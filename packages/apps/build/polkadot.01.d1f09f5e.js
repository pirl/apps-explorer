((typeof self !== 'undefined' ? self : this)["webpackJsonp"] = (typeof self !== 'undefined' ? self : this)["webpackJsonp"] || []).push([["polkadot.01"],{

/***/ "../../node_modules/@polkadot/api-contract/Abi.js":
/*!*************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-contract/Abi.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js"));

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _ContractRegistry = _interopRequireDefault(__webpack_require__(/*! ./ContractRegistry */ "../../node_modules/@polkadot/api-contract/ContractRegistry.js"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function findMessage(list, messageOrId) {
  const message = (0, _util.isNumber)(messageOrId) ? list[messageOrId] : (0, _util.isString)(messageOrId) ? list.find(({
    identifier
  }) => identifier === messageOrId.toString()) : messageOrId;
  (0, _util.assert)(message, `Attempted to call an invalid contract interface, ${JSON.stringify(messageOrId)}`);
  return message;
}

class Abi extends _ContractRegistry.default {
  constructor(abiJson, chainProperties) {
    const json = (0, _util.isString)(abiJson) ? JSON.parse(abiJson) : abiJson;
    (0, _util.assert)((0, _util.isObject)(json) && !Array.isArray(json) && json.metadataVersion && (0, _util.isObject)(json.spec) && !Array.isArray(json.spec) && Array.isArray(json.spec.constructors) && Array.isArray(json.spec.messages), 'Invalid JSON ABI structure supplied, expected a recent metadata version');
    super(json, chainProperties);
    this.constructors = void 0;
    this.json = void 0;
    this.messages = void 0;
    this.json = json;
    this.constructors = this.project.spec.constructors.map((spec, index) => this._createBase(spec, index, {
      isConstructor: true
    }));
    this.messages = this.project.spec.messages.map((spec, index) => {
      const typeSpec = spec.returnType.unwrapOr(null);
      return this._createBase(spec, index, {
        isMutating: spec.mutates.isTrue,
        isPayable: spec.payable.isTrue,
        returnType: typeSpec ? this.typeDefAt(typeSpec.type) : null
      });
    });
  }

  findConstructor(constructorOrId) {
    return findMessage(this.constructors, constructorOrId);
  }

  findMessage(messageOrId) {
    return findMessage(this.messages, messageOrId);
  }

  _createBase(spec, index, add = {}) {
    const identifier = spec.name.toString();
    const args = spec.args.map((arg, index) => {
      try {
        (0, _util.assert)((0, _util.isObject)(arg.type), 'Invalid type definition found');
        return {
          name: (0, _util.stringCamelCase)(arg.name.toString()),
          type: this.typeDefAt(arg.type.type)
        };
      } catch (error) {
        console.error(`Error expanding argument ${index} in ${JSON.stringify(spec)}`);
        throw error;
      }
    });
    return _objectSpread(_objectSpread({}, add), {}, {
      args,
      docs: spec.docs.map(doc => doc.toString()),
      identifier,
      index,
      selector: spec.selector
    });
  }

}

exports.default = Abi;

/***/ }),

/***/ "../../node_modules/@polkadot/api-contract/ContractRegistry.js":
/*!**************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-contract/ContractRegistry.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getRegistryOffset = getRegistryOffset;
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js"));

var _types = __webpack_require__(/*! @polkadot/types/types */ "../../node_modules/@polkadot/types/types/index.js");

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _types2 = __webpack_require__(/*! @polkadot/types */ "../../node_modules/@polkadot/types/index.js");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// convert the offset into project-specific, index-1
function getRegistryOffset(id) {
  return id.toNumber() - 1;
}

class ContractRegistry {
  constructor(json, chainProperties) {
    this.typeDefs = [];
    this.registry = void 0;
    this.project = void 0;
    this.registry = new _types2.TypeRegistry();

    if (chainProperties) {
      this.registry.setChainProperties(chainProperties);
    }

    this.project = this.registry.createType('InkProject', json); // Generate TypeDefs for each provided registry type

    this.project.types.forEach((_, index) => this.typeDefAt(this.registry.createType('MtLookupTypeId', index + 1)));
  }

  getAbiType(id) {
    const type = this.project.types[getRegistryOffset(id)];
    (0, _util.assert)(!(0, _util.isUndefined)(type), `getAbiType:: Unable to find ${id.toNumber()} in type values`);
    return this.registry.createType('MtType', type);
  }

  typeDefAt(id) {
    const offset = getRegistryOffset(id);
    let typeDef = this.typeDefs[offset];

    if (!typeDef) {
      typeDef = this.extractType(this.getAbiType(id), id);
      this.typeDefs[offset] = typeDef; // Here we protect against the following cases
      //   - No displayName present, these are generally known primitives
      //   - displayName === type, these generate circular references
      //   - displayName Option & type Option<...something...>

      if (typeDef.displayName && !(typeDef.type === typeDef.displayName || typeDef.type.startsWith(`${typeDef.displayName}<`))) {
        this.registry.register({
          [typeDef.displayName]: typeDef.type
        });
      }
    }

    return typeDef;
  }

  extractType(inkType, id) {
    var _path$pop;

    const path = [...inkType.path];
    let typeDef;

    if (inkType.path.join('::').startsWith('ink_env::types::') || inkType.def.isPrimitive) {
      typeDef = this.extractPrimitive(inkType);
    } else if (inkType.def.isComposite) {
      typeDef = this.extractFields(inkType.def.asComposite.fields);
    } else if (inkType.def.isVariant) {
      typeDef = this.extractVariant(inkType.def.asVariant, id);
    } else if (inkType.def.isArray) {
      typeDef = this.extractArray(inkType.def.asArray);
    } else if (inkType.def.isSequence) {
      typeDef = this.extractSequence(inkType.def.asSequence, id);
    } else if (inkType.def.isTuple) {
      typeDef = this.extractTuple(inkType.def.asTuple);
    } else {
      throw new Error(`Invalid ink! type at index ${id.toString()}`);
    }

    const displayName = (_path$pop = path.pop()) === null || _path$pop === void 0 ? void 0 : _path$pop.toString();
    return (0, _types2.withTypeString)(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, displayName ? {
      displayName
    } : {}), path.length > 1 ? {
      namespace: path.map(segment => segment.toString()).join('::')
    } : {}), inkType.params.length > 0 ? {
      params: inkType.params.map(id => this.typeDefAt(id))
    } : {}), typeDef));
  }

  extractVariant({
    variants
  }, id) {
    const {
      params,
      path
    } = this.getAbiType(id);
    const specialVariant = path[0].toString();

    if (specialVariant === 'Option') {
      return {
        info: _types.TypeDefInfo.Option,
        sub: this.typeDefAt(params[0])
      };
    } else if (specialVariant === 'Result') {
      return {
        info: _types.TypeDefInfo.Result,
        sub: params.map((param, index) => _objectSpread({
          name: ['Ok', 'Error'][index]
        }, this.typeDefAt(param)))
      };
    }

    return {
      info: _types.TypeDefInfo.Enum,
      sub: this.extractVariantSub(variants)
    };
  }

  extractVariantSub(variants) {
    const isAllUnitVariants = variants.every(({
      fields
    }) => fields.length === 0);

    if (isAllUnitVariants) {
      return variants.map(({
        discriminant,
        name
      }) => _objectSpread(_objectSpread({}, discriminant.isSome ? {
        ext: {
          discriminant: discriminant.unwrap().toNumber()
        }
      } : {}), {}, {
        info: _types.TypeDefInfo.Plain,
        name: name.toString(),
        type: 'Null'
      }));
    }

    return variants.map(({
      fields,
      name
    }) => (0, _types2.withTypeString)(_objectSpread(_objectSpread({}, this.extractFields(fields)), {}, {
      name: name.toString()
    })));
  }

  extractFields(fields) {
    const [isStruct, isTuple] = fields.reduce(([isAllNamed, isAllUnnamed], {
      name
    }) => [isAllNamed && name.isSome, isAllUnnamed && name.isNone], [true, true]);
    let info; // check for tuple first (no fields may be available)

    if (isTuple) {
      info = _types.TypeDefInfo.Tuple;
    } else if (isStruct) {
      info = _types.TypeDefInfo.Struct;
    } else {
      throw new Error('Invalid fields type detected, expected either Tuple or Struct');
    }

    const sub = fields.map(({
      name,
      type
    }) => {
      return _objectSpread(_objectSpread({}, this.typeDefAt(type)), name.isSome ? {
        name: name.unwrap().toString()
      } : {});
    });
    return isTuple && sub.length === 1 ? sub[0] : {
      info,
      sub
    };
  }

  extractArray({
    len: length,
    type
  }) {
    (0, _util.assert)(!length || length.toNumber() <= 256, 'ContractRegistry: Only support for [Type; <length>], where length > 256');
    return {
      info: _types.TypeDefInfo.VecFixed,
      length: length.toNumber(),
      sub: this.typeDefAt(type)
    };
  }

  extractSequence({
    type
  }, id) {
    (0, _util.assert)(!!type, `ContractRegistry: Invalid sequence type found at id ${id.toString()}`);
    return {
      info: _types.TypeDefInfo.Vec,
      sub: this.typeDefAt(type)
    };
  }

  extractTuple(ids) {
    return ids.length === 1 ? this.typeDefAt(ids[0]) : {
      info: _types.TypeDefInfo.Tuple,
      sub: ids.map(id => this.typeDefAt(id))
    };
  }

  extractPrimitive(inkType) {
    if (inkType.def.isPrimitive) {
      return {
        info: _types.TypeDefInfo.Plain,
        type: inkType.def.asPrimitive.type.toLowerCase()
      };
    } else if (inkType.path.length > 1) {
      return {
        info: _types.TypeDefInfo.Plain,
        type: inkType.path[inkType.path.length - 1].toString()
      };
    }

    throw new Error('Invalid primitive type');
  }

}

exports.default = ContractRegistry;

/***/ }),

/***/ "../../node_modules/@polkadot/api-contract/base/Base.js":
/*!*******************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-contract/base/Base.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _Abi = _interopRequireDefault(__webpack_require__(/*! ../Abi */ "../../node_modules/@polkadot/api-contract/Abi.js"));

// Copyright 2017-2020 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0
class Base {
  constructor(api, abi, decorateMethod) {
    this.abi = void 0;
    this.api = void 0;
    this.registry = void 0;
    this._decorateMethod = void 0;
    this.abi = abi instanceof _Abi.default ? abi : new _Abi.default(abi, api.registry.getChainProperties());
    this.api = api;
    this.registry = this.abi.registry;
    this._decorateMethod = decorateMethod;
    (0, _util.assert)(this.api.rx.tx.contracts && this.api.rx.tx.contracts.putCode, 'You need to connect to a node with the contracts module, the metadata does not enable api.tx.contracts on this instance');
  }

}

exports.default = Base;

/***/ }),

/***/ "../../node_modules/@polkadot/api-contract/base/Blueprint.js":
/*!************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-contract/base/Blueprint.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.BlueprintSubmittableResult = void 0;

var _classPrivateFieldLooseBase2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classPrivateFieldLooseBase */ "../../node_modules/@babel/runtime/helpers/classPrivateFieldLooseBase.js"));

var _classPrivateFieldLooseKey2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classPrivateFieldLooseKey */ "../../node_modules/@babel/runtime/helpers/classPrivateFieldLooseKey.js"));

var _api = __webpack_require__(/*! @polkadot/api */ "../../node_modules/@polkadot/api/index.js");

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _util2 = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-contract/util.js");

var _Base = _interopRequireDefault(__webpack_require__(/*! ./Base */ "../../node_modules/@polkadot/api-contract/base/Base.js"));

var _Contract = _interopRequireDefault(__webpack_require__(/*! ./Contract */ "../../node_modules/@polkadot/api-contract/base/Contract.js"));

// Copyright 2017-2020 @polkadot/api-contract authors & contributors
// SPDX-License-Identifier: Apache-2.0
class BlueprintSubmittableResult extends _api.SubmittableResult {
  constructor(result, contract) {
    super(result);
    this.contract = void 0;
    this.contract = contract;
  }

}

exports.BlueprintSubmittableResult = BlueprintSubmittableResult;

var _tx = (0, _classPrivateFieldLooseKey2.default)("tx");

var _deploy = (0, _classPrivateFieldLooseKey2.default)("deploy");

class Blueprint extends _Base.default {
  constructor(api, abi, codeHash, decorateMethod) {
    super(api, abi, decorateMethod);
    this.codeHash = void 0;
    Object.defineProperty(this, _tx, {
      writable: true,
      value: {}
    });
    Object.defineProperty(this, _deploy, {
      writable: true,
      value: (constructorOrId, endowment, gasLimit, params) => {
        return this.api.tx.contracts.instantiate(endowment, gasLimit, this.codeHash, (0, _util2.encodeMessage)(this.registry, this.abi.findConstructor(constructorOrId), params)).withResultTransform(result => new BlueprintSubmittableResult(result, (0, _util2.applyOnEvent)(result, 'Instantiated', record => new _Contract.default(this.api, this.abi, record.event.data[1], this._decorateMethod))));
      }
    });
    this.codeHash = this.registry.createType('Hash', codeHash);
    this.abi.constructors.forEach(c => {
      const messageName = (0, _util.stringCamelCase)(c.identifier);

      if ((0, _util.isUndefined)((0, _classPrivateFieldLooseBase2.default)(this, _tx)[_tx][messageName])) {
        (0, _classPrivateFieldLooseBase2.default)(this, _tx)[_tx][messageName] = (endowment, gasLimit, ...params) => (0, _classPrivateFieldLooseBase2.default)(this, _deploy)[_deploy](c, endowment, gasLimit, params);
      }
    });
  }

  get tx() {
    return (0, _classPrivateFieldLooseBase2.default)(this, _tx)[_tx];
  }

  createContract(constructorOrId, endowment, gasLimit, ...params) {
    return (0, _classPrivateFieldLooseBase2.default)(this, _deploy)[_deploy](constructorOrId, endowment, gasLimit, params);
  }

}

exports.default = Blueprint;

/***/ }),

/***/ "../../node_modules/@polkadot/api-contract/base/Code.js":
/*!*******************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-contract/base/Code.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.CodeSubmittableResult = void 0;

var _api = __webpack_require__(/*! @polkadot/api */ "../../node_modules/@polkadot/api/index.js");

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _util2 = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-contract/util.js");

var _Base = _interopRequireDefault(__webpack_require__(/*! ./Base */ "../../node_modules/@polkadot/api-contract/base/Base.js"));

var _Blueprint = _interopRequireDefault(__webpack_require__(/*! ./Blueprint */ "../../node_modules/@polkadot/api-contract/base/Blueprint.js"));

// Copyright 2017-2020 @polkadot/api-contract authors & contributors
// SPDX-License-Identifier: Apache-2.0
class CodeSubmittableResult extends _api.SubmittableResult {
  constructor(result, blueprint) {
    super(result);
    this.blueprint = void 0;
    this.blueprint = blueprint;
  }

}

exports.CodeSubmittableResult = CodeSubmittableResult;

class Code extends _Base.default {
  constructor(api, abi, wasm, decorateMethod) {
    super(api, abi, decorateMethod);
    this.code = void 0;
    this.code = (0, _util.u8aToU8a)(wasm);
  }

  createBlueprint() {
    return this.api.tx.contracts.putCode((0, _util.compactAddLength)(this.code)).withResultTransform(result => new CodeSubmittableResult(result, (0, _util2.applyOnEvent)(result, 'CodeStored', record => new _Blueprint.default(this.api, this.abi, record.event.data[0], this._decorateMethod))));
  }

}

exports.default = Code;

/***/ }),

/***/ "../../node_modules/@polkadot/api-contract/base/Contract.js":
/*!***********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-contract/base/Contract.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classPrivateFieldLooseBase2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classPrivateFieldLooseBase */ "../../node_modules/@babel/runtime/helpers/classPrivateFieldLooseBase.js"));

var _classPrivateFieldLooseKey2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classPrivateFieldLooseKey */ "../../node_modules/@babel/runtime/helpers/classPrivateFieldLooseKey.js"));

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _util2 = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-contract/util.js");

var _Base = _interopRequireDefault(__webpack_require__(/*! ./Base */ "../../node_modules/@polkadot/api-contract/base/Base.js"));

// Copyright 2017-2020 @polkadot/api-contract authors & contributors
// SPDX-License-Identifier: Apache-2.0
const ERROR_NO_CALL = 'Your node does not expose the contracts.call RPC. This is most probably due to a runtime configuration.';

var _tx = (0, _classPrivateFieldLooseKey2.default)("tx");

var _query = (0, _classPrivateFieldLooseKey2.default)("query");

var _exec = (0, _classPrivateFieldLooseKey2.default)("exec");

var _read = (0, _classPrivateFieldLooseKey2.default)("read");

class Contract extends _Base.default {
  constructor(api, abi, address, decorateMethod) {
    super(api, abi, decorateMethod);
    this.address = void 0;
    Object.defineProperty(this, _tx, {
      writable: true,
      value: {}
    });
    Object.defineProperty(this, _query, {
      writable: true,
      value: {}
    });
    Object.defineProperty(this, _exec, {
      writable: true,
      value: (messageOrId, value, gasLimit, params) => {
        return this.api.tx.contracts.call(this.address, value, gasLimit, (0, _util2.encodeMessage)(this.registry, this.abi.findMessage(messageOrId), params));
      }
    });
    Object.defineProperty(this, _read, {
      writable: true,
      value: (messageOrId, value, gasLimit, params) => {
        (0, _util.assert)(this.hasRpcContractsCall, ERROR_NO_CALL);
        const message = this.abi.findMessage(messageOrId);
        return {
          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
          send: this._decorateMethod(origin => this.api.rx.rpc.contracts.call({
            dest: this.address,
            gasLimit,
            inputData: (0, _util2.encodeMessage)(this.registry, message, params),
            origin,
            value
          }).pipe((0, _operators.map)(result => ({
            output: result.isSuccess && message.returnType ? (0, _util2.formatData)(this.registry, result.asSuccess.data, message.returnType) : null,
            result
          }))))
        };
      }
    });
    this.address = this.registry.createType('AccountId', address);
    this.abi.messages.forEach(m => {
      const messageName = (0, _util.stringCamelCase)(m.identifier);

      if ((0, _util.isUndefined)((0, _classPrivateFieldLooseBase2.default)(this, _tx)[_tx][messageName])) {
        (0, _classPrivateFieldLooseBase2.default)(this, _tx)[_tx][messageName] = (value, gasLimit, ...params) => (0, _classPrivateFieldLooseBase2.default)(this, _exec)[_exec](m, value, gasLimit, params);
      }

      if ((0, _util.isUndefined)((0, _classPrivateFieldLooseBase2.default)(this, _query)[_query][messageName])) {
        (0, _classPrivateFieldLooseBase2.default)(this, _query)[_query][messageName] = (origin, value, gasLimit, ...params) => (0, _classPrivateFieldLooseBase2.default)(this, _read)[_read](m, value, gasLimit, params).send(origin);
      }
    });
  }

  get hasRpcContractsCall() {
    var _this$api$rx$rpc$cont;

    return (0, _util.isFunction)((_this$api$rx$rpc$cont = this.api.rx.rpc.contracts) === null || _this$api$rx$rpc$cont === void 0 ? void 0 : _this$api$rx$rpc$cont.call);
  }

  get query() {
    (0, _util.assert)(this.hasRpcContractsCall, ERROR_NO_CALL);
    return (0, _classPrivateFieldLooseBase2.default)(this, _query)[_query];
  }

  get tx() {
    return (0, _classPrivateFieldLooseBase2.default)(this, _tx)[_tx];
  }

  exec(messageOrId, value, gasLimit, ...params) {
    return (0, _classPrivateFieldLooseBase2.default)(this, _exec)[_exec](messageOrId, value, gasLimit, params);
  }

  read(messageOrId, value, gasLimit, ...params) {
    return (0, _classPrivateFieldLooseBase2.default)(this, _read)[_read](messageOrId, value, gasLimit, params);
  }

}

exports.default = Contract;

/***/ }),

/***/ "../../node_modules/@polkadot/api-contract/index.js":
/*!***************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-contract/index.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Abi", {
  enumerable: true,
  get: function () {
    return _Abi.default;
  }
});
Object.defineProperty(exports, "BlueprintRx", {
  enumerable: true,
  get: function () {
    return _rx.Blueprint;
  }
});
Object.defineProperty(exports, "CodeRx", {
  enumerable: true,
  get: function () {
    return _rx.Code;
  }
});
Object.defineProperty(exports, "ContractRx", {
  enumerable: true,
  get: function () {
    return _rx.Contract;
  }
});
Object.defineProperty(exports, "BlueprintPromise", {
  enumerable: true,
  get: function () {
    return _promise.Blueprint;
  }
});
Object.defineProperty(exports, "CodePromise", {
  enumerable: true,
  get: function () {
    return _promise.Code;
  }
});
Object.defineProperty(exports, "ContractPromise", {
  enumerable: true,
  get: function () {
    return _promise.Contract;
  }
});

var _Abi = _interopRequireDefault(__webpack_require__(/*! ./Abi */ "../../node_modules/@polkadot/api-contract/Abi.js"));

var _rx = __webpack_require__(/*! ./rx */ "../../node_modules/@polkadot/api-contract/rx/index.js");

var _promise = __webpack_require__(/*! ./promise */ "../../node_modules/@polkadot/api-contract/promise/index.js");

/***/ }),

/***/ "../../node_modules/@polkadot/api-contract/promise/Blueprint.js":
/*!***************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-contract/promise/Blueprint.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _promise = __webpack_require__(/*! @polkadot/api/promise */ "../../node_modules/@polkadot/api/promise/index.js");

var _Blueprint = _interopRequireDefault(__webpack_require__(/*! ../base/Blueprint */ "../../node_modules/@polkadot/api-contract/base/Blueprint.js"));

// Copyright 2017-2020 @polkadot/api-contract authors & contributors
// SPDX-License-Identifier: Apache-2.0
class Blueprint extends _Blueprint.default {
  constructor(api, abi, codeHash) {
    super(api, abi, codeHash, _promise.decorateMethod);
  }

}

exports.default = Blueprint;

/***/ }),

/***/ "../../node_modules/@polkadot/api-contract/promise/Code.js":
/*!**********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-contract/promise/Code.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _promise = __webpack_require__(/*! @polkadot/api/promise */ "../../node_modules/@polkadot/api/promise/index.js");

var _Code = _interopRequireDefault(__webpack_require__(/*! ../base/Code */ "../../node_modules/@polkadot/api-contract/base/Code.js"));

// Copyright 2017-2020 @polkadot/api-contract authors & contributors
// SPDX-License-Identifier: Apache-2.0
class Code extends _Code.default {
  constructor(api, abi, wasm) {
    super(api, abi, wasm, _promise.decorateMethod);
  }

}

exports.default = Code;

/***/ }),

/***/ "../../node_modules/@polkadot/api-contract/promise/Contract.js":
/*!**************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-contract/promise/Contract.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _promise = __webpack_require__(/*! @polkadot/api/promise */ "../../node_modules/@polkadot/api/promise/index.js");

var _Contract = _interopRequireDefault(__webpack_require__(/*! ../base/Contract */ "../../node_modules/@polkadot/api-contract/base/Contract.js"));

// Copyright 2017-2020 @polkadot/api-contract authors & contributors
// SPDX-License-Identifier: Apache-2.0
class Contract extends _Contract.default {
  constructor(api, abi, address) {
    super(api, abi, address, _promise.decorateMethod);
  }

}

exports.default = Contract;

/***/ }),

/***/ "../../node_modules/@polkadot/api-contract/promise/index.js":
/*!***********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-contract/promise/index.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Blueprint", {
  enumerable: true,
  get: function () {
    return _Blueprint.default;
  }
});
Object.defineProperty(exports, "Code", {
  enumerable: true,
  get: function () {
    return _Code.default;
  }
});
Object.defineProperty(exports, "Contract", {
  enumerable: true,
  get: function () {
    return _Contract.default;
  }
});

var _Blueprint = _interopRequireDefault(__webpack_require__(/*! ./Blueprint */ "../../node_modules/@polkadot/api-contract/promise/Blueprint.js"));

var _Code = _interopRequireDefault(__webpack_require__(/*! ./Code */ "../../node_modules/@polkadot/api-contract/promise/Code.js"));

var _Contract = _interopRequireDefault(__webpack_require__(/*! ./Contract */ "../../node_modules/@polkadot/api-contract/promise/Contract.js"));

/***/ }),

/***/ "../../node_modules/@polkadot/api-contract/rx/Blueprint.js":
/*!**********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-contract/rx/Blueprint.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _rx = __webpack_require__(/*! @polkadot/api/rx */ "../../node_modules/@polkadot/api/rx/index.js");

var _Blueprint = _interopRequireDefault(__webpack_require__(/*! ../base/Blueprint */ "../../node_modules/@polkadot/api-contract/base/Blueprint.js"));

// Copyright 2017-2020 @polkadot/api-contract authors & contributors
// SPDX-License-Identifier: Apache-2.0
class Blueprint extends _Blueprint.default {
  constructor(api, abi, codeHash) {
    super(api, abi, codeHash, _rx.decorateMethod);
  }

}

exports.default = Blueprint;

/***/ }),

/***/ "../../node_modules/@polkadot/api-contract/rx/Code.js":
/*!*****************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-contract/rx/Code.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _rx = __webpack_require__(/*! @polkadot/api/rx */ "../../node_modules/@polkadot/api/rx/index.js");

var _Code = _interopRequireDefault(__webpack_require__(/*! ../base/Code */ "../../node_modules/@polkadot/api-contract/base/Code.js"));

// Copyright 2017-2020 @polkadot/api-contract authors & contributors
// SPDX-License-Identifier: Apache-2.0
class Code extends _Code.default {
  constructor(api, abi, wasm) {
    super(api, abi, wasm, _rx.decorateMethod);
  }

}

exports.default = Code;

/***/ }),

/***/ "../../node_modules/@polkadot/api-contract/rx/Contract.js":
/*!*********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-contract/rx/Contract.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _rx = __webpack_require__(/*! @polkadot/api/rx */ "../../node_modules/@polkadot/api/rx/index.js");

var _Contract = _interopRequireDefault(__webpack_require__(/*! ../base/Contract */ "../../node_modules/@polkadot/api-contract/base/Contract.js"));

// Copyright 2017-2020 @polkadot/api-contract authors & contributors
// SPDX-License-Identifier: Apache-2.0
class Contract extends _Contract.default {
  constructor(api, abi, address) {
    super(api, abi, address, _rx.decorateMethod);
  }

}

exports.default = Contract;

/***/ }),

/***/ "../../node_modules/@polkadot/api-contract/rx/index.js":
/*!******************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-contract/rx/index.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Blueprint", {
  enumerable: true,
  get: function () {
    return _Blueprint.default;
  }
});
Object.defineProperty(exports, "Code", {
  enumerable: true,
  get: function () {
    return _Code.default;
  }
});
Object.defineProperty(exports, "Contract", {
  enumerable: true,
  get: function () {
    return _Contract.default;
  }
});

var _Blueprint = _interopRequireDefault(__webpack_require__(/*! ./Blueprint */ "../../node_modules/@polkadot/api-contract/rx/Blueprint.js"));

var _Code = _interopRequireDefault(__webpack_require__(/*! ./Code */ "../../node_modules/@polkadot/api-contract/rx/Code.js"));

var _Contract = _interopRequireDefault(__webpack_require__(/*! ./Contract */ "../../node_modules/@polkadot/api-contract/rx/Contract.js"));

/***/ }),

/***/ "../../node_modules/@polkadot/api-contract/util.js":
/*!**************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-contract/util.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.formatData = formatData;
exports.applyOnEvent = applyOnEvent;
exports.encodeMessage = encodeMessage;

var _types = __webpack_require__(/*! @polkadot/types */ "../../node_modules/@polkadot/types/index.js");

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

// Copyright 2017-2020 @polkadot/rpc-core authors & contributors
// SPDX-License-Identifier: Apache-2.0
function formatData(registry, data, {
  type
}) {
  return (0, _types.createTypeUnsafe)(registry, type, [data], true);
}

function applyOnEvent(result, type, fn) {
  if (result.isInBlock || result.isFinalized) {
    const record = result.findRecord('contracts', type);

    if (record) {
      return fn(record);
    }
  }

  return undefined;
}

function encodeMessage(registry, message, params) {
  (0, _util.assert)(message, 'Attempted to call an invalid contract message');
  (0, _util.assert)(params.length === message.args.length, `Expected ${message.args.length} arguments to contract message '${message.identifier}', found ${params.length}`);
  const Clazz = (0, _types.createClass)(registry, JSON.stringify(message.args.reduce((r, {
    name,
    type
  }) => {
    r[name] = type.displayName || (0, _types.encodeTypeDef)(type);
    return r;
  }, {
    __selector: 'InkSelector'
  })));
  return (0, _util.compactAddLength)(new Clazz(registry, message.args.reduce((r, {
    name
  }, index) => {
    r[name] = params[index];
    return r;
  }, {
    __selector: message.selector
  })).toU8a());
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/accounts/accountId.js":
/*!**************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/accounts/accountId.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.accountId = accountId;

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _utilCrypto = __webpack_require__(/*! @polkadot/util-crypto */ "../../node_modules/@polkadot/util-crypto/index.js");

var _util2 = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
function retrieve(api, address) {
  const decoded = (0, _util.isU8a)(address) ? address : (0, _utilCrypto.decodeAddress)((address || '').toString());

  if (decoded.length === 32) {
    return (0, _rxjs.of)(api.registry.createType('AccountId', decoded));
  }

  const accountIndex = api.registry.createType('AccountIndex', decoded);
  return api.derive.accounts.indexToId(accountIndex.toString()).pipe((0, _operators.map)(accountId => {
    (0, _util.assert)(accountId, 'Unable to retrieve accountId');
    return accountId;
  }));
}
/**
 * @name accountId
 * @param {(Address | AccountId | AccountIndex | string | null)} address - An accounts address in various formats.
 * @description  An [[AccountId]]
 */


function accountId(instanceId, api) {
  return (0, _util2.memo)(instanceId, address => retrieve(api, address));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/accounts/flags.js":
/*!**********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/accounts/flags.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.flags = flags;

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
function isIncludedFn(accountId) {
  return function (id) {
    return id.toString() === accountId.toString();
  };
}
/**
 * @name info
 * @description Returns account membership flags
 */


function flags(instanceId, api) {
  return (0, _util.memo)(instanceId, address => {
    var _api$query$councilSec, _api$query$council, _api$query$technicalC, _api$query$society, _api$query$sudo;

    const councilSection = api.query.electionsPhragmen ? 'electionsPhragmen' : 'elections';
    return (0, _rxjs.combineLatest)([address && ((_api$query$councilSec = api.query[councilSection]) === null || _api$query$councilSec === void 0 ? void 0 : _api$query$councilSec.members) ? api.query[councilSection].members() : (0, _rxjs.of)(undefined), address && ((_api$query$council = api.query.council) === null || _api$query$council === void 0 ? void 0 : _api$query$council.members) ? api.query.council.members() : (0, _rxjs.of)([]), address && ((_api$query$technicalC = api.query.technicalCommittee) === null || _api$query$technicalC === void 0 ? void 0 : _api$query$technicalC.members) ? api.query.technicalCommittee.members() : (0, _rxjs.of)([]), address && ((_api$query$society = api.query.society) === null || _api$query$society === void 0 ? void 0 : _api$query$society.members) ? api.query.society.members() : (0, _rxjs.of)([]), address && ((_api$query$sudo = api.query.sudo) === null || _api$query$sudo === void 0 ? void 0 : _api$query$sudo.key) ? api.query.sudo.key() : (0, _rxjs.of)(undefined)]).pipe((0, _operators.map)(([electionsMembers, councilMembers, technicalCommitteeMembers, societyMembers, sudoKey]) => {
      const isIncluded = address ? isIncludedFn(address) : () => false;
      return {
        isCouncil: ((electionsMembers === null || electionsMembers === void 0 ? void 0 : electionsMembers.map(([id]) => id)) || councilMembers || []).some(isIncluded),
        isSociety: (societyMembers || []).some(isIncluded),
        isSudo: (sudoKey === null || sudoKey === void 0 ? void 0 : sudoKey.toString()) === (address === null || address === void 0 ? void 0 : address.toString()),
        isTechCommittee: (technicalCommitteeMembers || []).some(isIncluded)
      };
    }));
  });
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/accounts/idAndIndex.js":
/*!***************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/accounts/idAndIndex.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.idAndIndex = idAndIndex;

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _utilCrypto = __webpack_require__(/*! @polkadot/util-crypto */ "../../node_modules/@polkadot/util-crypto/index.js");

var _util2 = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
function retrieve(api, address) {
  try {
    // yes, this can fail, don't care too much, catch will catch it
    const decoded = (0, _util.isU8a)(address) ? address : (0, _utilCrypto.decodeAddress)((address || '').toString());

    if (decoded.length === 32) {
      const accountId = api.registry.createType('AccountId', decoded);
      return api.derive.accounts.idToIndex(accountId).pipe((0, _operators.map)(accountIndex => [accountId, accountIndex]));
    }

    const accountIndex = api.registry.createType('AccountIndex', decoded);
    return api.derive.accounts.indexToId(accountIndex.toString()).pipe((0, _operators.map)(accountId => [accountId, accountIndex]));
  } catch (error) {
    return (0, _rxjs.of)([undefined, undefined]);
  }
}
/**
 * @name idAndIndex
 * @param {(Address | AccountId | AccountIndex | string | null)} address - An accounts address in various formats.
 * @description  An array containing the [[AccountId]] and [[AccountIndex]] as optional values.
 * @example
 * <BR>
 *
 * ```javascript
 * api.derive.accounts.idAndIndex('F7Hs', ([id, ix]) => {
 *   console.log(`AccountId #${id} with corresponding AccountIndex ${ix}`);
 * });
 * ```
 */


function idAndIndex(instanceId, api) {
  return (0, _util2.memo)(instanceId, address => retrieve(api, address));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/accounts/idToIndex.js":
/*!**************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/accounts/idToIndex.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.idToIndex = idToIndex;

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name idToIndex
 * @param {( AccountId | string )} accountId - An accounts Id in different formats.
 * @returns Returns the corresponding AccountIndex.
 * @example
 * <BR>
 *
 * ```javascript
 * const ALICE = '5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY';
 * api.derive.accounts.idToIndex(ALICE, (accountIndex) => {
 *   console.log(`The AccountIndex of ${ALICE} is ${accountIndex}`);
 * });
 * ```
 */
function idToIndex(instanceId, api) {
  return (0, _util.memo)(instanceId, accountId => api.derive.accounts.indexes().pipe((0, _operators.map)(indexes => (indexes || {})[accountId.toString()])));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/accounts/index.js":
/*!**********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/accounts/index.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _accountId = __webpack_require__(/*! ./accountId */ "../../node_modules/@polkadot/api-derive/accounts/accountId.js");

Object.keys(_accountId).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _accountId[key];
    }
  });
});

var _flags = __webpack_require__(/*! ./flags */ "../../node_modules/@polkadot/api-derive/accounts/flags.js");

Object.keys(_flags).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _flags[key];
    }
  });
});

var _idAndIndex = __webpack_require__(/*! ./idAndIndex */ "../../node_modules/@polkadot/api-derive/accounts/idAndIndex.js");

Object.keys(_idAndIndex).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _idAndIndex[key];
    }
  });
});

var _idToIndex = __webpack_require__(/*! ./idToIndex */ "../../node_modules/@polkadot/api-derive/accounts/idToIndex.js");

Object.keys(_idToIndex).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _idToIndex[key];
    }
  });
});

var _indexToId = __webpack_require__(/*! ./indexToId */ "../../node_modules/@polkadot/api-derive/accounts/indexToId.js");

Object.keys(_indexToId).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _indexToId[key];
    }
  });
});

var _indexes = __webpack_require__(/*! ./indexes */ "../../node_modules/@polkadot/api-derive/accounts/indexes.js");

Object.keys(_indexes).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _indexes[key];
    }
  });
});

var _info = __webpack_require__(/*! ./info */ "../../node_modules/@polkadot/api-derive/accounts/info.js");

Object.keys(_info).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _info[key];
    }
  });
});

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/accounts/indexToId.js":
/*!**************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/accounts/indexToId.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.indexToId = indexToId;

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _AccountIndex = __webpack_require__(/*! @polkadot/types/generic/AccountIndex */ "../../node_modules/@polkadot/types/generic/AccountIndex.js");

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _util2 = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
function queryEnumSet(api, _accountIndex) {
  const accountIndex = _accountIndex instanceof api.registry.createClass('AccountIndex') ? _accountIndex : api.registry.createType('AccountIndex', _accountIndex);
  return api.query.indices.enumSet(accountIndex.div(_AccountIndex.ENUMSET_SIZE)).pipe((0, _operators.startWith)([]), (0, _operators.map)(accounts => (accounts || [])[accountIndex.mod(_AccountIndex.ENUMSET_SIZE).toNumber()]));
} // current


function query(api, accountIndex) {
  return api.query.indices.accounts(accountIndex).pipe((0, _operators.map)(optResult => optResult.unwrapOr([])[0]));
}
/**
 * @name indexToId
 * @param {( AccountIndex | string )} accountIndex - An accounts index in different formats.
 * @returns Returns the corresponding AccountId.
 * @example
 * <BR>
 *
 * ```javascript
 * api.derive.accounts.indexToId('F7Hs', (accountId) => {
 *   console.log(`The AccountId of F7Hs is ${accountId}`);
 * });
 * ```
 */


function indexToId(instanceId, api) {
  return (0, _util2.memo)(instanceId, accountIndex => api.query.indices ? (0, _util.isFunction)(api.query.indices.accounts) ? query(api, accountIndex) : queryEnumSet(api, accountIndex) : (0, _rxjs.of)(undefined));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/accounts/indexes.js":
/*!************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/accounts/indexes.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.indexes = indexes;

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _AccountIndex = __webpack_require__(/*! @polkadot/types/generic/AccountIndex */ "../../node_modules/@polkadot/types/generic/AccountIndex.js");

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _util2 = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
const enumsetSize = _AccountIndex.ENUMSET_SIZE.toNumber();

let indicesCache = null;

function queryEnumSet(api) {
  return api.query.indices.nextEnumSet().pipe( // use the nextEnumSet (which is a counter of the number of sets) to construct
  // a range of values to query [0, 1, 2, ...]. Retrieve the full enum set for the
  // specific index - each query can return up to ENUMSET_SIZE (64) records, each
  // containing an AccountId
  (0, _operators.switchMap)(next => api.query.indices.enumSet.multi([...Array(next.toNumber() + 1).keys()])), (0, _operators.map)(all => all.reduce((indexes, list, outerIndex) => {
    (list || []).forEach((accountId, innerIndex) => {
      // re-create the index based on position 0 is [0][0] and likewise
      // 64 (0..63 in first) is [1][0] (the first index value in set 2)
      const index = outerIndex * enumsetSize + innerIndex;
      indexes[accountId.toString()] = api.registry.createType('AccountIndex', index);
    });
    return indexes;
  }, {})));
}

function queryAccounts(api) {
  return api.query.indices.accounts.entries().pipe((0, _operators.map)(entries => entries.reduce((indexes, [key, idOpt]) => {
    if (idOpt.isSome) {
      indexes[idOpt.unwrap()[0].toString()] = key.args[0];
    }

    return indexes;
  }, {})));
}
/**
 * @name indexes
 * @returns Returns all the indexes on the system.
 * @description This is an unwieldly query since it loops through
 * all of the enumsets and returns all of the values found. This could be up to 32k depending
 * on the number of active accounts in the system
 * @example
 * <BR>
 *
 * ```javascript
 * api.derive.accounts.indexes((indexes) => {
 *   console.log('All existing AccountIndexes', indexes);
 * });
 * ```
 */


function indexes(instanceId, api) {
  return (0, _util2.memo)(instanceId, () => indicesCache ? (0, _rxjs.of)(indicesCache) : (api.query.indices ? (0, _util.isFunction)(api.query.indices.accounts) ? queryAccounts(api).pipe((0, _operators.startWith)({})) : queryEnumSet(api).pipe((0, _operators.startWith)({})) : (0, _rxjs.of)({})).pipe((0, _operators.map)(indices => {
    indicesCache = indices;
    return indices;
  })));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/accounts/info.js":
/*!*********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/accounts/info.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.info = info;

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _util2 = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
function dataAsString(data) {
  return data.isRaw ? (0, _util.u8aToString)(data.asRaw.toU8a(true)) : data.isNone ? undefined : data.toHex();
}

function retrieveNick(api, accountId) {
  var _api$query$nicks;

  return (accountId && ((_api$query$nicks = api.query.nicks) === null || _api$query$nicks === void 0 ? void 0 : _api$query$nicks.nameOf) ? api.query.nicks.nameOf(accountId) : (0, _rxjs.of)(undefined)).pipe((0, _operators.map)(nameOf => (nameOf === null || nameOf === void 0 ? void 0 : nameOf.isSome) ? (0, _util.u8aToString)(nameOf.unwrap()[0]).substr(0, api.consts.nicks.maxLength.toNumber()) : undefined));
}

function extractIdentity(identityOfOpt, superOf) {
  if (!(identityOfOpt === null || identityOfOpt === void 0 ? void 0 : identityOfOpt.isSome)) {
    return {
      judgements: []
    };
  }

  const {
    info,
    judgements
  } = identityOfOpt.unwrap();
  const topDisplay = dataAsString(info.display);
  return {
    display: superOf ? dataAsString(superOf[1]) || topDisplay : topDisplay,
    displayParent: superOf ? topDisplay : undefined,
    email: dataAsString(info.email),
    image: dataAsString(info.image),
    judgements,
    legal: dataAsString(info.legal),
    other: info.additional.reduce((other, [_key, _value]) => {
      const key = dataAsString(_key);
      const value = dataAsString(_value);

      if (key && value) {
        other[key] = value;
      }

      return other;
    }, {}),
    parent: superOf ? superOf[0] : undefined,
    pgp: info.pgpFingerprint.isSome ? info.pgpFingerprint.unwrap().toHex() : undefined,
    riot: dataAsString(info.riot),
    twitter: dataAsString(info.twitter),
    web: dataAsString(info.web)
  };
}

function retrieveIdentity(api, accountId) {
  var _api$query$identity;

  return (accountId && ((_api$query$identity = api.query.identity) === null || _api$query$identity === void 0 ? void 0 : _api$query$identity.identityOf) ? api.queryMulti([[api.query.identity.identityOf, accountId], [api.query.identity.superOf, accountId]]) : (0, _rxjs.of)([undefined, undefined])).pipe((0, _operators.switchMap)(([identityOfOpt, superOfOpt]) => {
    if (identityOfOpt === null || identityOfOpt === void 0 ? void 0 : identityOfOpt.isSome) {
      // this identity has something set
      return (0, _rxjs.of)([identityOfOpt, undefined]);
    } else if (superOfOpt === null || superOfOpt === void 0 ? void 0 : superOfOpt.isSome) {
      const superOf = superOfOpt.unwrap(); // we have a super

      return (0, _rxjs.combineLatest)([api.query.identity.identityOf(superOf[0]), (0, _rxjs.of)(superOf)]);
    } // nothing of value returned


    return (0, _rxjs.of)([undefined, undefined]);
  }), (0, _operators.map)(([identityOfOpt, superOf]) => extractIdentity(identityOfOpt, superOf)));
}
/**
 * @name info
 * @description Returns aux. info with regards to an account, current that includes the accountId, accountIndex and nickname
 */


function info(instanceId, api) {
  return (0, _util2.memo)(instanceId, address => api.derive.accounts.idAndIndex(address).pipe((0, _operators.switchMap)(([accountId, accountIndex]) => (0, _rxjs.combineLatest)([(0, _rxjs.of)({
    accountId,
    accountIndex
  }), retrieveIdentity(api, accountId), retrieveNick(api, accountId)])), (0, _operators.map)(([{
    accountId,
    accountIndex
  }, identity, nickname]) => ({
    accountId,
    accountIndex,
    identity,
    nickname
  }))));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/balances/account.js":
/*!************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/balances/account.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.account = account;

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _util2 = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
function calcBalances(api, [accountId, [freeBalance, reservedBalance, frozenFee, frozenMisc, accountNonce]]) {
  return {
    accountId,
    accountNonce,
    freeBalance,
    frozenFee,
    frozenMisc,
    reservedBalance,
    votingBalance: api.registry.createType('Balance', freeBalance.toBn())
  };
} // old


function queryBalancesFree(api, accountId) {
  return api.queryMulti([[api.query.balances.freeBalance, accountId], [api.query.balances.reservedBalance, accountId], [api.query.system.accountNonce, accountId]]).pipe((0, _operators.map)(([freeBalance, reservedBalance, accountNonce]) => [freeBalance, reservedBalance, api.registry.createType('Balance'), api.registry.createType('Balance'), accountNonce]));
}

function queryBalancesAccount(api, accountId) {
  return api.queryMulti([[api.query.balances.account, accountId], [api.query.system.accountNonce, accountId]]).pipe((0, _operators.map)(([{
    feeFrozen,
    free,
    miscFrozen,
    reserved
  }, accountNonce]) => [free, reserved, feeFrozen, miscFrozen, accountNonce]));
}

function queryCurrent(api, accountId) {
  // AccountInfo is current, support old, eg. Edgeware
  return api.query.system.account(accountId).pipe((0, _operators.map)(infoOrTuple => {
    const {
      feeFrozen,
      free,
      miscFrozen,
      reserved
    } = infoOrTuple.nonce ? infoOrTuple.data : infoOrTuple[1];
    const accountNonce = infoOrTuple.nonce || infoOrTuple[0];
    return [free, reserved, feeFrozen, miscFrozen, accountNonce];
  }));
}
/**
 * @name account
 * @param {( AccountIndex | AccountId | Address | string )} address - An accounts Id in different formats.
 * @returns An object containing the results of various balance queries
 * @example
 * <BR>
 *
 * ```javascript
 * const ALICE = 'F7Hs';
 *
 * api.derive.balances.all(ALICE, ({ accountId, lockedBalance }) => {
 *   console.log(`The account ${accountId} has a locked balance ${lockedBalance} units.`);
 * });
 * ```
 */


function account(instanceId, api) {
  return (0, _util2.memo)(instanceId, address => api.derive.accounts.accountId(address).pipe((0, _operators.switchMap)(accountId => accountId ? (0, _rxjs.combineLatest)([(0, _rxjs.of)(accountId), (0, _util.isFunction)(api.query.system.account) ? queryCurrent(api, accountId) : (0, _util.isFunction)(api.query.balances.account) ? queryBalancesAccount(api, accountId) : queryBalancesFree(api, accountId)]) : (0, _rxjs.of)([api.registry.createType('AccountId'), [api.registry.createType('Balance'), api.registry.createType('Balance'), api.registry.createType('Balance'), api.registry.createType('Balance'), api.registry.createType('Index')]])), (0, _operators.map)(result => calcBalances(api, result))));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/balances/all.js":
/*!********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/balances/all.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.all = all;

var _bn = _interopRequireDefault(__webpack_require__(/*! bn.js */ "../../node_modules/bn.js/lib/bn.js"));

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _util2 = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
const VESTING_ID = '0x76657374696e6720';

function calcBalances(api, [{
  accountId,
  accountNonce,
  freeBalance,
  frozenFee,
  frozenMisc,
  reservedBalance,
  votingBalance
}, bestNumber, [vesting, locks]]) {
  let lockedBalance = api.registry.createType('Balance');
  let lockedBreakdown = [];
  let vestingLocked = api.registry.createType('Balance');
  let allLocked = false;

  if (Array.isArray(locks)) {
    // only get the locks that are valid until passed the current block
    lockedBreakdown = locks.filter(({
      until
    }) => !until || bestNumber && until.gt(bestNumber));
    const notAll = lockedBreakdown.filter(({
      amount
    }) => !amount.isMax());
    allLocked = lockedBreakdown.some(({
      amount
    }) => amount.isMax());
    vestingLocked = api.registry.createType('Balance', lockedBreakdown.filter(({
      id
    }) => id.eq(VESTING_ID)).reduce((result, {
      amount
    }) => result.iadd(amount), new _bn.default(0))); // get the maximum of the locks according to https://github.com/paritytech/substrate/blob/master/srml/balances/src/lib.rs#L699

    if (notAll.length) {
      lockedBalance = api.registry.createType('Balance', (0, _util.bnMax)(...notAll.map(({
        amount
      }) => amount)));
    }
  } // Calculate the vesting balances,
  //  - offset = balance locked at startingBlock
  //  - perBlock is the unlock amount


  const {
    locked: vestingTotal,
    perBlock,
    startingBlock
  } = vesting || api.registry.createType('VestingInfo');
  const isStarted = bestNumber.gt(startingBlock);
  const vestedNow = isStarted ? perBlock.mul(bestNumber.sub(startingBlock)) : new _bn.default(0);
  const vestedBalance = vestedNow.gt(vestingTotal) ? vestingTotal : api.registry.createType('Balance', vestedNow);
  const isVesting = isStarted && !vestingLocked.isZero();
  const vestedClaimable = api.registry.createType('Balance', isVesting ? vestingLocked.sub(vestingTotal.sub(vestedBalance)) : 0);
  const availableBalance = api.registry.createType('Balance', allLocked ? 0 : (0, _util.bnMax)(new _bn.default(0), freeBalance.sub(lockedBalance)));
  const vestingEndBlock = api.registry.createType('BlockNumber', isVesting ? vestingTotal.div(perBlock).add(startingBlock) : 0);
  return {
    accountId,
    accountNonce,
    availableBalance,
    freeBalance,
    frozenFee,
    frozenMisc,
    isVesting,
    lockedBalance,
    lockedBreakdown,
    reservedBalance,
    vestedBalance,
    vestedClaimable,
    vestingEndBlock,
    vestingLocked,
    vestingPerBlock: perBlock,
    vestingTotal,
    votingBalance
  };
} // old


function queryOld(api, accountId) {
  return api.queryMulti([[api.query.balances.locks, accountId], [api.query.balances.vesting, accountId]]).pipe((0, _operators.map)(([locks, optVesting]) => {
    let vestingNew = null;

    if (optVesting.isSome) {
      const {
        offset: locked,
        perBlock,
        startingBlock
      } = optVesting.unwrap();
      vestingNew = api.registry.createType('VestingInfo', {
        locked,
        perBlock,
        startingBlock
      });
    }

    return [vestingNew, locks];
  }));
} // current (balances  vesting)


function queryCurrent(api, accountId) {
  var _api$query$vesting;

  return (((_api$query$vesting = api.query.vesting) === null || _api$query$vesting === void 0 ? void 0 : _api$query$vesting.vesting) ? api.queryMulti([[api.query.balances.locks, accountId], [api.query.vesting.vesting, accountId]]) : api.query.balances.locks(accountId).pipe((0, _operators.map)(locks => [locks, api.registry.createType('Option<VestingInfo>')]))).pipe((0, _operators.map)(([locks, optVesting]) => [optVesting.unwrapOr(null), locks]));
}
/**
 * @name all
 * @param {( AccountIndex | AccountId | Address | string )} address - An accounts Id in different formats.
 * @returns An object containing the results of various balance queries
 * @example
 * <BR>
 *
 * ```javascript
 * const ALICE = 'F7Hs';
 *
 * api.derive.balances.all(ALICE, ({ accountId, lockedBalance }) => {
 *   console.log(`The account ${accountId} has a locked balance ${lockedBalance} units.`);
 * });
 * ```
 */


function all(instanceId, api) {
  return (0, _util2.memo)(instanceId, address => api.derive.balances.account(address).pipe((0, _operators.switchMap)(account => !account.accountId.isEmpty ? (0, _rxjs.combineLatest)([(0, _rxjs.of)(account), api.derive.chain.bestNumber(), (0, _util.isFunction)(api.query.system.account) || (0, _util.isFunction)(api.query.balances.account) ? queryCurrent(api, account.accountId) : queryOld(api, account.accountId)]) : (0, _rxjs.of)([account, api.registry.createType('BlockNumber'), [null, api.registry.createType('Vec<BalanceLock>')]])), (0, _operators.map)(result => calcBalances(api, result))));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/balances/fees.js":
/*!*********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/balances/fees.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fees = fees;

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name fees
 * @returns An object containing the combined results of the storage queries for
 * all relevant fees as declared in the substrate chain spec.
 * @example
 * <BR>
 *
 * ```javascript
 * api.derive.balances.fees(({ creationFee, transferFee }) => {
 *   console.log(`The fee for creating a new account on this chain is ${creationFee} units. The fee required for making a transfer is ${transferFee} units.`);
 * });
 * ```
 */
function fees(instanceId, api) {
  return (0, _util.memo)(instanceId, () => {
    var _api$consts$balances, _api$consts$balances2, _api$consts$balances3, _api$consts$transacti, _api$consts$transacti2;

    return (0, _rxjs.of)([// deprecated - remove
    ((_api$consts$balances = api.consts.balances) === null || _api$consts$balances === void 0 ? void 0 : _api$consts$balances.creationFee) || api.registry.createType('Balance'), ((_api$consts$balances2 = api.consts.balances) === null || _api$consts$balances2 === void 0 ? void 0 : _api$consts$balances2.transferFee) || api.registry.createType('Balance'), // current
    ((_api$consts$balances3 = api.consts.balances) === null || _api$consts$balances3 === void 0 ? void 0 : _api$consts$balances3.existentialDeposit) || api.registry.createType('Balance'), ((_api$consts$transacti = api.consts.transactionPayment) === null || _api$consts$transacti === void 0 ? void 0 : _api$consts$transacti.transactionBaseFee) || api.registry.createType('Balance'), ((_api$consts$transacti2 = api.consts.transactionPayment) === null || _api$consts$transacti2 === void 0 ? void 0 : _api$consts$transacti2.transactionByteFee) || api.registry.createType('Balance')]).pipe((0, _operators.map)(([creationFee, transferFee, existentialDeposit, transactionBaseFee, transactionByteFee]) => ({
      creationFee,
      existentialDeposit,
      transactionBaseFee,
      transactionByteFee,
      transferFee
    })));
  });
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/balances/index.js":
/*!**********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/balances/index.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  votingBalance: true,
  all: true
};
Object.defineProperty(exports, "all", {
  enumerable: true,
  get: function () {
    return _all.all;
  }
});
exports.votingBalance = void 0;

var _all = __webpack_require__(/*! ./all */ "../../node_modules/@polkadot/api-derive/balances/all.js");

var _account = __webpack_require__(/*! ./account */ "../../node_modules/@polkadot/api-derive/balances/account.js");

Object.keys(_account).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _account[key];
    }
  });
});

var _fees = __webpack_require__(/*! ./fees */ "../../node_modules/@polkadot/api-derive/balances/fees.js");

Object.keys(_fees).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _fees[key];
    }
  });
});

var _votingBalances = __webpack_require__(/*! ./votingBalances */ "../../node_modules/@polkadot/api-derive/balances/votingBalances.js");

Object.keys(_votingBalances).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _votingBalances[key];
    }
  });
});
// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
const votingBalance = _all.all;
exports.votingBalance = votingBalance;

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/balances/votingBalances.js":
/*!*******************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/balances/votingBalances.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.votingBalances = votingBalances;

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _util = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
function votingBalances(instanceId, api) {
  return (0, _util.memo)(instanceId, addresses => !addresses || !addresses.length ? (0, _rxjs.of)([]) : (0, _rxjs.combineLatest)(addresses.map(accountId => api.derive.balances.account(accountId))));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/chain/bestNumber.js":
/*!************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/chain/bestNumber.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.bestNumber = bestNumber;

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name bestNumber
 * @returns The latest block number.
 * @example
 * <BR>
 *
 * ```javascript
 * api.derive.chain.bestNumber((blockNumber) => {
 *   console.log(`the current best block is #${blockNumber}`);
 * });
 * ```
 */
function bestNumber(instanceId, api) {
  return (0, _util.memo)(instanceId, () => api.derive.chain.subscribeNewHeads().pipe((0, _operators.map)(header => header.number.unwrap())));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/chain/bestNumberFinalized.js":
/*!*********************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/chain/bestNumberFinalized.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.bestNumberFinalized = bestNumberFinalized;

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name bestNumberFinalized
 * @returns A BlockNumber
 * @description Get the latest finalized block number.
 * @example
 * <BR>
 *
 * ```javascript
 * api.derive.chain.bestNumberFinalized((blockNumber) => {
 *   console.log(`the current finalized block is #${blockNumber}`);
 * });
 * ```
 */
function bestNumberFinalized(instanceId, api) {
  return (0, _util.memo)(instanceId, () => api.rpc.chain.subscribeFinalizedHeads().pipe((0, _operators.map)(header => header.number.unwrap())));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/chain/bestNumberLag.js":
/*!***************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/chain/bestNumberLag.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.bestNumberLag = bestNumberLag;

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name bestNumberLag
 * @returns A number of blocks
 * @description Calculates the lag between finalized head and best head
 * @example
 * <BR>
 *
 * ```javascript
 * api.derive.chain.bestNumberLag((lag) => {
 *   console.log(`finalized is ${lag} blocks behind head`);
 * });
 * ```
 */
function bestNumberLag(instanceId, api) {
  return (0, _util.memo)(instanceId, () => (0, _rxjs.combineLatest)([api.derive.chain.bestNumber(), api.derive.chain.bestNumberFinalized()]).pipe((0, _operators.map)(([bestNumber, bestNumberFinalized]) => api.registry.createType('BlockNumber', bestNumber.sub(bestNumberFinalized)))));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/chain/getHeader.js":
/*!***********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/chain/getHeader.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getHeader = getHeader;

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _type = __webpack_require__(/*! ../type */ "../../node_modules/@polkadot/api-derive/type/index.js");

var _util = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name getHeader
 * @param {( Uint8Array | string )} hash - A block hash as U8 array or string.
 * @returns An array containing the block header and the block author
 * @description Get a specific block header and extend it with the author
 * @example
 * <BR>
 *
 * ```javascript
 * const { author, number } = await api.derive.chain.getHeader('0x123...456');
 *
 * console.log(`block #${number} was authored by ${author}`);
 * ```
 */
function getHeader(instanceId, api) {
  return (0, _util.memo)(instanceId, hash => (0, _rxjs.combineLatest)([api.rpc.chain.getHeader(hash), api.query.session ? api.query.session.validators.at(hash) : (0, _rxjs.of)([])]).pipe((0, _operators.map)(([header, validators]) => new _type.HeaderExtended(api.registry, header, validators)), (0, _operators.catchError)(() => // where rpc.chain.getHeader throws, we will land here - it can happen that
  // we supplied an invalid hash. (Due to defaults, storeage will have an
  // empty value, so only the RPC is affected). So return undefined
  (0, _rxjs.of)())));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/chain/index.js":
/*!*******************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/chain/index.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _bestNumber = __webpack_require__(/*! ./bestNumber */ "../../node_modules/@polkadot/api-derive/chain/bestNumber.js");

Object.keys(_bestNumber).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _bestNumber[key];
    }
  });
});

var _bestNumberFinalized = __webpack_require__(/*! ./bestNumberFinalized */ "../../node_modules/@polkadot/api-derive/chain/bestNumberFinalized.js");

Object.keys(_bestNumberFinalized).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _bestNumberFinalized[key];
    }
  });
});

var _bestNumberLag = __webpack_require__(/*! ./bestNumberLag */ "../../node_modules/@polkadot/api-derive/chain/bestNumberLag.js");

Object.keys(_bestNumberLag).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _bestNumberLag[key];
    }
  });
});

var _getHeader = __webpack_require__(/*! ./getHeader */ "../../node_modules/@polkadot/api-derive/chain/getHeader.js");

Object.keys(_getHeader).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _getHeader[key];
    }
  });
});

var _subscribeNewHeads = __webpack_require__(/*! ./subscribeNewHeads */ "../../node_modules/@polkadot/api-derive/chain/subscribeNewHeads.js");

Object.keys(_subscribeNewHeads).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _subscribeNewHeads[key];
    }
  });
});

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/chain/subscribeNewHeads.js":
/*!*******************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/chain/subscribeNewHeads.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.subscribeNewHeads = subscribeNewHeads;

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _type = __webpack_require__(/*! ../type */ "../../node_modules/@polkadot/api-derive/type/index.js");

var _util = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name subscribeNewHeads
 * @returns An array containing the block header and the block author
 * @description An observable of the current block header and it's author
 * @example
 * <BR>
 *
 * ```javascript
 * api.derive.chain.subscribeNewHeads((header) => {
 *   console.log(`block #${header.number} was authored by ${header.author}`);
 * });
 * ```
 */
function subscribeNewHeads(instanceId, api) {
  return (0, _util.memo)(instanceId, () => (0, _rxjs.combineLatest)([api.rpc.chain.subscribeNewHeads(), api.query.session ? api.query.session.validators() : (0, _rxjs.of)([])]).pipe((0, _operators.map)(([header, validators]) => new _type.HeaderExtended(api.registry, header, validators))));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/collective/index.js":
/*!************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/collective/index.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _proposals = __webpack_require__(/*! ./proposals */ "../../node_modules/@polkadot/api-derive/collective/proposals.js");

Object.keys(_proposals).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _proposals[key];
    }
  });
});

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/collective/proposals.js":
/*!****************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/collective/proposals.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.proposals = proposals;

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _util2 = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
function parse([hashes, proposals, votes]) {
  return proposals.map((proposalOpt, index) => proposalOpt.isSome ? {
    hash: hashes[index],
    proposal: proposalOpt.unwrap(),
    votes: votes[index].unwrapOr(null)
  } : null).filter(proposal => !!proposal);
}

function proposals(instanceId, api, section) {
  return (0, _util2.memo)(instanceId, () => {
    var _api$query$section;

    return (0, _util.isFunction)((_api$query$section = api.query[section]) === null || _api$query$section === void 0 ? void 0 : _api$query$section.proposals) ? api.query[section].proposals().pipe((0, _operators.switchMap)(hashes => hashes.length ? (0, _rxjs.combineLatest)([(0, _rxjs.of)(hashes), api.query[section].proposalOf.multi(hashes), api.query[section].voting.multi(hashes)]) : (0, _rxjs.of)([[], [], []])), (0, _operators.map)(parse)) : (0, _rxjs.of)([]);
  });
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/contracts/fees.js":
/*!**********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/contracts/fees.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fees = fees;

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
// query via constants (current applicable path)
function queryConstants(api) {
  return (0, _rxjs.of)([// deprecated
  api.consts.contracts.callBaseFee || api.registry.createType('Balance'), api.consts.contracts.contractFee || api.registry.createType('Balance'), api.consts.contracts.creationFee || api.registry.createType('Balance'), api.consts.contracts.transactionBaseFee || api.registry.createType('Balance'), api.consts.contracts.transactionByteFee || api.registry.createType('Balance'), api.consts.contracts.transferFee || api.registry.createType('Balance'), // current
  api.consts.contracts.rentByteFee, api.consts.contracts.rentDepositOffset, api.consts.contracts.surchargeReward, api.consts.contracts.tombstoneDeposit]);
}
/**
 * @name fees
 * @returns An object containing the combined results of the queries for
 * all relevant contract fees as declared in the substrate chain spec.
 * @example
 * <BR>
 *
 * ```javascript
 * api.derive.contracts.fees(([creationFee, transferFee]) => {
 *   console.log(`The fee for creating a new contract on this chain is ${creationFee} units. The fee required to call this contract is ${transferFee} units.`);
 * });
 * ```
 */


function fees(instanceId, api) {
  return (0, _util.memo)(instanceId, () => {
    return queryConstants(api).pipe((0, _operators.map)(([callBaseFee, contractFee, creationFee, transactionBaseFee, transactionByteFee, transferFee, rentByteFee, rentDepositOffset, surchargeReward, tombstoneDeposit]) => ({
      callBaseFee,
      contractFee,
      creationFee,
      rentByteFee,
      rentDepositOffset,
      surchargeReward,
      tombstoneDeposit,
      transactionBaseFee,
      transactionByteFee,
      transferFee
    })));
  });
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/contracts/index.js":
/*!***********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/contracts/index.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _fees = __webpack_require__(/*! ./fees */ "../../node_modules/@polkadot/api-derive/contracts/fees.js");

Object.keys(_fees).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _fees[key];
    }
  });
});

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/council/index.js":
/*!*********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/council/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _proposals = __webpack_require__(/*! ./proposals */ "../../node_modules/@polkadot/api-derive/council/proposals.js");

Object.keys(_proposals).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _proposals[key];
    }
  });
});

var _votes = __webpack_require__(/*! ./votes */ "../../node_modules/@polkadot/api-derive/council/votes.js");

Object.keys(_votes).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _votes[key];
    }
  });
});

var _votesOf = __webpack_require__(/*! ./votesOf */ "../../node_modules/@polkadot/api-derive/council/votesOf.js");

Object.keys(_votesOf).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _votesOf[key];
    }
  });
});

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/council/proposals.js":
/*!*************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/council/proposals.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.proposals = proposals;

var _collective = __webpack_require__(/*! ../collective */ "../../node_modules/@polkadot/api-derive/collective/index.js");

var _util = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
function proposals(instanceId, api) {
  return (0, _util.memo)(instanceId, (0, _collective.proposals)(instanceId, api, 'council'));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/council/votes.js":
/*!*********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/council/votes.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.votes = votes;

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
function retrieveStakeOf(api) {
  return (api.query.electionsPhragmen || api.query.elections).stakeOf.entries().pipe((0, _operators.map)(entries => entries.map(([key, stake]) => [key.args[0], stake])));
}

function retrieveVoteOf(api) {
  return (api.query.electionsPhragmen || api.query.elections).votesOf.entries().pipe((0, _operators.map)(entries => entries.map(([key, votes]) => [key.args[0], votes])));
}

function retrievePrev(api) {
  return (0, _rxjs.combineLatest)([retrieveStakeOf(api), retrieveVoteOf(api)]).pipe((0, _operators.map)(([stakes, votes]) => {
    const result = [];
    votes.forEach(([voter, votes]) => {
      result.push([voter, {
        stake: api.registry.createType('Balance'),
        votes
      }]);
    });
    stakes.forEach(([staker, stake]) => {
      const entry = result.find(([voter]) => voter.eq(staker));

      if (entry) {
        entry[1].stake = stake;
      } else {
        result.push([staker, {
          stake,
          votes: []
        }]);
      }
    });
    return result;
  }));
}

function retrieveCurrent(api) {
  const elections = api.query.electionsPhragmen || api.query.elections;
  return elections.voting.entries().pipe((0, _operators.map)(entries => entries.map(([key, [stake, votes]]) => [key.args[0], {
    stake,
    votes
  }])));
}

function votes(instanceId, api) {
  return (0, _util.memo)(instanceId, () => (api.query.electionsPhragmen || api.query.elections).stakeOf ? retrievePrev(api) : retrieveCurrent(api));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/council/votesOf.js":
/*!***********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/council/votesOf.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.votesOf = votesOf;

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
function votesOf(instanceId, api) {
  return (0, _util.memo)(instanceId, accountId => api.derive.council.votes().pipe((0, _operators.map)(votes => (votes.find(([from]) => from.eq(accountId)) || [null, {
    stake: api.registry.createType('Balance'),
    votes: []
  }])[1])));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/democracy/dispatchQueue.js":
/*!*******************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/democracy/dispatchQueue.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dispatchQueue = dispatchQueue;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js"));

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _util2 = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const DEMOCRACY_ID = (0, _util.stringToHex)('democrac');

function queryQueue(api) {
  return api.query.democracy.dispatchQueue().pipe((0, _operators.switchMap)(dispatches => (0, _rxjs.combineLatest)([(0, _rxjs.of)(dispatches), api.derive.democracy.preimages(dispatches.map(([, hash]) => hash))])), (0, _operators.map)(([dispatches, images]) => dispatches.map(([at, imageHash, index], dispatchIndex) => ({
    at,
    image: images[dispatchIndex],
    imageHash,
    index
  }))));
}

function schedulerEntries(api) {
  // We don't get entries, but rather we get the keys (triggered via finished referendums) and
  // the subscribe to those keys - this means we pickup when the schedulers actually executes
  // at a block, the entry for that block will become empty
  return api.derive.democracy.referendumsFinished().pipe((0, _operators.switchMap)(() => api.query.scheduler.agenda.keys()), (0, _operators.switchMap)(keys => {
    const blockNumbers = keys.map(key => key.args[0]);
    return (0, _rxjs.combineLatest)([(0, _rxjs.of)(blockNumbers), api.query.scheduler.agenda.multi(blockNumbers)]);
  }));
}

function queryScheduler(api) {
  return schedulerEntries(api).pipe((0, _operators.switchMap)(([blockNumbers, agendas]) => {
    const result = [];
    blockNumbers.forEach((at, index) => {
      agendas[index].filter(optScheduled => optScheduled.isSome).forEach(optScheduled => {
        const scheduled = optScheduled.unwrap();

        if (scheduled.maybeId.isSome) {
          const id = scheduled.maybeId.unwrap().toHex();

          if (id.startsWith(DEMOCRACY_ID)) {
            const [, index] = api.registry.createType('(u64, ReferendumIndex)', id);
            const imageHash = scheduled.call.args[0];
            result.push({
              at,
              imageHash,
              index
            });
          }
        }
      });
    });
    return (0, _rxjs.combineLatest)([(0, _rxjs.of)(result), api.derive.democracy.preimages(result.map(({
      imageHash
    }) => imageHash))]);
  }), (0, _operators.map)(([infos, images]) => infos.map((info, index) => _objectSpread(_objectSpread({}, info), {}, {
    image: images[index]
  }))));
}

function dispatchQueue(instanceId, api) {
  return (0, _util2.memo)(instanceId, () => {
    var _api$query$scheduler;

    return (0, _util.isFunction)((_api$query$scheduler = api.query.scheduler) === null || _api$query$scheduler === void 0 ? void 0 : _api$query$scheduler.agenda) ? queryScheduler(api) : api.query.democracy.dispatchQueue ? queryQueue(api) : (0, _rxjs.of)([]);
  });
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/democracy/index.js":
/*!***********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/democracy/index.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _dispatchQueue = __webpack_require__(/*! ./dispatchQueue */ "../../node_modules/@polkadot/api-derive/democracy/dispatchQueue.js");

Object.keys(_dispatchQueue).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _dispatchQueue[key];
    }
  });
});

var _locks = __webpack_require__(/*! ./locks */ "../../node_modules/@polkadot/api-derive/democracy/locks.js");

Object.keys(_locks).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _locks[key];
    }
  });
});

var _nextExternal = __webpack_require__(/*! ./nextExternal */ "../../node_modules/@polkadot/api-derive/democracy/nextExternal.js");

Object.keys(_nextExternal).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nextExternal[key];
    }
  });
});

var _preimage = __webpack_require__(/*! ./preimage */ "../../node_modules/@polkadot/api-derive/democracy/preimage.js");

Object.keys(_preimage).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _preimage[key];
    }
  });
});

var _preimages = __webpack_require__(/*! ./preimages */ "../../node_modules/@polkadot/api-derive/democracy/preimages.js");

Object.keys(_preimages).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _preimages[key];
    }
  });
});

var _proposals = __webpack_require__(/*! ./proposals */ "../../node_modules/@polkadot/api-derive/democracy/proposals.js");

Object.keys(_proposals).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _proposals[key];
    }
  });
});

var _referendumIds = __webpack_require__(/*! ./referendumIds */ "../../node_modules/@polkadot/api-derive/democracy/referendumIds.js");

Object.keys(_referendumIds).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _referendumIds[key];
    }
  });
});

var _referendums = __webpack_require__(/*! ./referendums */ "../../node_modules/@polkadot/api-derive/democracy/referendums.js");

Object.keys(_referendums).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _referendums[key];
    }
  });
});

var _referendumsActive = __webpack_require__(/*! ./referendumsActive */ "../../node_modules/@polkadot/api-derive/democracy/referendumsActive.js");

Object.keys(_referendumsActive).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _referendumsActive[key];
    }
  });
});

var _referendumsFinished = __webpack_require__(/*! ./referendumsFinished */ "../../node_modules/@polkadot/api-derive/democracy/referendumsFinished.js");

Object.keys(_referendumsFinished).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _referendumsFinished[key];
    }
  });
});

var _referendumsInfo = __webpack_require__(/*! ./referendumsInfo */ "../../node_modules/@polkadot/api-derive/democracy/referendumsInfo.js");

Object.keys(_referendumsInfo).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _referendumsInfo[key];
    }
  });
});

var _sqrtElectorate = __webpack_require__(/*! ./sqrtElectorate */ "../../node_modules/@polkadot/api-derive/democracy/sqrtElectorate.js");

Object.keys(_sqrtElectorate).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _sqrtElectorate[key];
    }
  });
});

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/democracy/locks.js":
/*!***********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/democracy/locks.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.locks = locks;

var _bn = _interopRequireDefault(__webpack_require__(/*! bn.js */ "../../node_modules/bn.js/lib/bn.js"));

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _util2 = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
const LOCKUPS = [0, 1, 2, 4, 8, 16, 32];
const ZERO = new _bn.default(0);

function parseLock(api, [referendumId, accountVote], referendum) {
  const {
    balance,
    vote
  } = accountVote.asStandard;
  let unlockAt = ZERO;
  let referendumEnd = ZERO;

  if (referendum.isFinished) {
    const {
      approved,
      end
    } = referendum.asFinished;
    referendumEnd = end;

    if (approved.isTrue && vote.isAye || approved.isFalse && vote.isNay) {
      unlockAt = end.add(api.consts.democracy.enactmentPeriod.muln(LOCKUPS[vote.conviction.index]));
    }
  }

  return {
    balance,
    isDelegated: false,
    isFinished: referendum.isFinished,
    referendumEnd,
    referendumId,
    unlockAt,
    vote
  };
}

function delegateLocks(api, {
  balance,
  conviction,
  target
}) {
  return api.derive.democracy.locks(target).pipe((0, _operators.map)(available => available.map(({
    isFinished,
    referendumEnd,
    referendumId,
    unlockAt,
    vote
  }) => ({
    balance,
    isDelegated: true,
    isFinished,
    referendumEnd,
    referendumId,
    unlockAt: unlockAt.isZero() ? unlockAt : referendumEnd.add(api.consts.democracy.enactmentPeriod.muln(LOCKUPS[conviction.index])),
    vote: api.registry.createType('Vote', {
      aye: vote.isAye,
      conviction
    })
  }))));
}

function directLocks(api, {
  votes
}) {
  if (!votes.length) {
    return (0, _rxjs.of)([]);
  }

  return api.query.democracy.referendumInfoOf.multi(votes.map(([referendumId]) => referendumId)).pipe((0, _operators.map)(referendums => votes.map((vote, index) => [vote, referendums[index].unwrapOr(null)]).filter(item => !!item[1] && (0, _util.isUndefined)(item[1].end) && item[0][1].isStandard).map(([directVote, referendum]) => parseLock(api, directVote, referendum))));
}

function locks(instanceId, api) {
  return (0, _util2.memo)(instanceId, accountId => api.query.democracy.votingOf ? api.query.democracy.votingOf(accountId).pipe((0, _operators.switchMap)(voting => voting.isDirect ? directLocks(api, voting.asDirect) : voting.isDelegating ? delegateLocks(api, voting.asDelegating) : (0, _rxjs.of)([]))) : (0, _rxjs.of)([]));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/democracy/nextExternal.js":
/*!******************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/democracy/nextExternal.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.nextExternal = nextExternal;

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
function withImage(api, nextOpt) {
  if (nextOpt.isNone) {
    return (0, _rxjs.of)(null);
  }

  const [imageHash, threshold] = nextOpt.unwrap();
  return api.derive.democracy.preimage(imageHash).pipe((0, _operators.map)(image => ({
    image,
    imageHash,
    threshold
  })));
}

function nextExternal(instanceId, api) {
  return (0, _util.memo)(instanceId, () => {
    var _api$query$democracy;

    return ((_api$query$democracy = api.query.democracy) === null || _api$query$democracy === void 0 ? void 0 : _api$query$democracy.nextExternal) ? api.query.democracy.nextExternal().pipe((0, _operators.switchMap)(nextOpt => withImage(api, nextOpt))) : (0, _rxjs.of)(null);
  });
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/democracy/preimage.js":
/*!**************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/democracy/preimage.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.preimage = preimage;

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

var _util2 = __webpack_require__(/*! ./util */ "../../node_modules/@polkadot/api-derive/democracy/util.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
function preimage(instanceId, api) {
  return (0, _util.memo)(instanceId, hash => api.query.democracy.preimages(hash).pipe((0, _operators.map)(imageOpt => (0, _util2.parseImage)(api, imageOpt))));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/democracy/preimages.js":
/*!***************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/democracy/preimages.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.preimages = preimages;

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

var _util2 = __webpack_require__(/*! ./util */ "../../node_modules/@polkadot/api-derive/democracy/util.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
function preimages(instanceId, api) {
  return (0, _util.memo)(instanceId, hashes => api.query.democracy.preimages.multi(hashes).pipe((0, _operators.map)(images => images.map(imageOpt => (0, _util2.parseImage)(api, imageOpt)))));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/democracy/proposals.js":
/*!***************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/democracy/proposals.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.proposals = proposals;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js"));

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _util2 = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// eslint-disable-next-line @typescript-eslint/no-unused-vars
function isNewDepositors(depositors) {
  // Detect balance...
  // eslint-disable-next-line @typescript-eslint/unbound-method
  return (0, _util.isFunction)(depositors[1].mul);
}

function parse([proposals, images, optDepositors]) {
  return proposals.filter(([,, proposer], index) => {
    var _optDepositors$index;

    return !!((_optDepositors$index = optDepositors[index]) === null || _optDepositors$index === void 0 ? void 0 : _optDepositors$index.isSome) && !proposer.isEmpty;
  }).map(([index, imageHash, proposer], proposalIndex) => {
    const depositors = optDepositors[proposalIndex].unwrap();
    return _objectSpread(_objectSpread({}, isNewDepositors(depositors) ? {
      balance: depositors[1],
      seconds: depositors[0]
    } : {
      balance: depositors[0],
      seconds: depositors[1]
    }), {}, {
      image: images[proposalIndex],
      imageHash,
      index,
      proposer
    });
  });
}

function proposals(instanceId, api) {
  return (0, _util2.memo)(instanceId, () => {
    var _api$query$democracy, _api$query$democracy2;

    return ((_api$query$democracy = api.query.democracy) === null || _api$query$democracy === void 0 ? void 0 : _api$query$democracy.publicProps) && ((_api$query$democracy2 = api.query.democracy) === null || _api$query$democracy2 === void 0 ? void 0 : _api$query$democracy2.preimages) ? api.query.democracy.publicProps().pipe((0, _operators.switchMap)(proposals => (0, _rxjs.combineLatest)([(0, _rxjs.of)(proposals), api.derive.democracy.preimages(proposals.map(([, hash]) => hash)), api.query.democracy.depositOf.multi(proposals.map(([index]) => index))])), (0, _operators.map)(parse)) : (0, _rxjs.of)([]);
  });
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/democracy/referendumIds.js":
/*!*******************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/democracy/referendumIds.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.referendumIds = referendumIds;

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
function referendumIds(instanceId, api) {
  return (0, _util.memo)(instanceId, () => {
    var _api$query$democracy;

    return ((_api$query$democracy = api.query.democracy) === null || _api$query$democracy === void 0 ? void 0 : _api$query$democracy.lowestUnbaked) ? api.queryMulti([api.query.democracy.lowestUnbaked, api.query.democracy.referendumCount]).pipe((0, _operators.map)(([first, total]) => total.gt(first) // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    ? [...Array(total.sub(first).toNumber())].map((_, i) => first.addn(i)) : [])) : (0, _rxjs.of)([]);
  });
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/democracy/referendums.js":
/*!*****************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/democracy/referendums.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.referendums = referendums;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js"));

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function referendums(instanceId, api) {
  return (0, _util.memo)(instanceId, () => api.derive.democracy.referendumsActive().pipe((0, _operators.switchMap)(referendums => (0, _rxjs.combineLatest)([(0, _rxjs.of)(referendums), api.derive.democracy._referendumsVotes(referendums)])), (0, _operators.map)(([referendums, votes]) => referendums.map((referendum, index) => _objectSpread(_objectSpread({}, referendum), votes[index])))));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/democracy/referendumsActive.js":
/*!***********************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/democracy/referendumsActive.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.referendumsActive = referendumsActive;

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
function referendumsActive(instanceId, api) {
  return (0, _util.memo)(instanceId, () => api.derive.democracy.referendumIds().pipe((0, _operators.switchMap)(ids => ids.length ? api.derive.democracy.referendumsInfo(ids) : (0, _rxjs.of)([]))));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/democracy/referendumsFinished.js":
/*!*************************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/democracy/referendumsFinished.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.referendumsFinished = referendumsFinished;

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
function referendumsFinished(instanceId, api) {
  return (0, _util.memo)(instanceId, () => api.derive.democracy.referendumIds().pipe((0, _operators.switchMap)(ids => api.query.democracy.referendumInfoOf.multi(ids)), (0, _operators.map)(infos => infos.filter(optInfo => optInfo.isSome).map(optInfo => optInfo.unwrap()).filter(info => info.isFinished).map(info => info.asFinished))));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/democracy/referendumsInfo.js":
/*!*********************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/democracy/referendumsInfo.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._referendumVotes = _referendumVotes;
exports._referendumsVotes = _referendumsVotes;
exports._referendumInfo = _referendumInfo;
exports.referendumsInfo = referendumsInfo;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js"));

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _util2 = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

var _util3 = __webpack_require__(/*! ./util */ "../../node_modules/@polkadot/api-derive/democracy/util.js");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function votesPrev(api, referendumId) {
  return api.query.democracy.votersFor(referendumId).pipe((0, _operators.switchMap)(votersFor => (0, _rxjs.combineLatest)([(0, _rxjs.of)(votersFor), votersFor.length ? api.query.democracy.voteOf.multi(votersFor.map(accountId => [referendumId, accountId])) : (0, _rxjs.of)([]), api.derive.balances.votingBalances(votersFor)])), (0, _operators.map)(([votersFor, votes, balances]) => votersFor.map((accountId, index) => ({
    accountId,
    balance: balances[index].votingBalance || api.registry.createType('Balance'),
    isDelegating: false,
    vote: votes[index] || api.registry.createType('Vote')
  }))));
}

function votesCurr(api, referendumId) {
  return api.query.democracy.votingOf.entries().pipe((0, _operators.map)(allVoting => {
    const mapped = allVoting.map(([key, voting]) => [key.args[0], voting]);
    const votes = mapped.filter(([, voting]) => voting.isDirect).map(([accountId, voting]) => [accountId, voting.asDirect.votes.filter(([idx]) => idx.eq(referendumId))]).filter(([, directVotes]) => !!directVotes.length).reduce((result, [accountId, votes]) => // FIXME We are ignoring split votes
    votes.reduce((result, [, vote]) => {
      if (vote.isStandard) {
        result.push(_objectSpread({
          accountId,
          isDelegating: false
        }, vote.asStandard));
      }

      return result;
    }, result), []);
    const delegations = mapped.filter(([, voting]) => voting.isDelegating).map(([accountId, voting]) => [accountId, voting.asDelegating]); // add delegations

    delegations.forEach(([accountId, {
      balance,
      conviction,
      target
    }]) => {
      // Are we delegating to a delegator
      const toDelegator = delegations.find(([accountId]) => accountId.eq(target));
      const to = votes.find(({
        accountId
      }) => accountId.eq(toDelegator ? toDelegator[0] : target)); // this delegation has a target

      if (to) {
        votes.push({
          accountId,
          balance,
          isDelegating: true,
          vote: api.registry.createType('Vote', {
            aye: to.vote.isAye,
            conviction
          })
        });
      }
    });
    return votes;
  }));
}

function _referendumVotes(instanceId, api) {
  return (0, _util2.memo)(instanceId, referendum => (0, _rxjs.combineLatest)([api.derive.democracy.sqrtElectorate(), (0, _util.isFunction)(api.query.democracy.votingOf) ? votesCurr(api, referendum.index) : votesPrev(api, referendum.index)]).pipe((0, _operators.map)(([sqrtElectorate, votes]) => (0, _util3.calcVotes)(sqrtElectorate, referendum, votes))));
}

function _referendumsVotes(instanceId, api) {
  return (0, _util2.memo)(instanceId, referendums => referendums.length ? (0, _rxjs.combineLatest)(referendums.map(referendum => api.derive.democracy._referendumVotes(referendum))) : (0, _rxjs.of)([]));
}

function _referendumInfo(instanceId, api) {
  return (0, _util2.memo)(instanceId, (index, info) => {
    const status = (0, _util3.getStatus)(info);
    return status ? api.query.democracy.preimages(status.proposalHash).pipe((0, _operators.map)(preimage => ({
      image: (0, _util3.parseImage)(api, preimage),
      imageHash: status.proposalHash,
      index: api.registry.createType('ReferendumIndex', index),
      status
    }))) : (0, _rxjs.of)(null);
  });
}

function referendumsInfo(instanceId, api) {
  return (0, _util2.memo)(instanceId, ids => ids.length ? api.query.democracy.referendumInfoOf.multi(ids).pipe((0, _operators.switchMap)(infos => (0, _rxjs.combineLatest)(ids.map((id, index) => api.derive.democracy._referendumInfo(id, infos[index])))), (0, _operators.map)(infos => infos.filter(referendum => !!referendum))) : (0, _rxjs.of)([]));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/democracy/sqrtElectorate.js":
/*!********************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/democracy/sqrtElectorate.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sqrtElectorate = sqrtElectorate;

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _util2 = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
function sqrtElectorate(instanceId, api) {
  return (0, _util2.memo)(instanceId, () => api.query.balances.totalIssuance().pipe((0, _operators.map)(totalIssuance => (0, _util.bnSqrt)(totalIssuance))));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/democracy/util.js":
/*!**********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/democracy/util.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.compareRationals = compareRationals;
exports.calcPassing = calcPassing;
exports.calcVotes = calcVotes;
exports.getStatus = getStatus;
exports.parseImage = parseImage;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js"));

var _bn = _interopRequireDefault(__webpack_require__(/*! bn.js */ "../../node_modules/bn.js/lib/bn.js"));

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function isOldInfo(info) {
  return !!info.proposalHash;
}

function isCurrentStatus(status) {
  return !!status.tally;
}

function isCurrentPreimage(api, imageOpt) {
  return !!imageOpt && !api.query.democracy.dispatchQueue;
}

function compareRationals(n1, d1, n2, d2) {
  while (true) {
    const q1 = n1.div(d1);
    const q2 = n2.div(d2);

    if (q1.lt(q2)) {
      return true;
    } else if (q2.lt(q1)) {
      return false;
    }

    const r1 = n1.mod(d1);
    const r2 = n2.mod(d2);

    if (r2.isZero()) {
      return false;
    } else if (r1.isZero()) {
      return true;
    }

    n1 = d2;
    n2 = d1;
    d1 = r2;
    d2 = r1;
  }
}

function calcPassing(threshold, sqrtElectorate, {
  votedAye,
  votedNay,
  votedTotal
}) {
  const sqrtVoters = (0, _util.bnSqrt)(votedTotal);
  return sqrtVoters.isZero() ? false : threshold.isSimplemajority ? votedAye.gt(votedNay) : threshold.isSupermajorityapproval ? compareRationals(votedNay, sqrtVoters, votedAye, sqrtElectorate) : compareRationals(votedNay, sqrtElectorate, votedAye, sqrtVoters);
}

function calcVotesPrev(votesFor) {
  return votesFor.reduce((state, derived) => {
    const {
      balance,
      vote
    } = derived;
    const isDefault = vote.conviction.index === 0;
    const counted = balance.muln(isDefault ? 1 : vote.conviction.index).divn(isDefault ? 10 : 1);

    if (vote.isAye) {
      state.allAye.push(derived);
      state.voteCountAye++;
      state.votedAye.iadd(counted);
    } else {
      state.allNay.push(derived);
      state.voteCountNay++;
      state.votedNay.iadd(counted);
    }

    state.voteCount++;
    state.votedTotal.iadd(counted);
    return state;
  }, {
    allAye: [],
    allNay: [],
    voteCount: 0,
    voteCountAye: 0,
    voteCountNay: 0,
    votedAye: new _bn.default(0),
    votedNay: new _bn.default(0),
    votedTotal: new _bn.default(0)
  });
}

function calcVotesCurrent(tally, votes) {
  const allAye = [];
  const allNay = [];
  votes.forEach(derived => {
    if (derived.vote.isAye) {
      allAye.push(derived);
    } else {
      allNay.push(derived);
    }
  });
  return {
    allAye,
    allNay,
    voteCount: allAye.length + allNay.length,
    voteCountAye: allAye.length,
    voteCountNay: allNay.length,
    votedAye: tally.ayes,
    votedNay: tally.nays,
    votedTotal: tally.turnout
  };
}

function calcVotes(sqrtElectorate, referendum, votes) {
  const state = isCurrentStatus(referendum.status) ? calcVotesCurrent(referendum.status.tally, votes) : calcVotesPrev(votes);
  return _objectSpread(_objectSpread({}, state), {}, {
    isPassing: calcPassing(referendum.status.threshold, sqrtElectorate, state),
    votes
  });
}

function getStatus(info) {
  if (info.isNone) {
    return null;
  }

  const unwrapped = info.unwrap();

  if (isOldInfo(unwrapped)) {
    return unwrapped;
  } else if (unwrapped.isOngoing) {
    return unwrapped.asOngoing;
  } // done, we don't include it here... only currently active


  return null;
}

function constructProposal(api, [bytes, proposer, balance, at]) {
  let proposal;

  try {
    proposal = api.registry.createType('Proposal', bytes.toU8a(true));
  } catch (error) {
    console.error(error);
  }

  return {
    at,
    balance,
    proposal,
    proposer
  };
}

function parseImage(api, imageOpt) {
  if (imageOpt.isNone) {
    return;
  }

  if (isCurrentPreimage(api, imageOpt)) {
    const status = imageOpt.unwrap();

    if (status.isMissing) {
      return;
    }

    const {
      data,
      deposit,
      provider,
      since
    } = status.asAvailable;
    return constructProposal(api, [data, provider, deposit, since]);
  }

  return constructProposal(api, imageOpt.unwrap());
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/elections/index.js":
/*!***********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/elections/index.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _info = __webpack_require__(/*! ./info */ "../../node_modules/@polkadot/api-derive/elections/info.js");

Object.keys(_info).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _info[key];
    }
  });
});

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/elections/info.js":
/*!**********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/elections/info.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.info = info;

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
function sortAccounts([, balanceA], [, balanceB]) {
  return balanceB.cmp(balanceA);
}

function queryElections(api) {
  const section = api.query.electionsPhragmen ? 'electionsPhragmen' : 'elections';
  return api.queryMulti([api.query.council.members, api.query[section].candidates, api.query[section].members, api.query[section].runnersUp]).pipe((0, _operators.map)(([councilMembers, candidates, members, runnersUp]) => ({
    candidacyBond: api.consts[section].candidacyBond,
    candidateCount: api.registry.createType('u32', candidates.length),
    candidates,
    desiredRunnersUp: api.consts[section].desiredRunnersUp,
    desiredSeats: api.consts[section].desiredMembers,
    members: members.length ? members.sort(sortAccounts) : councilMembers.map(accountId => [accountId, api.registry.createType('Balance')]),
    runnersUp: runnersUp.sort(sortAccounts),
    termDuration: api.consts[section].termDuration,
    votingBond: api.consts[section].votingBond
  })));
}
/**
 * @name info
 * @returns An object containing the combined results of the storage queries for
 * all relevant election module properties.
 * @example
 * <BR>
 *
 * ```javascript
 * api.derive.elections.info(({ members, candidates }) => {
 *   console.log(`There are currently ${members.length} council members and ${candidates.length} prospective council candidates.`);
 * });
 * ```
 */


function info(instanceId, api) {
  return (0, _util.memo)(instanceId, () => queryElections(api));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/imOnline/index.js":
/*!**********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/imOnline/index.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _receivedHeartbeats = __webpack_require__(/*! ./receivedHeartbeats */ "../../node_modules/@polkadot/api-derive/imOnline/receivedHeartbeats.js");

Object.keys(_receivedHeartbeats).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _receivedHeartbeats[key];
    }
  });
});

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/imOnline/receivedHeartbeats.js":
/*!***********************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/imOnline/receivedHeartbeats.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.receivedHeartbeats = receivedHeartbeats;

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _util2 = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
function mapResult([result, validators, heartbeats, numBlocks]) {
  validators.forEach((validator, index) => {
    const validatorId = validator.toString();
    const blockCount = numBlocks[index];
    const hasMessage = !heartbeats[index].isEmpty;
    const prev = result[validatorId];

    if (!prev || prev.hasMessage !== hasMessage || !prev.blockCount.eq(blockCount)) {
      result[validatorId] = {
        blockCount,
        hasMessage,
        isOnline: hasMessage || blockCount.gt(_util.BN_ZERO)
      };
    }
  });
  return result;
}
/**
 * @description Return a boolean array indicating whether the passed accounts had received heartbeats in the current session
 */


function receivedHeartbeats(instanceId, api) {
  return (0, _util2.memo)(instanceId, () => {
    var _api$query$imOnline;

    return ((_api$query$imOnline = api.query.imOnline) === null || _api$query$imOnline === void 0 ? void 0 : _api$query$imOnline.receivedHeartbeats) ? api.derive.staking.overview().pipe((0, _operators.switchMap)(({
      currentIndex,
      validators
    }) => (0, _rxjs.combineLatest)([(0, _rxjs.of)({}), (0, _rxjs.of)(validators), api.query.imOnline.receivedHeartbeats.multi(validators.map((_address, index) => [currentIndex, index])), api.query.imOnline.authoredBlocks.multi(validators.map(address => [currentIndex, address]))])), (0, _operators.map)(mapResult)) : (0, _rxjs.of)({});
  });
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/index.js":
/*!*************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/index.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "../../node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  derive: true
};
exports.default = decorateDerive;
exports.derive = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js"));

var accounts = _interopRequireWildcard(__webpack_require__(/*! ./accounts */ "../../node_modules/@polkadot/api-derive/accounts/index.js"));

var balances = _interopRequireWildcard(__webpack_require__(/*! ./balances */ "../../node_modules/@polkadot/api-derive/balances/index.js"));

var chain = _interopRequireWildcard(__webpack_require__(/*! ./chain */ "../../node_modules/@polkadot/api-derive/chain/index.js"));

var contracts = _interopRequireWildcard(__webpack_require__(/*! ./contracts */ "../../node_modules/@polkadot/api-derive/contracts/index.js"));

var council = _interopRequireWildcard(__webpack_require__(/*! ./council */ "../../node_modules/@polkadot/api-derive/council/index.js"));

var democracy = _interopRequireWildcard(__webpack_require__(/*! ./democracy */ "../../node_modules/@polkadot/api-derive/democracy/index.js"));

var elections = _interopRequireWildcard(__webpack_require__(/*! ./elections */ "../../node_modules/@polkadot/api-derive/elections/index.js"));

var imOnline = _interopRequireWildcard(__webpack_require__(/*! ./imOnline */ "../../node_modules/@polkadot/api-derive/imOnline/index.js"));

var parachains = _interopRequireWildcard(__webpack_require__(/*! ./parachains */ "../../node_modules/@polkadot/api-derive/parachains/index.js"));

var session = _interopRequireWildcard(__webpack_require__(/*! ./session */ "../../node_modules/@polkadot/api-derive/session/index.js"));

var society = _interopRequireWildcard(__webpack_require__(/*! ./society */ "../../node_modules/@polkadot/api-derive/society/index.js"));

var staking = _interopRequireWildcard(__webpack_require__(/*! ./staking */ "../../node_modules/@polkadot/api-derive/staking/index.js"));

var technicalCommittee = _interopRequireWildcard(__webpack_require__(/*! ./technicalCommittee */ "../../node_modules/@polkadot/api-derive/technicalCommittee/index.js"));

var treasury = _interopRequireWildcard(__webpack_require__(/*! ./treasury */ "../../node_modules/@polkadot/api-derive/treasury/index.js"));

var tx = _interopRequireWildcard(__webpack_require__(/*! ./tx */ "../../node_modules/@polkadot/api-derive/tx/index.js"));

var _type = __webpack_require__(/*! ./type */ "../../node_modules/@polkadot/api-derive/type/index.js");

Object.keys(_type).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _type[key];
    }
  });
});

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const derive = {
  accounts,
  balances,
  chain,
  contracts,
  council,
  democracy,
  elections,
  imOnline,
  parachains,
  session,
  society,
  staking,
  technicalCommittee,
  treasury,
  tx
};
exports.derive = derive;
// Enable derive only if some of these modules are available
const deriveAvail = {
  contracts: ['contracts'],
  council: ['council'],
  democracy: ['democracy'],
  elections: ['electionsPhragmen', 'elections'],
  imOnline: ['imOnline'],
  parachains: ['parachains', 'registrar'],
  session: ['session'],
  society: ['society'],
  staking: ['staking'],
  technicalCommittee: ['technicalCommittee'],
  treasury: ['treasury']
};
/**
 * Returns an object that will inject `api` into all the functions inside
 * `allSections`, and keep the object architecture of `allSections`.
 */

/** @internal */

function injectFunctions(instanceId, api, allSections) {
  const queryKeys = Object.keys(api.query);
  return Object.keys(allSections).filter(sectionName => !deriveAvail[sectionName] || deriveAvail[sectionName].some(query => queryKeys.includes(query))).reduce((deriveAcc, sectionName) => {
    const section = allSections[sectionName];
    deriveAcc[sectionName] = Object.keys(section).reduce((sectionAcc, _methodName) => {
      const methodName = _methodName; // Not sure what to do here, casting as any. Though the final types are good
      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-call

      const method = section[methodName](instanceId, api); // idem
      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access

      sectionAcc[methodName] = method;
      return sectionAcc;
    }, {});
    return deriveAcc;
  }, {});
} // FIXME The return type of this function should be {...ExactDerive, ...DeriveCustom}
// For now we just drop the custom derive typings

/** @internal */


function decorateDerive(instanceId, api, custom = {}) {
  return _objectSpread(_objectSpread({}, injectFunctions(instanceId, api, derive)), injectFunctions(instanceId, api, custom));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/parachains/index.js":
/*!************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/parachains/index.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _info = __webpack_require__(/*! ./info */ "../../node_modules/@polkadot/api-derive/parachains/info.js");

Object.keys(_info).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _info[key];
    }
  });
});

var _overview = __webpack_require__(/*! ./overview */ "../../node_modules/@polkadot/api-derive/parachains/overview.js");

Object.keys(_overview).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _overview[key];
    }
  });
});

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/parachains/info.js":
/*!***********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/parachains/info.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.info = info;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js"));

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function parseActive(id, active) {
  const found = active.find(([paraId]) => paraId === id);

  if (found && found[1].isSome) {
    const [collatorId, retriable] = found[1].unwrap();
    return _objectSpread({
      collatorId
    }, retriable.isWithRetries ? {
      isRetriable: true,
      retries: retriable.asWithRetries.toNumber()
    } : {
      isRetriable: false,
      retries: 0
    });
  }

  return null;
}

function parseCollators(id, collatorQueue) {
  return collatorQueue.map(queue => {
    const found = queue.find(([paraId]) => paraId === id);
    return found ? found[1] : null;
  });
}

function parse(id, [active, retryQueue, selectedThreads, didUpdate, info, pendingSwap, heads, relayDispatchQueue]) {
  if (info.isNone) {
    return null;
  }

  return {
    active: parseActive(id, active),
    didUpdate: didUpdate.isSome ? !!didUpdate.unwrap().some(paraId => paraId.eq(id)) : false,
    heads,
    id,
    info: _objectSpread({
      id
    }, info.unwrap()),
    pendingSwapId: pendingSwap.unwrapOr(null),
    relayDispatchQueue,
    retryCollators: parseCollators(id, retryQueue),
    selectedCollators: parseCollators(id, selectedThreads)
  };
}

function info(instanceId, api) {
  return (0, _util.memo)(instanceId, id => api.query.registrar && api.query.parachains ? api.queryMulti([api.query.registrar.active, api.query.registrar.retryQueue, api.query.registrar.selectedThreads, api.query.parachains.didUpdate, [api.query.registrar.paras, id], [api.query.registrar.pendingSwap, id], [api.query.parachains.heads, id], [api.query.parachains.relayDispatchQueue, id]]).pipe((0, _operators.map)(result => parse(api.registry.createType('ParaId', id), result))) : (0, _rxjs.of)(null));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/parachains/overview.js":
/*!***************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/parachains/overview.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.overview = overview;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js"));

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function parse([ids, didUpdate, infos, pendingSwaps, relayDispatchQueueSizes]) {
  return ids.map((id, index) => {
    return {
      didUpdate: didUpdate.isSome ? !!didUpdate.unwrap().some(paraId => paraId.eq(id)) : false,
      id,
      info: _objectSpread({
        id
      }, infos[index].unwrapOr(null)),
      pendingSwapId: pendingSwaps[index].unwrapOr(null),
      relayDispatchQueueSize: relayDispatchQueueSizes[index][0].toNumber()
    };
  });
}

function overview(instanceId, api) {
  return (0, _util.memo)(instanceId, () => {
    var _api$query$registrar;

    return ((_api$query$registrar = api.query.registrar) === null || _api$query$registrar === void 0 ? void 0 : _api$query$registrar.parachains) && api.query.parachains ? api.query.registrar.parachains().pipe((0, _operators.switchMap)(paraIds => (0, _rxjs.combineLatest)([(0, _rxjs.of)(paraIds), api.query.parachains.didUpdate(), api.query.registrar.paras.multi(paraIds), api.query.registrar.pendingSwap.multi(paraIds), api.query.parachains.relayDispatchQueueSize.multi(paraIds)])), (0, _operators.map)(result => parse(result))) : (0, _rxjs.of)([]);
  });
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/session/eraLength.js":
/*!*************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/session/eraLength.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.eraLength = eraLength;

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
function eraLength(instanceId, api) {
  return (0, _util.memo)(instanceId, () => api.derive.session.info().pipe((0, _operators.map)(info => info.eraLength)));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/session/eraProgress.js":
/*!***************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/session/eraProgress.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.eraProgress = eraProgress;

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
function eraProgress(instanceId, api) {
  return (0, _util.memo)(instanceId, () => api.derive.session.progress().pipe((0, _operators.map)(info => info.eraProgress)));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/session/index.js":
/*!*********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/session/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _eraLength = __webpack_require__(/*! ./eraLength */ "../../node_modules/@polkadot/api-derive/session/eraLength.js");

Object.keys(_eraLength).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _eraLength[key];
    }
  });
});

var _eraProgress = __webpack_require__(/*! ./eraProgress */ "../../node_modules/@polkadot/api-derive/session/eraProgress.js");

Object.keys(_eraProgress).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _eraProgress[key];
    }
  });
});

var _indexes = __webpack_require__(/*! ./indexes */ "../../node_modules/@polkadot/api-derive/session/indexes.js");

Object.keys(_indexes).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _indexes[key];
    }
  });
});

var _info = __webpack_require__(/*! ./info */ "../../node_modules/@polkadot/api-derive/session/info.js");

Object.keys(_info).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _info[key];
    }
  });
});

var _progress = __webpack_require__(/*! ./progress */ "../../node_modules/@polkadot/api-derive/session/progress.js");

Object.keys(_progress).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _progress[key];
    }
  });
});

var _sessionProgress = __webpack_require__(/*! ./sessionProgress */ "../../node_modules/@polkadot/api-derive/session/sessionProgress.js");

Object.keys(_sessionProgress).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _sessionProgress[key];
    }
  });
});

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/session/indexes.js":
/*!***********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/session/indexes.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.indexes = indexes;

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _util2 = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
function isEraOpt(era) {
  return (0, _util.isFunction)(era.unwrapOrDefault);
} // parse into Indexes


function parse([activeEra, activeEraStart, currentEra, currentIndex, validatorCount]) {
  return {
    activeEra,
    activeEraStart,
    currentEra,
    currentIndex,
    validatorCount
  };
} // query for previous V2


function queryNoActive(api) {
  return api.queryMulti([api.query.staking.currentEra, api.query.session.currentIndex, api.query.staking.validatorCount]).pipe((0, _operators.map)(([currentEraOpt, currentIndex, validatorCount]) => {
    const currentEra = isEraOpt(currentEraOpt) ? currentEraOpt.unwrapOrDefault() : currentEraOpt;
    return parse([currentEra, api.registry.createType('Option<Moment>'), currentEra, currentIndex, validatorCount]);
  }));
} // query based on latest


function query(api) {
  return api.queryMulti([api.query.staking.activeEra, api.query.staking.currentEra, api.query.session.currentIndex, api.query.staking.validatorCount]).pipe((0, _operators.map)(([activeOpt, currentEra, currentIndex, validatorCount]) => {
    const {
      index,
      start
    } = activeOpt.unwrapOrDefault();
    return parse([index, start, currentEra.unwrapOrDefault(), currentIndex, validatorCount]);
  }));
} // empty set when none is available


function empty(api) {
  return (0, _rxjs.of)(parse([api.registry.createType('EraIndex'), api.registry.createType('Option<Moment>'), api.registry.createType('EraIndex'), api.registry.createType('SessionIndex', 1), api.registry.createType('u32')]));
}

function indexes(instanceId, api) {
  return (0, _util2.memo)(instanceId, () => api.query.session && api.query.staking ? (0, _util.isFunction)(api.query.staking.activeEra) ? query(api) : queryNoActive(api) : empty(api));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/session/info.js":
/*!********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/session/info.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.info = info;

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
function createDerive(api, [[hasBabe, epochDuration, sessionsPerEra], {
  activeEra,
  activeEraStart,
  currentEra,
  currentIndex,
  validatorCount
}]) {
  return {
    activeEra,
    activeEraStart,
    currentEra,
    currentIndex,
    eraLength: api.registry.createType('BlockNumber', sessionsPerEra.mul(epochDuration)),
    isEpoch: hasBabe,
    sessionLength: epochDuration,
    sessionsPerEra,
    validatorCount
  };
}

function queryAura(api) {
  return api.derive.session.indexes().pipe((0, _operators.map)(indexes => {
    var _api$consts$staking;

    return createDerive(api, [[false, api.registry.createType('u64', 1), ((_api$consts$staking = api.consts.staking) === null || _api$consts$staking === void 0 ? void 0 : _api$consts$staking.sessionsPerEra) || api.registry.createType('SessionIndex', 1)], indexes]);
  }));
}

function queryBabe(api) {
  return api.derive.session.indexes().pipe((0, _operators.map)(indexes => createDerive(api, [[true, api.consts.babe.epochDuration, api.consts.staking.sessionsPerEra], indexes])));
}
/**
 * @description Retrieves all the session and era query and calculates specific values on it as the length of the session and eras
 */


function info(instanceId, api) {
  return (0, _util.memo)(instanceId, () => api.consts.babe ? queryBabe(api) : queryAura(api));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/session/progress.js":
/*!************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/session/progress.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.progress = progress;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js"));

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _util2 = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function createDerive(api, info, [currentSlot, epochIndex, epochOrGenesisStartSlot, activeEraStartSessionIndex]) {
  const epochStartSlot = epochIndex.mul(info.sessionLength).iadd(epochOrGenesisStartSlot);
  const sessionProgress = currentSlot.sub(epochStartSlot);
  const eraProgress = info.currentIndex.sub(activeEraStartSessionIndex).imul(info.sessionLength).iadd(sessionProgress);
  return _objectSpread(_objectSpread({}, info), {}, {
    eraProgress: api.registry.createType('BlockNumber', eraProgress),
    sessionProgress: api.registry.createType('BlockNumber', sessionProgress)
  });
}

function queryAura(api) {
  return api.derive.session.info().pipe((0, _operators.map)(info => _objectSpread(_objectSpread({}, info), {}, {
    eraProgress: api.registry.createType('BlockNumber'),
    sessionProgress: api.registry.createType('BlockNumber')
  })));
}

function queryBabe(api) {
  return api.derive.session.info().pipe((0, _operators.switchMap)(info => (0, _rxjs.combineLatest)([(0, _rxjs.of)(info), api.queryMulti([api.query.babe.currentSlot, api.query.babe.epochIndex, api.query.babe.genesisSlot, [api.query.staking.erasStartSessionIndex, info.activeEra]])])), (0, _operators.map)(([info, [currentSlot, epochIndex, genesisSlot, optStartIndex]]) => [info, [currentSlot, epochIndex, genesisSlot, optStartIndex.unwrapOr(api.registry.createType('SessionIndex', 1))]]));
}

function queryBabeNoHistory(api) {
  return (0, _rxjs.combineLatest)([api.derive.session.info(), api.queryMulti([api.query.babe.currentSlot, api.query.babe.epochIndex, api.query.babe.genesisSlot, api.query.staking.currentEraStartSessionIndex])]);
}
/**
 * @description Retrieves all the session and era query and calculates specific values on it as the length of the session and eras
 */


function progress(instanceId, api) {
  return (0, _util2.memo)(instanceId, () => api.consts.babe ? ((0, _util.isFunction)(api.query.staking.erasStartSessionIndex) ? queryBabe(api) // 2.x with Babe
  : queryBabeNoHistory(api)).pipe((0, _operators.map)(([info, slots]) => createDerive(api, info, slots))) : queryAura(api));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/session/sessionProgress.js":
/*!*******************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/session/sessionProgress.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sessionProgress = sessionProgress;

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
function sessionProgress(instanceId, api) {
  return (0, _util.memo)(instanceId, () => api.derive.session.progress().pipe((0, _operators.map)(info => info.sessionProgress)));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/society/candidates.js":
/*!**************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/society/candidates.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.candidates = candidates;

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @description Get the candidate info for a society
 */
function candidates(instanceId, api) {
  return (0, _util.memo)(instanceId, () => api.query.society.candidates().pipe((0, _operators.switchMap)(candidates => (0, _rxjs.combineLatest)([(0, _rxjs.of)(candidates), api.query.society.suspendedCandidates.multi(candidates.map(({
    who
  }) => who))])), (0, _operators.map)(([candidates, suspended]) => candidates.map(({
    kind,
    value,
    who
  }, index) => ({
    accountId: who,
    isSuspended: suspended[index].isSome,
    kind,
    value
  })))));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/society/index.js":
/*!*********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/society/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _candidates = __webpack_require__(/*! ./candidates */ "../../node_modules/@polkadot/api-derive/society/candidates.js");

Object.keys(_candidates).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _candidates[key];
    }
  });
});

var _info = __webpack_require__(/*! ./info */ "../../node_modules/@polkadot/api-derive/society/info.js");

Object.keys(_info).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _info[key];
    }
  });
});

var _member = __webpack_require__(/*! ./member */ "../../node_modules/@polkadot/api-derive/society/member.js");

Object.keys(_member).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _member[key];
    }
  });
});

var _members = __webpack_require__(/*! ./members */ "../../node_modules/@polkadot/api-derive/society/members.js");

Object.keys(_members).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _members[key];
    }
  });
});

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/society/info.js":
/*!********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/society/info.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.info = info;

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @description Get the overall info for a society
 */
function info(instanceId, api) {
  return (0, _util.memo)(instanceId, () => api.queryMulti([api.query.society.bids, api.query.society.defender, api.query.society.founder, api.query.society.head, api.query.society.maxMembers, api.query.society.pot]).pipe((0, _operators.map)(([bids, defender, founder, head, maxMembers, pot]) => ({
    bids,
    defender: defender.unwrapOr(undefined),
    founder: founder.unwrapOr(undefined),
    hasDefender: defender.isSome && head.isSome && !head.eq(defender) || false,
    head: head.unwrapOr(undefined),
    maxMembers,
    pot
  }))));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/society/member.js":
/*!**********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/society/member.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.member = member;

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @description Get the member info for a society
 */
function member(instanceId, api) {
  return (0, _util.memo)(instanceId, accountId => api.queryMulti([[api.query.society.payouts, accountId], [api.query.society.strikes, accountId], [api.query.society.defenderVotes, accountId], [api.query.society.suspendedMembers, accountId], [api.query.society.vouching, accountId]]).pipe((0, _operators.map)(([payouts, strikes, defenderVotes, suspended, vouching]) => ({
    accountId,
    isSuspended: suspended.isTrue,
    payouts,
    strikes,
    vote: defenderVotes.unwrapOr(undefined),
    vouching: vouching.unwrapOr(undefined)
  }))));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/society/members.js":
/*!***********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/society/members.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.members = members;

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @description Get the member info for a society
 */
function members(instanceId, api) {
  return (0, _util.memo)(instanceId, () => api.query.society.members().pipe((0, _operators.switchMap)(members => (0, _rxjs.combineLatest)(members.map(accountId => api.derive.society.member(accountId))))));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/staking/account.js":
/*!***********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/staking/account.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.accounts = accounts;
exports.account = account;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js"));

var _bn = _interopRequireDefault(__webpack_require__(/*! bn.js */ "../../node_modules/bn.js/lib/bn.js"));

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _util2 = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function groupByEra(list) {
  return list.reduce((map, {
    era,
    value
  }) => {
    const key = era.toString();
    map[key] = (map[key] || _util.BN_ZERO).add(value.unwrap());
    return map;
  }, {});
}

function calculateUnlocking(api, stakingLedger, sessionInfo) {
  const results = Object.entries(groupByEra(((stakingLedger === null || stakingLedger === void 0 ? void 0 : stakingLedger.unlocking) || []).filter(({
    era
  }) => era.unwrap().gt(sessionInfo.activeEra)))).map(([eraString, value]) => ({
    remainingEras: new _bn.default(eraString).isub(sessionInfo.activeEra),
    value: api.registry.createType('Balance', value)
  }));
  return results.length ? results : undefined;
}

function redeemableSum(api, stakingLedger, sessionInfo) {
  return api.registry.createType('Balance', ((stakingLedger === null || stakingLedger === void 0 ? void 0 : stakingLedger.unlocking) || []).reduce((total, {
    era,
    value
  }) => {
    return sessionInfo.activeEra.gte(era.unwrap()) ? total.iadd(value.unwrap()) : total;
  }, new _bn.default(0)));
}

function parseResult(api, sessionInfo, keys, query) {
  return _objectSpread(_objectSpread(_objectSpread({}, keys), query), {}, {
    redeemable: redeemableSum(api, query.stakingLedger, sessionInfo),
    unlocking: calculateUnlocking(api, query.stakingLedger, sessionInfo)
  });
}
/**
 * @description From a list of stashes, fill in all the relevant staking details
 */


function accounts(instanceId, api) {
  return (0, _util2.memo)(instanceId, accountIds => api.derive.session.info().pipe((0, _operators.switchMap)(sessionInfo => (0, _rxjs.combineLatest)([api.derive.staking.keysMulti(accountIds), api.derive.staking.queryMulti(accountIds)]).pipe((0, _operators.map)(([keys, queries]) => queries.map((query, index) => parseResult(api, sessionInfo, keys[index], query)))))));
}
/**
 * @description From a stash, retrieve the controllerId and fill in all the relevant staking details
 */


function account(instanceId, api) {
  return (0, _util2.memo)(instanceId, accountId => api.derive.staking.accounts([accountId]).pipe((0, _operators.map)(([first]) => first)));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/staking/currentPoints.js":
/*!*****************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/staking/currentPoints.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.currentPoints = currentPoints;

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
function retrievePointsPrev(api, currentElected) {
  return api.query.staking.currentEraPointsEarned().pipe((0, _operators.map)(({
    individual,
    total
  }) => api.registry.createType('EraRewardPoints', {
    individual: new Map(individual.map(points => api.registry.createType('RewardPoint', points)).map((points, index) => [currentElected[index], points])),
    total
  })));
}
/**
 * @description Retrieve the staking overview, including elected and points earned
 */


function currentPoints(instanceId, api) {
  return (0, _util.memo)(instanceId, () => api.derive.staking.overview().pipe((0, _operators.switchMap)(({
    activeEra,
    nextElected
  }) => api.query.staking.erasRewardPoints ? api.query.staking.erasRewardPoints(activeEra) : api.query.staking.currentEraPointsEarned ? retrievePointsPrev(api, nextElected) : (0, _rxjs.of)(api.registry.createType('EraRewardPoints')))));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/staking/electedInfo.js":
/*!***************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/staking/electedInfo.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.electedInfo = electedInfo;

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
function electedInfo(instanceId, api) {
  return (0, _util.memo)(instanceId, () => api.derive.staking.validators().pipe((0, _operators.switchMap)(({
    nextElected
  }) => api.derive.staking.queryMulti(nextElected).pipe((0, _operators.map)(info => ({
    info,
    nextElected
  }))))));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/staking/erasExposure.js":
/*!****************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/staking/erasExposure.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._eraExposure = _eraExposure;
exports.eraExposure = eraExposure;
exports._erasExposure = _erasExposure;
exports.erasExposure = erasExposure;

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
const CACHE_KEY = 'eraExposure';

function mapStakers(era, stakers) {
  const nominators = {};
  const validators = {};
  stakers.forEach(([key, exposure]) => {
    const validatorId = key.args[1].toString();
    validators[validatorId] = exposure;
    exposure.others.forEach(({
      who
    }, validatorIndex) => {
      const nominatorId = who.toString();
      nominators[nominatorId] = nominators[nominatorId] || [];
      nominators[nominatorId].push({
        validatorId,
        validatorIndex
      });
    });
  });
  return {
    era,
    nominators,
    validators
  };
}

function _eraExposure(instanceId, api) {
  return (0, _util.memo)(instanceId, (era, withActive) => {
    const cacheKey = `${CACHE_KEY}-${era.toString()}`;
    const cached = withActive ? undefined : _util.deriveCache.get(cacheKey);
    return cached ? (0, _rxjs.of)(cached) : api.query.staking.erasStakersClipped.entries(era).pipe((0, _operators.map)(stakers => {
      const value = mapStakers(era, stakers);
      !withActive && _util.deriveCache.set(cacheKey, value);
      return value;
    }));
  });
}

function eraExposure(instanceId, api) {
  return (0, _util.memo)(instanceId, era => api.derive.staking._eraExposure(era, true));
}

function _erasExposure(instanceId, api) {
  return (0, _util.memo)(instanceId, (eras, withActive) => eras.length ? (0, _rxjs.combineLatest)(eras.map(era => api.derive.staking._eraExposure(era, withActive))) : (0, _rxjs.of)([]));
}

function erasExposure(instanceId, api) {
  return (0, _util.memo)(instanceId, (withActive = false) => api.derive.staking.erasHistoric(withActive).pipe((0, _operators.switchMap)(eras => api.derive.staking._erasExposure(eras, withActive))));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/staking/erasHistoric.js":
/*!****************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/staking/erasHistoric.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.erasHistoric = erasHistoric;

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
function erasHistoric(instanceId, api) {
  return (0, _util.memo)(instanceId, withActive => {
    var _api$query$staking;

    return ((_api$query$staking = api.query.staking) === null || _api$query$staking === void 0 ? void 0 : _api$query$staking.activeEra) ? api.queryMulti([api.query.staking.activeEra, api.query.staking.historyDepth]).pipe((0, _operators.map)(([activeEraOpt, historyDepth]) => {
      const result = [];
      const max = historyDepth.toNumber();
      const activeEra = activeEraOpt.unwrapOrDefault().index;
      let lastEra = activeEra;

      while (lastEra.gten(0) && result.length < max) {
        if (lastEra !== activeEra || withActive === true) {
          result.push(api.registry.createType('EraIndex', lastEra));
        }

        lastEra = lastEra.subn(1);
      } // go from oldest to newest


      return result.reverse();
    })) : (0, _rxjs.of)([]);
  });
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/staking/erasPoints.js":
/*!**************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/staking/erasPoints.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._erasPoints = _erasPoints;
exports.erasPoints = erasPoints;

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _util2 = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
const CACHE_KEY = 'eraPoints';

function mapValidators({
  individual
}) {
  return [...individual.entries()].filter(([, points]) => points.gt(_util.BN_ZERO)).reduce((result, [validatorId, points]) => {
    result[validatorId.toString()] = points;
    return result;
  }, {});
}

function mapPoints(eras, points) {
  return eras.map((era, index) => ({
    era,
    eraPoints: points[index].total,
    validators: mapValidators(points[index])
  }));
}

function _erasPoints(instanceId, api) {
  return (0, _util2.memo)(instanceId, (eras, withActive) => {
    if (!eras.length) {
      return (0, _rxjs.of)([]);
    }

    const cached = withActive ? [] : eras.map(era => _util2.deriveCache.get(`${CACHE_KEY}-${era.toString()}`)).filter(value => !!value);
    const remaining = eras.filter(era => !cached.some(cached => era.eq(cached.era)));
    return !remaining.length ? (0, _rxjs.of)(cached) : api.query.staking.erasRewardPoints.multi(remaining).pipe((0, _operators.map)(points => {
      const query = mapPoints(remaining, points);
      !withActive && query.forEach(q => _util2.deriveCache.set(`${CACHE_KEY}-${q.era.toString()}`, q));
      return eras.map(era => cached.find(cached => era.eq(cached.era)) || query.find(query => era.eq(query.era)));
    }));
  });
}

function erasPoints(instanceId, api) {
  return (0, _util2.memo)(instanceId, (withActive = false) => api.derive.staking.erasHistoric(withActive).pipe((0, _operators.switchMap)(eras => api.derive.staking._erasPoints(eras, withActive))));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/staking/erasPrefs.js":
/*!*************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/staking/erasPrefs.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._eraPrefs = _eraPrefs;
exports.eraPrefs = eraPrefs;
exports._erasPrefs = _erasPrefs;
exports.erasPrefs = erasPrefs;

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
const CACHE_KEY = 'eraPrefs';

function mapPrefs(era, all) {
  const validators = {};
  all.forEach(([key, prefs]) => {
    validators[key.args[1].toString()] = prefs;
  });
  return {
    era,
    validators
  };
}

function _eraPrefs(instanceId, api) {
  return (0, _util.memo)(instanceId, (era, withActive) => {
    const cacheKey = `${CACHE_KEY}-${era.toString()}`;
    const cached = withActive ? undefined : _util.deriveCache.get(cacheKey);
    return cached ? (0, _rxjs.of)(cached) : api.query.staking.erasValidatorPrefs.entries(era).pipe((0, _operators.map)(prefs => {
      const value = mapPrefs(era, prefs);
      !withActive && _util.deriveCache.set(cacheKey, value);
      return value;
    }));
  });
}

function eraPrefs(instanceId, api) {
  return (0, _util.memo)(instanceId, era => api.derive.staking._eraPrefs(era, true));
}

function _erasPrefs(instanceId, api) {
  return (0, _util.memo)(instanceId, (eras, withActive) => eras.length ? (0, _rxjs.combineLatest)(eras.map(era => api.derive.staking._eraPrefs(era, withActive))) : (0, _rxjs.of)([]));
}

function erasPrefs(instanceId, api) {
  return (0, _util.memo)(instanceId, (withActive = false) => api.derive.staking.erasHistoric(withActive).pipe((0, _operators.switchMap)(eras => api.derive.staking._erasPrefs(eras, withActive))));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/staking/erasRewards.js":
/*!***************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/staking/erasRewards.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._erasRewards = _erasRewards;
exports.erasRewards = erasRewards;

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
const CACHE_KEY = 'eraRewards';

function mapRewards(eras, optRewards) {
  return eras.map((era, index) => ({
    era,
    eraReward: optRewards[index].unwrapOrDefault()
  }));
}

function _erasRewards(instanceId, api) {
  return (0, _util.memo)(instanceId, (eras, withActive) => {
    if (!eras.length) {
      return (0, _rxjs.of)([]);
    }

    const cached = withActive ? [] : eras.map(era => _util.deriveCache.get(`${CACHE_KEY}-${era.toString()}`)).filter(value => !!value);
    const remaining = eras.filter(era => !cached.some(cached => era.eq(cached.era)));

    if (!remaining.length) {
      return (0, _rxjs.of)(cached);
    }

    return api.query.staking.erasValidatorReward.multi(remaining).pipe((0, _operators.map)(optRewards => {
      const query = mapRewards(remaining, optRewards);
      !withActive && query.forEach(q => _util.deriveCache.set(`${CACHE_KEY}-${q.era.toString()}`, q));
      return eras.map(era => cached.find(cached => era.eq(cached.era)) || query.find(query => era.eq(query.era)));
    }));
  });
}

function erasRewards(instanceId, api) {
  return (0, _util.memo)(instanceId, (withActive = false) => api.derive.staking.erasHistoric(withActive).pipe((0, _operators.switchMap)(eras => api.derive.staking._erasRewards(eras, withActive))));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/staking/erasSlashes.js":
/*!***************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/staking/erasSlashes.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._eraSlashes = _eraSlashes;
exports.eraSlashes = eraSlashes;
exports._erasSlashes = _erasSlashes;
exports.erasSlashes = erasSlashes;

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
const CACHE_KEY = 'eraSlashes';

function mapSlashes(era, noms, vals) {
  const nominators = {};
  const validators = {};
  noms.forEach(([key, optBalance]) => {
    nominators[key.args[1].toString()] = optBalance.unwrap();
  });
  vals.forEach(([key, optRes]) => {
    validators[key.args[1].toString()] = optRes.unwrapOrDefault()[1];
  });
  return {
    era,
    nominators,
    validators
  };
}

function _eraSlashes(instanceId, api) {
  return (0, _util.memo)(instanceId, (era, withActive) => {
    const cacheKey = `${CACHE_KEY}-${era.toString()}`;
    const cached = withActive ? undefined : _util.deriveCache.get(cacheKey);
    return cached ? (0, _rxjs.of)(cached) : (0, _rxjs.combineLatest)([api.query.staking.nominatorSlashInEra.entries(era), api.query.staking.validatorSlashInEra.entries(era)]).pipe((0, _operators.map)(([noms, vals]) => {
      const value = mapSlashes(era, noms, vals);
      !withActive && _util.deriveCache.set(cacheKey, value);
      return value;
    }));
  });
}

function eraSlashes(instanceId, api) {
  return (0, _util.memo)(instanceId, era => api.derive.staking._eraSlashes(era, true));
}

function _erasSlashes(instanceId, api) {
  return (0, _util.memo)(instanceId, (eras, withActive) => eras.length ? (0, _rxjs.combineLatest)(eras.map(era => api.derive.staking._eraSlashes(era, withActive))) : (0, _rxjs.of)([]));
}

function erasSlashes(instanceId, api) {
  return (0, _util.memo)(instanceId, (withActive = false) => api.derive.staking.erasHistoric(withActive).pipe((0, _operators.switchMap)(eras => api.derive.staking._erasSlashes(eras, withActive))));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/staking/index.js":
/*!*********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/staking/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _account = __webpack_require__(/*! ./account */ "../../node_modules/@polkadot/api-derive/staking/account.js");

Object.keys(_account).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _account[key];
    }
  });
});

var _currentPoints = __webpack_require__(/*! ./currentPoints */ "../../node_modules/@polkadot/api-derive/staking/currentPoints.js");

Object.keys(_currentPoints).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _currentPoints[key];
    }
  });
});

var _erasExposure = __webpack_require__(/*! ./erasExposure */ "../../node_modules/@polkadot/api-derive/staking/erasExposure.js");

Object.keys(_erasExposure).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _erasExposure[key];
    }
  });
});

var _erasHistoric = __webpack_require__(/*! ./erasHistoric */ "../../node_modules/@polkadot/api-derive/staking/erasHistoric.js");

Object.keys(_erasHistoric).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _erasHistoric[key];
    }
  });
});

var _erasPoints = __webpack_require__(/*! ./erasPoints */ "../../node_modules/@polkadot/api-derive/staking/erasPoints.js");

Object.keys(_erasPoints).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _erasPoints[key];
    }
  });
});

var _erasPrefs = __webpack_require__(/*! ./erasPrefs */ "../../node_modules/@polkadot/api-derive/staking/erasPrefs.js");

Object.keys(_erasPrefs).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _erasPrefs[key];
    }
  });
});

var _erasRewards = __webpack_require__(/*! ./erasRewards */ "../../node_modules/@polkadot/api-derive/staking/erasRewards.js");

Object.keys(_erasRewards).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _erasRewards[key];
    }
  });
});

var _erasSlashes = __webpack_require__(/*! ./erasSlashes */ "../../node_modules/@polkadot/api-derive/staking/erasSlashes.js");

Object.keys(_erasSlashes).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _erasSlashes[key];
    }
  });
});

var _electedInfo = __webpack_require__(/*! ./electedInfo */ "../../node_modules/@polkadot/api-derive/staking/electedInfo.js");

Object.keys(_electedInfo).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _electedInfo[key];
    }
  });
});

var _keys = __webpack_require__(/*! ./keys */ "../../node_modules/@polkadot/api-derive/staking/keys.js");

Object.keys(_keys).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _keys[key];
    }
  });
});

var _overview = __webpack_require__(/*! ./overview */ "../../node_modules/@polkadot/api-derive/staking/overview.js");

Object.keys(_overview).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _overview[key];
    }
  });
});

var _ownExposure = __webpack_require__(/*! ./ownExposure */ "../../node_modules/@polkadot/api-derive/staking/ownExposure.js");

Object.keys(_ownExposure).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _ownExposure[key];
    }
  });
});

var _ownSlashes = __webpack_require__(/*! ./ownSlashes */ "../../node_modules/@polkadot/api-derive/staking/ownSlashes.js");

Object.keys(_ownSlashes).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _ownSlashes[key];
    }
  });
});

var _query = __webpack_require__(/*! ./query */ "../../node_modules/@polkadot/api-derive/staking/query.js");

Object.keys(_query).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _query[key];
    }
  });
});

var _stakerExposure = __webpack_require__(/*! ./stakerExposure */ "../../node_modules/@polkadot/api-derive/staking/stakerExposure.js");

Object.keys(_stakerExposure).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _stakerExposure[key];
    }
  });
});

var _stakerPoints = __webpack_require__(/*! ./stakerPoints */ "../../node_modules/@polkadot/api-derive/staking/stakerPoints.js");

Object.keys(_stakerPoints).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _stakerPoints[key];
    }
  });
});

var _stakerPrefs = __webpack_require__(/*! ./stakerPrefs */ "../../node_modules/@polkadot/api-derive/staking/stakerPrefs.js");

Object.keys(_stakerPrefs).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _stakerPrefs[key];
    }
  });
});

var _stakerRewards = __webpack_require__(/*! ./stakerRewards */ "../../node_modules/@polkadot/api-derive/staking/stakerRewards.js");

Object.keys(_stakerRewards).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _stakerRewards[key];
    }
  });
});

var _stakerSlashes = __webpack_require__(/*! ./stakerSlashes */ "../../node_modules/@polkadot/api-derive/staking/stakerSlashes.js");

Object.keys(_stakerSlashes).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _stakerSlashes[key];
    }
  });
});

var _stashes = __webpack_require__(/*! ./stashes */ "../../node_modules/@polkadot/api-derive/staking/stashes.js");

Object.keys(_stashes).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _stashes[key];
    }
  });
});

var _validators = __webpack_require__(/*! ./validators */ "../../node_modules/@polkadot/api-derive/staking/validators.js");

Object.keys(_validators).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _validators[key];
    }
  });
});

var _validatorsFrom = __webpack_require__(/*! ./validatorsFrom */ "../../node_modules/@polkadot/api-derive/staking/validatorsFrom.js");

Object.keys(_validatorsFrom).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _validatorsFrom[key];
    }
  });
});

var _waitingInfo = __webpack_require__(/*! ./waitingInfo */ "../../node_modules/@polkadot/api-derive/staking/waitingInfo.js");

Object.keys(_waitingInfo).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _waitingInfo[key];
    }
  });
});

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/staking/keys.js":
/*!********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/staking/keys.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.keys = keys;
exports.keysMulti = keysMulti;

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
function extractsIds(stashId, queuedKeys, nextKeys) {
  const sessionIds = (queuedKeys.find(([currentId]) => currentId.eq(stashId)) || [undefined, []])[1];
  const nextSessionIds = nextKeys.unwrapOr([]);
  return {
    nextSessionIds,
    sessionIds
  };
}

function keys(instanceId, api) {
  return (0, _util.memo)(instanceId, stashId => api.derive.staking.keysMulti([stashId]).pipe((0, _operators.map)(([first]) => first)));
}

function keysMulti(instanceId, api) {
  return (0, _util.memo)(instanceId, stashIds => stashIds.length ? api.query.session.queuedKeys().pipe((0, _operators.switchMap)(queuedKeys => {
    var _api$consts$session;

    return (0, _rxjs.combineLatest)([(0, _rxjs.of)(queuedKeys), ((_api$consts$session = api.consts.session) === null || _api$consts$session === void 0 ? void 0 : _api$consts$session.dedupKeyPrefix) ? api.query.session.nextKeys.multi(stashIds.map(stashId => [api.consts.session.dedupKeyPrefix, stashId])) : api.query.session.nextKeys.multi(stashIds)]);
  }), (0, _operators.map)(([queuedKeys, nextKeys]) => stashIds.map((stashId, index) => extractsIds(stashId, queuedKeys, nextKeys[index])))) : (0, _rxjs.of)([]));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/staking/overview.js":
/*!************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/staking/overview.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.overview = overview;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js"));

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * @description Retrieve the staking overview, including elected and points earned
 */
function overview(instanceId, api) {
  return (0, _util.memo)(instanceId, () => (0, _rxjs.combineLatest)([api.derive.session.indexes(), api.derive.staking.validators()]).pipe((0, _operators.map)(([indexes, {
    nextElected,
    validators
  }]) => _objectSpread(_objectSpread({}, indexes), {}, {
    nextElected,
    validators
  }))));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/staking/ownExposure.js":
/*!***************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/staking/ownExposure.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._ownExposure = _ownExposure;
exports.ownExposure = ownExposure;
exports._ownExposures = _ownExposures;
exports.ownExposures = ownExposures;

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
const CACHE_KEY = 'ownExposure';

function _ownExposure(instanceId, api) {
  return (0, _util.memo)(instanceId, (accountId, era, withActive) => {
    const cacheKey = `${CACHE_KEY}-${era.toString()}-${accountId.toString()}`;
    const cached = withActive ? undefined : _util.deriveCache.get(cacheKey);
    return cached ? (0, _rxjs.of)(cached) : api.queryMulti([[api.query.staking.erasStakersClipped, [era, accountId]], [api.query.staking.erasStakers, [era, accountId]]]).pipe((0, _operators.map)(([clipped, exposure]) => {
      const value = {
        clipped,
        era,
        exposure
      };
      !withActive && _util.deriveCache.set(cacheKey, value);
      return value;
    }));
  });
}

function ownExposure(instanceId, api) {
  return (0, _util.memo)(instanceId, (accountId, era) => api.derive.staking._ownExposure(accountId, era, true));
}

function _ownExposures(instanceId, api) {
  return (0, _util.memo)(instanceId, (accountId, eras, withActive) => eras.length ? (0, _rxjs.combineLatest)(eras.map(era => api.derive.staking._ownExposure(accountId, era, withActive))) : (0, _rxjs.of)([]));
}

function ownExposures(instanceId, api) {
  return (0, _util.memo)(instanceId, (accountId, withActive = false) => {
    return api.derive.staking.erasHistoric(withActive).pipe((0, _operators.switchMap)(eras => api.derive.staking._ownExposures(accountId, eras, withActive)));
  });
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/staking/ownSlashes.js":
/*!**************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/staking/ownSlashes.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._ownSlash = _ownSlash;
exports.ownSlash = ownSlash;
exports._ownSlashes = _ownSlashes;
exports.ownSlashes = ownSlashes;

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
const CACHE_KEY = 'ownSlash';

function _ownSlash(instanceId, api) {
  return (0, _util.memo)(instanceId, (accountId, era, withActive) => {
    const cacheKey = `${CACHE_KEY}-${era.toString()}-${accountId.toString()}`;
    const cached = withActive ? undefined : _util.deriveCache.get(cacheKey);
    return cached ? (0, _rxjs.of)(cached) : api.queryMulti([[api.query.staking.nominatorSlashInEra, [era, accountId]], [api.query.staking.validatorSlashInEra, [era, accountId]]]).pipe((0, _operators.map)(([optNom, optVal]) => {
      const value = {
        era,
        total: optVal.isSome ? optVal.unwrap()[1] : optNom.unwrapOrDefault()
      };
      !withActive && _util.deriveCache.set(cacheKey, value);
      return value;
    }));
  });
}

function ownSlash(instanceId, api) {
  return (0, _util.memo)(instanceId, (accountId, era) => api.derive.staking._ownSlash(accountId, era, true));
}

function _ownSlashes(instanceId, api) {
  return (0, _util.memo)(instanceId, (accountId, eras, withActive) => eras.length ? (0, _rxjs.combineLatest)(eras.map(era => api.derive.staking._ownSlash(accountId, era, withActive))) : (0, _rxjs.of)([]));
}

function ownSlashes(instanceId, api) {
  return (0, _util.memo)(instanceId, (accountId, withActive = false) => {
    return api.derive.staking.erasHistoric(withActive).pipe((0, _operators.switchMap)(eras => api.derive.staking._ownSlashes(accountId, eras, withActive)));
  });
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/staking/query.js":
/*!*********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/staking/query.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.query = query;
exports.queryMulti = queryMulti;

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _util2 = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
function parseController(stashId, [controllerIdOpt, nominatorsOpt, rewardDestination, validatorPrefs, exposure], stakingLedgerOpt) {
  const nominators = nominatorsOpt.unwrapOr(null);
  return {
    accountId: stashId,
    controllerId: controllerIdOpt.unwrapOr(null),
    exposure,
    nominators: nominators ? Array.isArray(nominators) ? nominators[0].targets : nominators.targets : [],
    rewardDestination,
    stakingLedger: stakingLedgerOpt.unwrapOrDefault(),
    stashId,
    validatorPrefs: Array.isArray(validatorPrefs) ? validatorPrefs[0] : validatorPrefs
  };
}

function retrievePrev(api, stashId) {
  return api.queryMulti([[api.query.staking.bonded, stashId], [api.query.staking.nominators, stashId], [api.query.staking.payee, stashId], [api.query.staking.validators, stashId], [api.query.staking.stakers, stashId]]);
}

function retrieveCurr(api, stashIds, activeEra) {
  return (0, _rxjs.combineLatest)([api.query.staking.bonded.multi(stashIds), api.query.staking.nominators ? api.query.staking.nominators.multi(stashIds) : (0, _rxjs.of)(stashIds.map(() => api.registry.createType('Option<Nominations>'))), api.query.staking.payee.multi(stashIds), api.query.staking.validators.multi(stashIds), api.query.staking.erasStakers.multi(stashIds.map(stashId => [activeEra, stashId]))]).pipe((0, _operators.map)(([controllerIdOpt, nominatorsOpt, rewardDestination, validatorPrefs, exposure]) => controllerIdOpt.map((controllerIdOpt, index) => [controllerIdOpt, nominatorsOpt[index], rewardDestination[index], validatorPrefs[index], exposure[index]])));
}

function retrieveControllers(api, optControllerIds) {
  const ids = optControllerIds.filter(opt => opt.isSome).map(opt => opt.unwrap());

  if (!ids.length) {
    return (0, _rxjs.of)(optControllerIds.map(() => api.registry.createType('Option<StakingLedger>')));
  }

  return api.query.staking.ledger.multi(ids).pipe((0, _operators.map)(optLedgers => {
    let offset = -1;
    return optControllerIds.map(opt => opt.isSome ? optLedgers[++offset] : api.registry.createType('Option<StakingLedger>'));
  }));
}
/**
 * @description From a stash, retrieve the controllerId and all relevant details
 */


function query(instanceId, api) {
  return (0, _util2.memo)(instanceId, accountId => api.derive.staking.queryMulti([accountId]).pipe((0, _operators.map)(([first]) => first)));
}

function queryMulti(instanceId, api) {
  return (0, _util2.memo)(instanceId, accountIds => accountIds.length ? api.derive.session.indexes().pipe((0, _operators.switchMap)(({
    activeEra
  }) => {
    const stashIds = accountIds.map(accountId => api.registry.createType('AccountId', accountId));
    return ((0, _util.isFunction)(api.query.staking.erasStakers) ? retrieveCurr(api, stashIds, activeEra) : (0, _rxjs.combineLatest)(stashIds.map(stashId => retrievePrev(api, stashId)))).pipe((0, _operators.switchMap)(results => retrieveControllers(api, results.map(([optController]) => optController)).pipe((0, _operators.map)(stakingLedgerOpts => stashIds.map((stashId, index) => parseController(stashId, results[index], stakingLedgerOpts[index]))))));
  })) : (0, _rxjs.of)([]));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/staking/stakerExposure.js":
/*!******************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/staking/stakerExposure.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._stakerExposure = _stakerExposure;
exports.stakerExposure = stakerExposure;

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
function _stakerExposure(instanceId, api) {
  return (0, _util.memo)(instanceId, (accountId, eras, withActive) => {
    const stakerId = api.registry.createType('AccountId', accountId).toString();
    return api.derive.staking._erasExposure(eras, withActive).pipe((0, _operators.map)(exposures => exposures.map(({
      era,
      nominators: allNominators,
      validators: allValidators
    }) => {
      const isValidator = !!allValidators[stakerId];
      const validators = {};
      const nominating = allNominators[stakerId] || [];

      if (isValidator) {
        validators[stakerId] = allValidators[stakerId];
      } else if (nominating) {
        nominating.forEach(({
          validatorId
        }) => {
          validators[validatorId] = allValidators[validatorId];
        });
      }

      return {
        era,
        isEmpty: !Object.keys(validators).length,
        isValidator,
        nominating,
        validators
      };
    })));
  });
}

function stakerExposure(instanceId, api) {
  return (0, _util.memo)(instanceId, (accountId, withActive = false) => api.derive.staking.erasHistoric(withActive).pipe((0, _operators.switchMap)(eras => api.derive.staking._stakerExposure(accountId, eras, withActive))));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/staking/stakerPoints.js":
/*!****************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/staking/stakerPoints.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._stakerPoints = _stakerPoints;
exports.stakerPoints = stakerPoints;

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
function _stakerPoints(instanceId, api) {
  return (0, _util.memo)(instanceId, (accountId, eras, withActive) => {
    const stakerId = api.registry.createType('AccountId', accountId).toString();
    return api.derive.staking._erasPoints(eras, withActive).pipe((0, _operators.map)(points => points.map(({
      era,
      eraPoints,
      validators
    }) => ({
      era,
      eraPoints,
      points: validators[stakerId] || api.registry.createType('RewardPoint')
    }))));
  });
}

function stakerPoints(instanceId, api) {
  return (0, _util.memo)(instanceId, (accountId, withActive = false) => api.derive.staking.erasHistoric(withActive).pipe((0, _operators.switchMap)(eras => api.derive.staking._stakerPoints(accountId, eras, withActive))));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/staking/stakerPrefs.js":
/*!***************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/staking/stakerPrefs.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._stakerPrefs = _stakerPrefs;
exports.stakerPrefs = stakerPrefs;

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
function _stakerPrefs(instanceId, api) {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  return (0, _util.memo)(instanceId, (accountId, eras, _withActive) => {
    return api.query.staking.erasValidatorPrefs.multi(eras.map(era => [era, accountId])).pipe((0, _operators.map)(all => all.map((validatorPrefs, index) => ({
      era: eras[index],
      validatorPrefs
    }))));
  });
}

function stakerPrefs(instanceId, api) {
  return (0, _util.memo)(instanceId, (accountId, withActive = false) => api.derive.staking.erasHistoric(withActive).pipe((0, _operators.switchMap)(eras => api.derive.staking._stakerPrefs(accountId, eras, withActive))));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/staking/stakerRewards.js":
/*!*****************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/staking/stakerRewards.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._stakerRewardsEras = _stakerRewardsEras;
exports._stakerRewards = _stakerRewards;
exports.stakerRewards = stakerRewards;
exports.stakerRewardsMultiEras = stakerRewardsMultiEras;
exports.stakerRewardsMulti = stakerRewardsMulti;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js"));

var _bn = _interopRequireDefault(__webpack_require__(/*! bn.js */ "../../node_modules/bn.js/lib/bn.js"));

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _util2 = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const ZERO = new _bn.default(0);
const MIN_ONE = new _bn.default(-1);
const COMM_DIV = new _bn.default(1000000000);
const MAX_ERAS = new _bn.default(1000000000);

function parseRewards(api, stashId, [, erasPoints, erasPrefs, erasRewards], exposures) {
  return exposures.map(({
    era,
    isEmpty,
    isValidator,
    nominating,
    validators: eraValidators
  }) => {
    const {
      eraPoints,
      validators: allValPoints
    } = erasPoints.find(p => p.era.eq(era)) || {
      eraPoints: ZERO,
      validators: {}
    };
    const {
      eraReward
    } = erasRewards.find(r => r.era.eq(era)) || {
      eraReward: api.registry.createType('Balance')
    };
    const {
      validators: allValPrefs
    } = erasPrefs.find(p => p.era.eq(era)) || {
      validators: {}
    };
    const validators = {};
    const stakerId = stashId.toString();
    Object.entries(eraValidators).forEach(([validatorId, exposure]) => {
      var _allValPrefs$validato;

      const valPoints = allValPoints[validatorId] || ZERO;
      const valComm = ((_allValPrefs$validato = allValPrefs[validatorId]) === null || _allValPrefs$validato === void 0 ? void 0 : _allValPrefs$validato.commission.unwrap()) || ZERO;
      const expTotal = exposure.total.unwrap();
      let avail = ZERO;
      let value;

      if (!(expTotal.isZero() || valPoints.isZero() || eraPoints.isZero())) {
        avail = eraReward.mul(valPoints).div(eraPoints);
        const valCut = valComm.mul(avail).div(COMM_DIV);
        let staked;

        if (validatorId === stakerId) {
          staked = exposure.own.unwrap();
        } else {
          const stakerExp = exposure.others.find(({
            who
          }) => who.eq(stakerId));
          staked = stakerExp ? stakerExp.value.unwrap() : ZERO;
        }

        value = avail.sub(valCut).imul(staked).div(expTotal).iadd(validatorId === stakerId ? valCut : ZERO);
      }

      validators[validatorId] = {
        total: api.registry.createType('Balance', avail),
        value: api.registry.createType('Balance', value)
      };
    });
    return {
      era,
      eraReward,
      isEmpty,
      isValidator,
      nominating,
      validators
    };
  });
}

function uniqValidators(rewards) {
  const uniq = [];
  rewards.forEach(({
    validators
  }) => {
    Object.keys(validators).forEach(validatorId => {
      if (!uniq.includes(validatorId)) {
        uniq.push(validatorId);
      }
    });
  });
  return uniq;
}

function isOldLedger(ledger) {
  return !!(ledger === null || ledger === void 0 ? void 0 : ledger.lastReward);
}

function filterEra(era, stakingLedger) {
  return isOldLedger(stakingLedger) ? era.gt(stakingLedger.lastReward.unwrapOr(MIN_ONE)) : !stakingLedger.claimedRewards.some(e => e.eq(era));
}

function filterEras(eras, stakingLedger) {
  return eras.filter(era => filterEra(era, stakingLedger));
}

function filterRewards(api, eras, migrateEra, rewards, stakingLedger, withActive) {
  if (withActive) {
    return (0, _rxjs.of)(rewards);
  }

  const validators = uniqValidators(rewards);
  return ((0, _util.isFunction)(api.tx.staking.payoutStakers) ? api.derive.staking.queryMulti(validators) : (0, _rxjs.of)([])).pipe((0, _operators.map)(queryValidators => {
    const filter = withActive ? eras : filterEras(eras, stakingLedger);
    return rewards.filter(({
      isEmpty
    }) => !isEmpty).filter(reward => {
      if (!filter.some(filter => reward.era.eq(filter))) {
        return false;
      } else if (reward.era.lt(migrateEra)) {
        // we filter again here, the actual ledger may have changed, e.g. something has been claimed
        return filterEra(reward.era, stakingLedger);
      }

      reward.isStakerPayout = true;
      const rm = [];
      Object.keys(reward.validators).forEach(validatorId => {
        const index = validators.indexOf(validatorId);

        if (index !== -1) {
          const valLedger = queryValidators[index].stakingLedger;

          if (valLedger === null || valLedger === void 0 ? void 0 : valLedger.claimedRewards.some(era => reward.era.eq(era))) {
            rm.push(validatorId);
          }
        }
      });
      rm.forEach(validatorId => {
        delete reward.validators[validatorId];
      });
      return true;
    }).filter(({
      validators
    }) => Object.keys(validators).length !== 0).map(reward => _objectSpread(_objectSpread({}, reward), {}, {
      nominators: reward.nominating.filter(({
        validatorId
      }) => !!reward.validators[validatorId])
    }));
  }));
}

function _stakerRewardsEras(instanceId, api) {
  return (0, _util2.memo)(instanceId, (eras, withActive) => (0, _rxjs.combineLatest)([(0, _util.isFunction)(api.query.staking.migrateEra) ? api.query.staking.migrateEra() : (0, _rxjs.of)({
    unwrapOr: () => (0, _util.isFunction)(api.tx.staking.payoutStakers) ? ZERO : MAX_ERAS
  }), api.derive.staking._erasPoints(eras, withActive), api.derive.staking._erasPrefs(eras, withActive), api.derive.staking._erasRewards(eras, withActive)]));
}

function _stakerRewards(instanceId, api) {
  return (0, _util2.memo)(instanceId, (accountId, eras, withActive) => (0, _rxjs.combineLatest)([api.derive.staking.query(accountId), api.derive.staking._stakerExposure(accountId, eras, withActive), api.derive.staking._stakerRewardsEras(eras, withActive)]).pipe((0, _operators.switchMap)(([{
    stakingLedger,
    stashId
  }, exposures, erasResult]) => {
    const migrateEra = erasResult[0].unwrapOr(ZERO);

    if (!stashId || !stakingLedger) {
      return (0, _rxjs.of)([]);
    }

    return filterRewards(api, eras, migrateEra, parseRewards(api, stashId, erasResult, exposures), stakingLedger, withActive);
  })));
}

function stakerRewards(instanceId, api) {
  return (0, _util2.memo)(instanceId, (accountId, withActive = false) => api.derive.staking.erasHistoric(withActive).pipe((0, _operators.switchMap)(eras => api.derive.staking._stakerRewards(accountId, eras, withActive))));
}

function stakerRewardsMultiEras(instanceId, api) {
  return (0, _util2.memo)(instanceId, (accountIds, eras) => accountIds.length && eras.length ? (0, _rxjs.combineLatest)(accountIds.map(acc => api.derive.staking._stakerRewards(acc, eras, false))) : (0, _rxjs.of)([]));
}

function stakerRewardsMulti(instanceId, api) {
  return (0, _util2.memo)(instanceId, (accountIds, withActive = false) => api.derive.staking.erasHistoric(withActive).pipe((0, _operators.switchMap)(eras => api.derive.staking.stakerRewardsMultiEras(accountIds, eras))));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/staking/stakerSlashes.js":
/*!*****************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/staking/stakerSlashes.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._stakerSlashes = _stakerSlashes;
exports.stakerSlashes = stakerSlashes;

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
function _stakerSlashes(instanceId, api) {
  return (0, _util.memo)(instanceId, (accountId, eras, withActive) => {
    const stakerId = api.registry.createType('AccountId', accountId).toString();
    return api.derive.staking._erasSlashes(eras, withActive).pipe((0, _operators.map)(slashes => slashes.map(({
      era,
      nominators,
      validators
    }) => ({
      era,
      total: nominators[stakerId] || validators[stakerId] || api.registry.createType('Balance')
    }))));
  });
}

function stakerSlashes(instanceId, api) {
  return (0, _util.memo)(instanceId, (accountId, withActive = false) => api.derive.staking.erasHistoric(withActive).pipe((0, _operators.switchMap)(eras => api.derive.staking._stakerSlashes(accountId, eras, withActive))));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/staking/stashes.js":
/*!***********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/staking/stashes.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.stashes = stashes;

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @description Retrieve the list of all validator stashes
 */
function stashes(instanceId, api) {
  return (0, _util.memo)(instanceId, () => api.query.staking.validators.keys().pipe((0, _operators.map)(keys => keys.map(key => key.args[0]).filter(a => a))));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/staking/validators.js":
/*!**************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/staking/validators.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.nextElected = nextElected;
exports.validators = validators;

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
function nextElected(instanceId, api) {
  return (0, _util.memo)(instanceId, () => api.query.staking.erasStakers ? api.derive.session.indexes().pipe( // only populate for next era in the last session, so track both here - entries are not
  // subscriptions, so we need a trigger - currentIndex acts as that trigger to refresh
  (0, _operators.switchMap)(({
    currentEra
  }) => api.query.staking.erasStakers.keys(currentEra)), (0, _operators.map)(keys => keys.map(key => key.args[1]))) : api.query.staking.currentElected());
}
/**
 * @description Retrieve latest list of validators
 */


function validators(instanceId, api) {
  return (0, _util.memo)(instanceId, () => // Sadly the node-template is (for some obscure reason) not comprehensive, so while the derive works
  // in all actual real-world deployed chains, it does create some confusion for limited template chains
  // NOTE: Not doing multi queries here, since we have validators as a single in the derived newHead
  (0, _rxjs.combineLatest)([api.query.session ? api.query.session.validators() : (0, _rxjs.of)([]), api.query.staking ? api.derive.staking.nextElected() : (0, _rxjs.of)([])]).pipe((0, _operators.map)(([validators, nextElected]) => ({
    nextElected: nextElected.length ? nextElected : validators,
    validators
  }))));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/staking/validatorsFrom.js":
/*!******************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/staking/validatorsFrom.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validatorsFrom = validatorsFrom;

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @description From a list of stashIds, staking ledgers for those acting as validators and those being nominated
 */
function validatorsFrom(instanceId, api) {
  return (0, _util.memo)(instanceId, stashIds => api.query.staking.nominators.multi(stashIds).pipe((0, _operators.switchMap)(optNoms => api.derive.staking.queryMulti(optNoms.reduce((validatorIds, optNom) => {
    return optNom.unwrapOrDefault().targets.reduce((validatorIds, targetId) => {
      if (!validatorIds.find(validatorId => validatorId.eq(targetId))) {
        validatorIds.push(targetId);
      }

      return validatorIds;
    }, validatorIds);
  }, [])))));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/staking/waitingInfo.js":
/*!***************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/staking/waitingInfo.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.waitingInfo = waitingInfo;

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
function waitingInfo(instanceId, api) {
  return (0, _util.memo)(instanceId, () => (0, _rxjs.combineLatest)([api.derive.staking.validators(), api.derive.staking.stashes()]).pipe((0, _operators.switchMap)(([{
    nextElected
  }, stashes]) => {
    const elected = nextElected.map(a => a.toString());
    const waiting = stashes.filter(v => !elected.includes(v.toString()));
    return api.derive.staking.queryMulti(waiting).pipe((0, _operators.map)(info => ({
      info,
      waiting
    })));
  })));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/technicalCommittee/index.js":
/*!********************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/technicalCommittee/index.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _proposals = __webpack_require__(/*! ./proposals */ "../../node_modules/@polkadot/api-derive/technicalCommittee/proposals.js");

Object.keys(_proposals).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _proposals[key];
    }
  });
});

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/technicalCommittee/proposals.js":
/*!************************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/technicalCommittee/proposals.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.proposals = proposals;

var _collective = __webpack_require__(/*! ../collective */ "../../node_modules/@polkadot/api-derive/collective/index.js");

var _util = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
function proposals(instanceId, api) {
  return (0, _util.memo)(instanceId, (0, _collective.proposals)(instanceId, api, 'technicalCommittee'));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/treasury/index.js":
/*!**********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/treasury/index.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _proposals = __webpack_require__(/*! ./proposals */ "../../node_modules/@polkadot/api-derive/treasury/proposals.js");

Object.keys(_proposals).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _proposals[key];
    }
  });
});

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/treasury/proposals.js":
/*!**************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/treasury/proposals.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.proposals = proposals;

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
function parseResult(_api, {
  allIds,
  allProposals,
  approvalIds,
  councilProposals,
  proposalCount
}) {
  const approvals = [];
  const proposals = [];
  const councilTreasury = councilProposals.filter(({
    proposal: {
      methodName,
      sectionName
    }
  }) => sectionName === 'treasury' && ['approveProposal', 'rejectProposal'].includes(methodName));
  allIds.forEach((id, index) => {
    if (allProposals[index].isSome) {
      const council = councilTreasury.filter(({
        proposal
      }) => id.eq(proposal.args[0])).sort((a, b) => a.proposal.methodName.localeCompare(b.proposal.methodName));
      const isApproval = approvalIds.some(approvalId => approvalId.eq(id));
      const derived = {
        council,
        id,
        proposal: allProposals[index].unwrap()
      };

      if (isApproval) {
        approvals.push(derived);
      } else {
        proposals.push(derived);
      }
    }
  });
  return {
    approvals,
    proposalCount,
    proposals
  };
}

function retrieveProposals(api, proposalCount, approvalIds) {
  const proposalIds = [];
  const count = proposalCount.toNumber();

  for (let index = 0; index < count; index++) {
    const isApproval = approvalIds.some(id => id.eqn(index));

    if (!isApproval) {
      proposalIds.push(api.registry.createType('ProposalIndex', index));
    }
  }

  const allIds = [...proposalIds, ...approvalIds];
  return (0, _rxjs.combineLatest)([api.query.treasury.proposals.multi(allIds), api.derive.council.proposals()]).pipe((0, _operators.map)(([allProposals, councilProposals]) => parseResult(api, {
    allIds,
    allProposals,
    approvalIds,
    councilProposals,
    proposalCount
  })));
}
/**
 * @description Retrieve all active and approved treasury proposals, along with their info
 */


function proposals(instanceId, api) {
  return (0, _util.memo)(instanceId, () => api.query.treasury ? (0, _rxjs.combineLatest)([api.query.treasury.proposalCount(), api.query.treasury.approvals()]).pipe((0, _operators.switchMap)(([proposalCount, approvalIds]) => retrieveProposals(api, proposalCount, approvalIds))) : (0, _rxjs.of)({
    approvals: [],
    proposalCount: api.registry.createType('ProposalIndex'),
    proposals: []
  }));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/tx/constants.js":
/*!********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/tx/constants.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MORTAL_PERIOD = exports.MAX_FINALITY_LAG = exports.FALLBACK_PERIOD = exports.FALLBACK_MAX_HASH_COUNT = void 0;

var _bn = _interopRequireDefault(__webpack_require__(/*! bn.js */ "../../node_modules/bn.js/lib/bn.js"));

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
const FALLBACK_MAX_HASH_COUNT = 250; // default here to 5 min eras, adjusted based on the actual blocktime

exports.FALLBACK_MAX_HASH_COUNT = FALLBACK_MAX_HASH_COUNT;
const FALLBACK_PERIOD = new _bn.default(6 * 1000);
exports.FALLBACK_PERIOD = FALLBACK_PERIOD;
const MAX_FINALITY_LAG = new _bn.default(5);
exports.MAX_FINALITY_LAG = MAX_FINALITY_LAG;
const MORTAL_PERIOD = new _bn.default(5 * 60 * 1000);
exports.MORTAL_PERIOD = MORTAL_PERIOD;

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/tx/events.js":
/*!*****************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/tx/events.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.events = events;

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api-derive/util/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
function events(instanceId, api) {
  return (0, _util.memo)(instanceId, at => (0, _rxjs.combineLatest)([api.query.system.events.at(at), api.rpc.chain.getBlock(at)]).pipe((0, _operators.map)(([events, block]) => ({
    block,
    events
  }))));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/tx/index.js":
/*!****************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/tx/index.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _events = __webpack_require__(/*! ./events */ "../../node_modules/@polkadot/api-derive/tx/events.js");

Object.keys(_events).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _events[key];
    }
  });
});

var _signingInfo = __webpack_require__(/*! ./signingInfo */ "../../node_modules/@polkadot/api-derive/tx/signingInfo.js");

Object.keys(_signingInfo).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _signingInfo[key];
    }
  });
});

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/tx/signingInfo.js":
/*!**********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/tx/signingInfo.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.signingInfo = signingInfo;

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _constants = __webpack_require__(/*! ./constants */ "../../node_modules/@polkadot/api-derive/tx/constants.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
function latestNonce(api, address) {
  return api.derive.balances.account(address).pipe((0, _operators.map)(({
    accountNonce
  }) => accountNonce));
}

function nextNonce(api, address) {
  var _api$rpc$system;

  return ((_api$rpc$system = api.rpc.system) === null || _api$rpc$system === void 0 ? void 0 : _api$rpc$system.accountNextIndex) ? api.rpc.system.accountNextIndex(address) : latestNonce(api, address);
}

function signingHeader(api) {
  return (0, _rxjs.combineLatest)([api.rpc.chain.getHeader(), api.rpc.chain.getFinalizedHead().pipe((0, _operators.switchMap)(hash => api.rpc.chain.getHeader(hash)))]).pipe((0, _operators.map)(([current, finalized]) => // determine the hash to use, current when lag > max, else finalized
  current.number.unwrap().sub(finalized.number.unwrap()).gt(_constants.MAX_FINALITY_LAG) ? current : finalized));
}

function signingInfo(_instanceId, api) {
  // no memo, we want to do this fresh on each run
  return (address, nonce, era) => (0, _rxjs.combineLatest)([// retrieve nonce if none was specified
  (0, _util.isUndefined)(nonce) ? latestNonce(api, address) : nonce === -1 ? nextNonce(api, address) : (0, _rxjs.of)(api.registry.createType('Index', nonce)), // if no era (create) or era > 0 (mortal), do block retrieval
  (0, _util.isUndefined)(era) || (0, _util.isNumber)(era) && era > 0 ? signingHeader(api) : (0, _rxjs.of)(null)]).pipe((0, _operators.map)(([nonce, header]) => {
    var _api$consts$babe, _api$consts$timestamp;

    return {
      header,
      mortalLength: _constants.MORTAL_PERIOD.div(((_api$consts$babe = api.consts.babe) === null || _api$consts$babe === void 0 ? void 0 : _api$consts$babe.expectedBlockTime) || ((_api$consts$timestamp = api.consts.timestamp) === null || _api$consts$timestamp === void 0 ? void 0 : _api$consts$timestamp.minimumPeriod.muln(2)) || _constants.FALLBACK_PERIOD).iadd(_constants.MAX_FINALITY_LAG).toNumber(),
      nonce
    };
  }));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/type/HeaderExtended.js":
/*!***************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/type/HeaderExtended.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js"));

var _classPrivateFieldLooseBase2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classPrivateFieldLooseBase */ "../../node_modules/@babel/runtime/helpers/classPrivateFieldLooseBase.js"));

var _classPrivateFieldLooseKey2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classPrivateFieldLooseKey */ "../../node_modules/@babel/runtime/helpers/classPrivateFieldLooseKey.js"));

var _definitions = _interopRequireDefault(__webpack_require__(/*! @polkadot/types/interfaces/runtime/definitions */ "../../node_modules/@polkadot/types/interfaces/runtime/definitions.js"));

var _types = __webpack_require__(/*! @polkadot/types */ "../../node_modules/@polkadot/types/index.js");

var _util = __webpack_require__(/*! ./util */ "../../node_modules/@polkadot/api-derive/type/util.js");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// We can ignore the properties, added via Struct.with
const _Header = _types.Struct.with(_definitions.default.types.Header);
/**
 * @name HeaderExtended
 * @description
 * A [[Block]] header with an additional `author` field that indicates the block author
 */


var _author = (0, _classPrivateFieldLooseKey2.default)("author");

class HeaderExtended extends _Header {
  constructor(registry, header, sessionValidators) {
    super(registry, header);
    Object.defineProperty(this, _author, {
      writable: true,
      value: void 0
    });
    (0, _classPrivateFieldLooseBase2.default)(this, _author)[_author] = (0, _util.extractAuthor)(this.digest, sessionValidators);
  }
  /**
   * @description Convenience method, returns the author for the block
   */


  get author() {
    return (0, _classPrivateFieldLooseBase2.default)(this, _author)[_author];
  }
  /**
   * @description Creates a human-friendly JSON representation
   */


  toHuman(isExtended) {
    return _objectSpread(_objectSpread({}, super.toHuman(isExtended)), {}, {
      author: this.author ? this.author.toHuman() : undefined
    });
  }
  /**
   * @description Creates the JSON representation
   */


  toJSON() {
    return _objectSpread(_objectSpread({}, super.toJSON()), {}, {
      author: this.author ? this.author.toJSON() : undefined
    });
  }

}

exports.default = HeaderExtended;

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/type/SignedBlockExtended.js":
/*!********************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/type/SignedBlockExtended.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js"));

var _classPrivateFieldLooseBase2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classPrivateFieldLooseBase */ "../../node_modules/@babel/runtime/helpers/classPrivateFieldLooseBase.js"));

var _classPrivateFieldLooseKey2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classPrivateFieldLooseKey */ "../../node_modules/@babel/runtime/helpers/classPrivateFieldLooseKey.js"));

var _definitions = _interopRequireDefault(__webpack_require__(/*! @polkadot/types/interfaces/runtime/definitions */ "../../node_modules/@polkadot/types/interfaces/runtime/definitions.js"));

var _types = __webpack_require__(/*! @polkadot/types */ "../../node_modules/@polkadot/types/index.js");

var _util = __webpack_require__(/*! ./util */ "../../node_modules/@polkadot/api-derive/type/util.js");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// We can ignore the properties, added via Struct.with
const _SignedBlock = _types.Struct.with(_definitions.default.types.SignedBlock);
/**
 * @name SignedBlockExtended
 * @description
 * A [[Block]] header with an additional `author` field that indicates the block author
 */


var _author = (0, _classPrivateFieldLooseKey2.default)("author");

class BlockExtended extends _SignedBlock {
  constructor(registry, block, sessionValidators) {
    super(registry, block);
    Object.defineProperty(this, _author, {
      writable: true,
      value: void 0
    });
    (0, _classPrivateFieldLooseBase2.default)(this, _author)[_author] = (0, _util.extractAuthor)(this.block.header.digest, sessionValidators);
  }
  /**
   * @description Convenience method, returns the author for the block
   */


  get author() {
    return (0, _classPrivateFieldLooseBase2.default)(this, _author)[_author];
  }
  /**
   * @description Creates a human-friendly JSON representation
   */


  toHuman(isExtended) {
    return _objectSpread(_objectSpread({}, super.toHuman(isExtended)), {}, {
      author: this.author ? this.author.toHuman() : undefined
    });
  }
  /**
   * @description Creates the JSON representation
   */


  toJSON() {
    return _objectSpread(_objectSpread({}, super.toJSON()), {}, {
      author: this.author ? this.author.toJSON() : undefined
    });
  }

}

exports.default = BlockExtended;

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/type/index.js":
/*!******************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/type/index.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "HeaderExtended", {
  enumerable: true,
  get: function () {
    return _HeaderExtended.default;
  }
});
Object.defineProperty(exports, "SignedBlockExtended", {
  enumerable: true,
  get: function () {
    return _SignedBlockExtended.default;
  }
});

var _HeaderExtended = _interopRequireDefault(__webpack_require__(/*! ./HeaderExtended */ "../../node_modules/@polkadot/api-derive/type/HeaderExtended.js"));

var _SignedBlockExtended = _interopRequireDefault(__webpack_require__(/*! ./SignedBlockExtended */ "../../node_modules/@polkadot/api-derive/type/SignedBlockExtended.js"));

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/type/util.js":
/*!*****************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/type/util.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractAuthor = extractAuthor;

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
function extractAuthor(digest, sessionValidators = []) {
  const [pitem] = digest.logs.filter(({
    type
  }) => type === 'PreRuntime'); // extract from the substrate 2.0 PreRuntime digest

  if (pitem) {
    const [engine, data] = pitem.asPreRuntime;
    return engine.extractAuthor(data, sessionValidators);
  } else {
    const [citem] = digest.logs.filter(({
      type
    }) => type === 'Consensus'); // extract author from the consensus (substrate 1.0, digest)

    if (citem) {
      const [engine, data] = citem.asConsensus;
      return engine.extractAuthor(data, sessionValidators);
    }
  }

  return undefined;
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/util/approvalFlagsToBools.js":
/*!*********************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/util/approvalFlagsToBools.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.approvalFlagsToBools = approvalFlagsToBools;

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0

/** @internal */
function approvalFlagsToBools(flags) {
  const bools = [];
  flags.forEach(flag => {
    const str = flag.toString(2); // read from lowest bit to highest

    for (const bit of str.split('').reverse()) {
      bools.push(!!parseInt(bit, 10));
    }
  }); // slice off trailing "false" values, as in substrate

  const lastApproval = bools.lastIndexOf(true);
  return lastApproval >= 0 ? bools.slice(0, lastApproval + 1) : [];
}

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/util/cache.js":
/*!******************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/util/cache.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setDeriveCache = setDeriveCache;
exports.deriveCache = void 0;

var _cacheImpl = __webpack_require__(/*! ./cacheImpl */ "../../node_modules/@polkadot/api-derive/util/cacheImpl.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
const CHACHE_EXPIRY = 7 * (24 * 60) * (60 * 1000);
let deriveCache;
exports.deriveCache = deriveCache;

function wrapCache(keyStart, cache) {
  return {
    del: partial => cache.del(`${keyStart}${partial}`),
    forEach: cache.forEach,
    get: partial => {
      const key = `${keyStart}${partial}`;
      const cached = cache.get(key);

      if (cached) {
        cached.x = Date.now();
        cache.set(key, cached);
        return cached.v;
      }

      return undefined;
    },
    set: (partial, v) => {
      cache.set(`${keyStart}${partial}`, {
        v,
        x: Date.now()
      });
    }
  };
}

function clearCache(cache) {
  // clear all expired values
  const now = Date.now();
  const all = [];
  cache.forEach((key, {
    x
  }) => {
    now - x > CHACHE_EXPIRY && all.push(key);
  }); // don't do delete inside loop, just in-case

  all.forEach(key => cache.del(key));
}

function setDeriveCache(prefix = '', cache) {
  exports.deriveCache = deriveCache = cache ? wrapCache(`derive:${prefix}:`, cache) : _cacheImpl.deriveNoopCache;

  if (cache) {
    clearCache(cache);
  }
}

setDeriveCache();

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/util/cacheImpl.js":
/*!**********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/util/cacheImpl.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deriveNoopCache = exports.deriveMapCache = void 0;
// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
const mapCache = new Map();
const deriveMapCache = {
  del: key => {
    mapCache.delete(key);
  },
  forEach: cb => {
    const entries = mapCache.entries();

    for (const entry in entries) {
      cb(entry[0], entry[1]);
    }
  },
  get: key => {
    return mapCache.get(key);
  },
  set: (key, value) => {
    mapCache.set(key, value);
  }
};
exports.deriveMapCache = deriveMapCache;
const deriveNoopCache = {
  del: () => undefined,
  forEach: () => undefined,
  get: () => undefined,
  set: (_, value) => value
};
exports.deriveNoopCache = deriveNoopCache;

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/util/index.js":
/*!******************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/util/index.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  drr: true
};
Object.defineProperty(exports, "drr", {
  enumerable: true,
  get: function () {
    return _rxjs.drr;
  }
});

var _rxjs = __webpack_require__(/*! @polkadot/rpc-core/rxjs */ "../../node_modules/@polkadot/rpc-core/rxjs/index.js");

var _approvalFlagsToBools = __webpack_require__(/*! ./approvalFlagsToBools */ "../../node_modules/@polkadot/api-derive/util/approvalFlagsToBools.js");

Object.keys(_approvalFlagsToBools).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _approvalFlagsToBools[key];
    }
  });
});

var _cache = __webpack_require__(/*! ./cache */ "../../node_modules/@polkadot/api-derive/util/cache.js");

Object.keys(_cache).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _cache[key];
    }
  });
});

var _cacheImpl = __webpack_require__(/*! ./cacheImpl */ "../../node_modules/@polkadot/api-derive/util/cacheImpl.js");

Object.keys(_cacheImpl).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _cacheImpl[key];
    }
  });
});

var _memo = __webpack_require__(/*! ./memo */ "../../node_modules/@polkadot/api-derive/util/memo.js");

Object.keys(_memo).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _memo[key];
    }
  });
});

/***/ }),

/***/ "../../node_modules/@polkadot/api-derive/util/memo.js":
/*!*****************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api-derive/util/memo.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.memo = memo;

var _memoizee = _interopRequireDefault(__webpack_require__(/*! memoizee */ "../../node_modules/memoizee/index.js"));

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _rxjs2 = __webpack_require__(/*! @polkadot/rpc-core/rxjs */ "../../node_modules/@polkadot/rpc-core/rxjs/index.js");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Wraps a derive, doing 2 things to optimize calls -
//   1. creates a memo of the inner fn -> Observable, removing when unsubscribed
//   2. wraps the observable in a drr() (which includes an unsub delay)

/** @internal */
function memo(instanceId, inner) {
  const cached = (0, _memoizee.default)((...params) => new _rxjs.Observable(observer => {
    const subscription = inner(...params).subscribe(observer);
    return () => {
      cached.delete(...params);
      subscription.unsubscribe();
    };
  }).pipe((0, _rxjs2.drr)()), {
    // Normalize via JSON.stringify, allow e.g. AccountId -> ss58
    // eslint-disable-next-line @typescript-eslint/unbound-method
    normalizer: args => instanceId + JSON.stringify(args)
  });
  return cached;
}

/***/ }),

/***/ "../../node_modules/@polkadot/api/base/Decorate.js":
/*!**************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api/base/Decorate.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classPrivateFieldLooseBase2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classPrivateFieldLooseBase */ "../../node_modules/@babel/runtime/helpers/classPrivateFieldLooseBase.js"));

var _classPrivateFieldLooseKey2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classPrivateFieldLooseKey */ "../../node_modules/@babel/runtime/helpers/classPrivateFieldLooseKey.js"));

var _bn = _interopRequireDefault(__webpack_require__(/*! bn.js */ "../../node_modules/bn.js/lib/bn.js"));

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _apiDerive = _interopRequireDefault(__webpack_require__(/*! @polkadot/api-derive */ "../../node_modules/@polkadot/api-derive/index.js"));

var _util = __webpack_require__(/*! @polkadot/api-derive/util */ "../../node_modules/@polkadot/api-derive/util/index.js");

var _Decorated = _interopRequireDefault(__webpack_require__(/*! @polkadot/metadata/Decorated */ "../../node_modules/@polkadot/metadata/Decorated/index.js"));

var _rpcCore = _interopRequireDefault(__webpack_require__(/*! @polkadot/rpc-core */ "../../node_modules/@polkadot/rpc-core/index.js"));

var _rpcProvider = __webpack_require__(/*! @polkadot/rpc-provider */ "../../node_modules/@polkadot/rpc-provider/index.js");

var _types = __webpack_require__(/*! @polkadot/types */ "../../node_modules/@polkadot/types/index.js");

var _constants = __webpack_require__(/*! @polkadot/types/extrinsic/constants */ "../../node_modules/@polkadot/types/extrinsic/constants.js");

var _StorageKey = __webpack_require__(/*! @polkadot/types/primitive/StorageKey */ "../../node_modules/@polkadot/types/primitive/StorageKey.js");

var _util2 = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _submittable = __webpack_require__(/*! ../submittable */ "../../node_modules/@polkadot/api/submittable/index.js");

var _augmentObject = _interopRequireDefault(__webpack_require__(/*! ../util/augmentObject */ "../../node_modules/@polkadot/api/util/augmentObject.js"));

var _decorate = __webpack_require__(/*! ../util/decorate */ "../../node_modules/@polkadot/api/util/decorate.js");

var _validate = __webpack_require__(/*! ../util/validate */ "../../node_modules/@polkadot/api/util/validate.js");

var _Events = _interopRequireDefault(__webpack_require__(/*! ./Events */ "../../node_modules/@polkadot/api/base/Events.js"));

// Copyright 2017-2020 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0
const PAGE_SIZE_KEYS = 256;
const PAGE_SIZE_VALS = PAGE_SIZE_KEYS;
const l = (0, _util2.logger)('api/init');
let instanceCounter = 0;

var _instanceId = (0, _classPrivateFieldLooseKey2.default)("instanceId");

var _registry = (0, _classPrivateFieldLooseKey2.default)("registry");

class Decorate extends _Events.default {
  // HACK Use BN import so decorateDerive works... yes, wtf.

  /**
   * This is the one and only method concrete children classes need to implement.
   * It's a higher-order function, which takes one argument
   * `method: Method extends (...args: any[]) => Observable<any>`
   * (and one optional `options`), and should return the user facing method.
   * For example:
   * - For ApiRx, `decorateMethod` should just be identity, because the input
   * function is already an Observable
   * - For ApiPromise, `decorateMethod` should return a function that takes all
   * the parameters from `method`, adds an optional `callback` argument, and
   * returns a Promise.
   *
   * We could easily imagine other user-facing interfaces, which are simply
   * implemented by transforming the Observable to Stream/Iterator/Kefir/Bacon
   * via `decorateMethod`.
   */

  /**
   * @description Create an instance of the class
   *
   * @param options Options object to create API instance or a Provider instance
   *
   * @example
   * <BR>
   *
   * ```javascript
   * import Api from '@polkadot/api/promise';
   *
   * const api = new Api().isReady();
   *
   * api.rpc.subscribeNewHeads((header) => {
   *   console.log(`new block #${header.number.toNumber()}`);
   * });
   * ```
   */
  constructor(options, type, decorateMethod) {
    var _options$source;

    super();
    Object.defineProperty(this, _instanceId, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _registry, {
      writable: true,
      value: void 0
    });
    this.__phantom = new _bn.default(0);
    this._consts = {};
    this._derive = void 0;
    this._extrinsics = void 0;
    this._extrinsicType = _constants.DEFAULT_VERSION;
    this._genesisHash = void 0;
    this._isConnected = void 0;
    this._isReady = false;
    this._options = void 0;
    this._query = {};
    this._queryMulti = void 0;
    this._rpc = void 0;
    this._rpcCore = void 0;
    this._runtimeChain = void 0;
    this._runtimeMetadata = void 0;
    this._runtimeVersion = void 0;
    this._rx = {
      consts: {},
      query: {},
      tx: {}
    };
    this._type = void 0;
    this._decorateMethod = void 0;

    this._rxDecorateMethod = method => {
      return method;
    };

    (0, _classPrivateFieldLooseBase2.default)(this, _instanceId)[_instanceId] = `${++instanceCounter}`;
    (0, _classPrivateFieldLooseBase2.default)(this, _registry)[_registry] = ((_options$source = options.source) === null || _options$source === void 0 ? void 0 : _options$source.registry) || options.registry || new _types.TypeRegistry();
    const thisProvider = options.source ? options.source._rpcCore.provider.clone() : options.provider || new _rpcProvider.WsProvider();
    this._decorateMethod = decorateMethod;
    this._options = options;
    this._type = type;
    this._rpcCore = new _rpcCore.default((0, _classPrivateFieldLooseBase2.default)(this, _instanceId)[_instanceId], (0, _classPrivateFieldLooseBase2.default)(this, _registry)[_registry], thisProvider, this._options.rpc);
    this._isConnected = new _rxjs.BehaviorSubject(this._rpcCore.provider.isConnected);
    this._rx.hasSubscriptions = this._rpcCore.provider.hasSubscriptions;
    this._rx.registry = (0, _classPrivateFieldLooseBase2.default)(this, _registry)[_registry];
  }
  /**
   * @description Return the current used registry
   */


  get registry() {
    return (0, _classPrivateFieldLooseBase2.default)(this, _registry)[_registry];
  }
  /**
   * @description Creates an instance of a type as registered
   */


  createType(type, ...params) {
    return (0, _classPrivateFieldLooseBase2.default)(this, _registry)[_registry].createType(type, ...params);
  }
  /**
   * @description Register additional user-defined of chain-specific types in the type registry
   */


  registerTypes(types) {
    types && (0, _classPrivateFieldLooseBase2.default)(this, _registry)[_registry].register(types);
  }
  /**
   * @returns `true` if the API operates with subscriptions
   */


  get hasSubscriptions() {
    return this._rpcCore.provider.hasSubscriptions;
  }

  injectMetadata(metadata, fromEmpty, registry) {
    const decoratedMeta = new _Decorated.default(registry || (0, _classPrivateFieldLooseBase2.default)(this, _registry)[_registry], metadata);

    if (fromEmpty || !this._extrinsics) {
      this._extrinsics = this._decorateExtrinsics(decoratedMeta.tx, this._decorateMethod);
      this._rx.tx = this._decorateExtrinsics(decoratedMeta.tx, this._rxDecorateMethod);
    } else {
      (0, _augmentObject.default)('tx', this._decorateExtrinsics(decoratedMeta.tx, this._decorateMethod), this._extrinsics, false);
      (0, _augmentObject.default)(null, this._decorateExtrinsics(decoratedMeta.tx, this._rxDecorateMethod), this._rx.tx, false);
    } // this API


    (0, _augmentObject.default)('query', this._decorateStorage(decoratedMeta.query, this._decorateMethod), this._query, fromEmpty);
    (0, _augmentObject.default)('consts', decoratedMeta.consts, this._consts, fromEmpty); // rx

    (0, _augmentObject.default)(null, this._decorateStorage(decoratedMeta.query, this._rxDecorateMethod), this._rx.query, fromEmpty);
    (0, _augmentObject.default)(null, decoratedMeta.consts, this._rx.consts, fromEmpty);
  }

  _decorateFunctionMeta(input, output) {
    output.meta = input.meta;
    output.method = input.method;
    output.section = input.section;
    output.toJSON = input.toJSON;

    if (input.callIndex) {
      output.callIndex = input.callIndex;
    }

    return output;
  } // Filter all RPC methods based on the results of the rpc_methods call. We do this in the following
  // manner to cater for both old and new:
  //   - when the number of entries are 0, only remove the ones with isOptional (account & contracts)
  //   - when non-zero, remove anything that is not in the array (we don't do this)


  async _filterRpc() {
    let methods;

    try {
      // we ignore the version (adjust as versions change, for now only "1")
      methods = (await this._rpcCore.rpc.methods().toPromise()).methods.map(t => t.toString());
    } catch (error) {
      // the method is not there, we adjust accordingly
      methods = [];
    }

    this._filterRpcMethods(methods);
  }

  _filterRpcMethods(exposed) {
    const hasResults = exposed.length !== 0;
    const allKnown = [...this._rpcCore.mapping.entries()];
    const allKeys = allKnown.reduce((allKeys, [, {
      alias,
      method,
      pubsub,
      section
    }]) => {
      allKeys.push(`${section}_${method}`);

      if (pubsub) {
        allKeys.push(`${section}_${pubsub[1]}`);
        allKeys.push(`${section}_${pubsub[2]}`);
      }

      if (alias) {
        allKeys.push(...alias);
      }

      return allKeys;
    }, []);
    const unknown = exposed.filter(key => !allKeys.includes(key));

    if (unknown.length) {
      l.warn(`RPC methods not decorated: ${unknown.join(', ')}`);
    } // loop through all entries we have (populated in decorate) and filter as required
    // only remove when we have results and method missing, or with no results if optional


    allKnown.filter(([key]) => hasResults ? !exposed.includes(key) && key !== 'rpc_methods' // rpc_methods doesn't appear, v1
    : key === 'rpc_methods' // we didn't find this one, remove
    ) // eslint-disable-next-line @typescript-eslint/no-unused-vars
    .forEach(([_, {
      method,
      section
    }]) => {
      delete this._rpc[section][method];
      delete this._rpcCore[section][method];
      delete this._rx.rpc[section][method];
    });
  }

  _decorateRpc(rpc, decorateMethod) {
    return rpc.sections.reduce((out, _sectionName) => {
      const sectionName = _sectionName; // out and section here are horrors to get right from a typing perspective :(

      out[sectionName] = Object.entries(rpc[sectionName]).reduce((section, [methodName, method]) => {
        //  skip subscriptions where we have a non-subscribe interface
        if (this.hasSubscriptions || !(methodName.startsWith('subscribe') || methodName.startsWith('unsubscribe'))) {
          section[methodName] = decorateMethod(method, {
            methodName
          }); // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access

          section[methodName].raw = decorateMethod(method.raw, {
            methodName
          });
        }

        return section;
      }, {});
      return out;
    }, {});
  }

  _decorateMulti(decorateMethod) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return decorateMethod(calls => this._rpcCore.state.subscribeStorage(calls.map(arg => // the input is a QueryableStorageEntry, convert to StorageEntry
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    Array.isArray(arg) ? [arg[0].creator, ...arg.slice(1)] : [arg.creator])));
  }

  _decorateExtrinsics(extrinsics, decorateMethod) {
    const creator = (0, _submittable.createSubmittable)(this._type, this._rx, decorateMethod);
    return Object.entries(extrinsics).reduce((out, [name, section]) => {
      out[name] = Object.entries(section).reduce((out, [name, method]) => {
        out[name] = this._decorateExtrinsicEntry(method, creator);
        return out;
      }, {});
      return out;
    }, creator);
  }

  _decorateExtrinsicEntry(method, creator) {
    const decorated = (...params) => creator(method(...params)); // eslint-disable-next-line @typescript-eslint/no-unsafe-return


    return this._decorateFunctionMeta(method, decorated);
  }

  _decorateStorage(storage, decorateMethod) {
    return Object.entries(storage).reduce((out, [name, section]) => {
      out[name] = Object.entries(section).reduce((out, [name, method]) => {
        out[name] = this._decorateStorageEntry(method, decorateMethod);
        return out;
      }, {});
      return out;
    }, {});
  }

  _decorateStorageEntry(creator, decorateMethod) {
    // get the storage arguments, with DoubleMap as an array entry, otherwise spread
    const getArgs = (...args) => (0, _validate.extractStorageArgs)(creator, args); // Disable this where it occurs for each field we are decorating

    /* eslint-disable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */


    const decorated = this._decorateStorageCall(creator, decorateMethod);

    decorated.creator = creator;
    decorated.at = decorateMethod((hash, arg1, arg2) => this._rpcCore.state.getStorage(getArgs(arg1, arg2), hash));
    decorated.hash = decorateMethod((arg1, arg2) => this._rpcCore.state.getStorageHash(getArgs(arg1, arg2)));

    decorated.key = (arg1, arg2) => (0, _util2.u8aToHex)((0, _util2.compactStripLength)(creator(creator.meta.type.isDoubleMap ? [arg1, arg2] : arg1))[1]);

    decorated.keyPrefix = key1 => (0, _util2.u8aToHex)(creator.keyPrefix(key1));

    decorated.range = decorateMethod((range, arg1, arg2) => this._decorateStorageRange(decorated, [arg1, arg2], range));
    decorated.size = decorateMethod((arg1, arg2) => this._rpcCore.state.getStorageSize(getArgs(arg1, arg2))); // .keys() & .entries() only available on map types

    if (creator.iterKey && (creator.meta.type.isMap || creator.meta.type.isDoubleMap)) {
      decorated.entries = decorateMethod((0, _util.memo)((0, _classPrivateFieldLooseBase2.default)(this, _instanceId)[_instanceId], doubleMapArg => this._retrieveMapEntries(creator, doubleMapArg)));
      decorated.entriesPaged = decorateMethod((0, _util.memo)((0, _classPrivateFieldLooseBase2.default)(this, _instanceId)[_instanceId], opts => this._retrieveMapEntriesPaged(creator, opts)));
      decorated.keys = decorateMethod((0, _util.memo)((0, _classPrivateFieldLooseBase2.default)(this, _instanceId)[_instanceId], doubleMapArg => this._retrieveMapKeys(creator, doubleMapArg)));
      decorated.keysPaged = decorateMethod((0, _util.memo)((0, _classPrivateFieldLooseBase2.default)(this, _instanceId)[_instanceId], opts => this._retrieveMapKeysPaged(creator, opts)));
    } // only support multi where subs are available


    if (this.hasSubscriptions) {
      // When using double map storage function, user need to pass double map key as an array
      decorated.multi = decorateMethod(args => this._rpcCore.state.subscribeStorage(args.map(arg => [creator, arg])));
    }
    /* eslint-enable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */


    return this._decorateFunctionMeta(creator, decorated);
  } // Decorate the base storage call. In the case or rxjs or promise-without-callback (await)
  // we make a subscription, alternatively we push this through a single-shot query


  _decorateStorageCall(creator, decorateMethod) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return decorateMethod((...args) => {
      return this.hasSubscriptions ? this._rpcCore.state.subscribeStorage([(0, _validate.extractStorageArgs)(creator, args)]).pipe((0, _operators.map)(([data]) => data) // extract first/only result from list
      ) : this._rpcCore.state.getStorage((0, _validate.extractStorageArgs)(creator, args));
    }, {
      methodName: creator.method,
      overrideNoSub: (...args) => this._rpcCore.state.getStorage((0, _validate.extractStorageArgs)(creator, args))
    });
  }

  _decorateStorageRange(decorated, args, range) {
    const outputType = (0, _StorageKey.unwrapStorageType)(decorated.creator.meta.type, decorated.creator.meta.modifier.isOptional);
    return this._rpcCore.state.queryStorage([decorated.key(...args)], ...range).pipe((0, _operators.map)(result => result.map(([blockHash, [value]]) => [blockHash, this.createType(outputType, value.isSome ? value.unwrap().toHex() : undefined)])));
  }

  _retrieveMapKeys({
    iterKey,
    meta
  }, arg) {
    (0, _util2.assert)(iterKey && (meta.type.isMap || meta.type.isDoubleMap), 'keys can only be retrieved on maps, linked maps and double maps');
    const headKey = iterKey(arg).toHex();
    const startSubject = new _rxjs.BehaviorSubject(headKey);
    return startSubject.pipe((0, _operators.switchMap)(startKey => this._rpcCore.state.getKeysPaged(headKey, PAGE_SIZE_KEYS, startKey).pipe((0, _operators.map)(keys => keys.map(key => key.setMeta(meta))))), (0, _operators.tap)(keys => {
      keys.length === PAGE_SIZE_KEYS ? startSubject.next(keys[PAGE_SIZE_KEYS - 1].toHex()) : startSubject.complete();
    }), (0, _operators.toArray)(), // toArray since we want to startSubject to be completed
    (0, _operators.map)(keysArr => keysArr.reduce((result, keys) => result.concat(keys), [])));
  }

  _retrieveMapKeysPaged({
    iterKey,
    meta
  }, opts) {
    (0, _util2.assert)(iterKey && (meta.type.isMap || meta.type.isDoubleMap), 'keys can only be retrieved on maps, linked maps and double maps');
    const headKey = iterKey(opts.arg).toHex();
    return this._rpcCore.state.getKeysPaged(headKey, opts.pageSize, opts.startKey || headKey).pipe((0, _operators.map)(keys => keys.map(key => key.setMeta(meta))));
  }

  _retrieveMapEntries(entry, arg) {
    return this._retrieveMapKeys(entry, arg).pipe((0, _operators.switchMap)(keys => (0, _rxjs.combineLatest)([(0, _rxjs.of)(keys), ...Array(Math.ceil(keys.length / PAGE_SIZE_VALS)).fill(0).map((_, index) => {
      const keyset = keys.slice(index * PAGE_SIZE_VALS, index * PAGE_SIZE_VALS + PAGE_SIZE_VALS);
      return this._rpcCore.state.queryStorageAt ? this._rpcCore.state.queryStorageAt(keyset) // this is horrible, but need older support
      : this._rpcCore.state.subscribeStorage(keyset).pipe((0, _operators.take)(1));
    })])), (0, _operators.map)(([keys, ...valsArr]) => valsArr.reduce((result, vals) => result.concat(vals), []).map((value, index) => [keys[index], value])));
  }

  _retrieveMapEntriesPaged(entry, opts) {
    return this._retrieveMapKeysPaged(entry, opts).pipe((0, _operators.switchMap)(keys => (0, _rxjs.combineLatest)([(0, _rxjs.of)(keys), this._rpcCore.state.queryStorageAt(keys)])), (0, _operators.map)(([keys, ...valsArr]) => valsArr.reduce((result, vals) => result.concat(vals), []).map((value, index) => [keys[index], value])));
  }

  _decorateDeriveRx(decorateMethod) {
    // Pull in derive from api-derive
    const derive = (0, _apiDerive.default)((0, _classPrivateFieldLooseBase2.default)(this, _instanceId)[_instanceId], this._rx, this._options.derives);
    return (0, _decorate.decorateSections)(derive, decorateMethod);
  }

  _decorateDerive(decorateMethod) {
    return (0, _decorate.decorateSections)(this._rx.derive, decorateMethod);
  }
  /**
   * Put the `this.onCall` function of ApiRx here, because it is needed by
   * `api._rx`.
   */


}

exports.default = Decorate;

/***/ }),

/***/ "../../node_modules/@polkadot/api/base/Events.js":
/*!************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api/base/Events.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classPrivateFieldLooseBase2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classPrivateFieldLooseBase */ "../../node_modules/@babel/runtime/helpers/classPrivateFieldLooseBase.js"));

var _classPrivateFieldLooseKey2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classPrivateFieldLooseKey */ "../../node_modules/@babel/runtime/helpers/classPrivateFieldLooseKey.js"));

var _eventemitter2 = _interopRequireDefault(__webpack_require__(/*! eventemitter3 */ "../../node_modules/eventemitter3/index.js"));

// Copyright 2017-2020 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _eventemitter = (0, _classPrivateFieldLooseKey2.default)("eventemitter");

class Events {
  constructor() {
    Object.defineProperty(this, _eventemitter, {
      writable: true,
      value: new _eventemitter2.default()
    });
  }

  emit(type, ...args) {
    return (0, _classPrivateFieldLooseBase2.default)(this, _eventemitter)[_eventemitter].emit(type, ...args);
  }
  /**
   * @description Attach an eventemitter handler to listen to a specific event
   *
   * @param type The type of event to listen to. Available events are `connected`, `disconnected`, `ready` and `error`
   * @param handler The callback to be called when the event fires. Depending on the event type, it could fire with additional arguments.
   *
   * @example
   * <BR>
   *
   * ```javascript
   * api.on('connected', (): void => {
   *   console.log('API has been connected to the endpoint');
   * });
   *
   * api.on('disconnected', (): void => {
   *   console.log('API has been disconnected from the endpoint');
   * });
   * ```
   */


  on(type, handler) {
    (0, _classPrivateFieldLooseBase2.default)(this, _eventemitter)[_eventemitter].on(type, handler);

    return this;
  }
  /**
   * @description Remove the given eventemitter handler
   *
   * @param type The type of event the callback was attached to. Available events are `connected`, `disconnected`, `ready` and `error`
   * @param handler The callback to unregister.
   *
   * @example
   * <BR>
   *
   * ```javascript
   * const handler = (): void => {
   *  console.log('Connected !);
   * };
   *
   * // Start listening
   * api.on('connected', handler);
   *
   * // Stop listening
   * api.off('connected', handler);
   * ```
   */


  off(type, handler) {
    (0, _classPrivateFieldLooseBase2.default)(this, _eventemitter)[_eventemitter].removeListener(type, handler);

    return this;
  }
  /**
   * @description Attach an one-time eventemitter handler to listen to a specific event
   *
   * @param type The type of event to listen to. Available events are `connected`, `disconnected`, `ready` and `error`
   * @param handler The callback to be called when the event fires. Depending on the event type, it could fire with additional arguments.
   *
   * @example
   * <BR>
   *
   * ```javascript
   * api.once('connected', (): void => {
   *   console.log('API has been connected to the endpoint');
   * });
   *
   * api.once('disconnected', (): void => {
   *   console.log('API has been disconnected from the endpoint');
   * });
   * ```
   */


  once(type, handler) {
    (0, _classPrivateFieldLooseBase2.default)(this, _eventemitter)[_eventemitter].once(type, handler);

    return this;
  }

}

exports.default = Events;

/***/ }),

/***/ "../../node_modules/@polkadot/api/base/Init.js":
/*!**********************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api/base/Init.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classPrivateFieldLooseBase2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classPrivateFieldLooseBase */ "../../node_modules/@babel/runtime/helpers/classPrivateFieldLooseBase.js"));

var _classPrivateFieldLooseKey2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classPrivateFieldLooseKey */ "../../node_modules/@babel/runtime/helpers/classPrivateFieldLooseKey.js"));

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _types = __webpack_require__(/*! @polkadot/types */ "../../node_modules/@polkadot/types/index.js");

var _Extrinsic = __webpack_require__(/*! @polkadot/types/extrinsic/Extrinsic */ "../../node_modules/@polkadot/types/extrinsic/Extrinsic.js");

var _typesKnown = __webpack_require__(/*! @polkadot/types-known */ "../../node_modules/@polkadot/types-known/index.js");

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _utilCrypto = __webpack_require__(/*! @polkadot/util-crypto */ "../../node_modules/@polkadot/util-crypto/index.js");

var _Decorate = _interopRequireDefault(__webpack_require__(/*! ./Decorate */ "../../node_modules/@polkadot/api/base/Decorate.js"));

// Copyright 2017-2020 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0
const KEEPALIVE_INTERVAL = 15000;
const DEFAULT_BLOCKNUMBER = {
  unwrap: () => _util.BN_ZERO
};
const l = (0, _util.logger)('api/init');

var _healthTimer = (0, _classPrivateFieldLooseKey2.default)("healthTimer");

var _registries = (0, _classPrivateFieldLooseKey2.default)("registries");

var _updateSub = (0, _classPrivateFieldLooseKey2.default)("updateSub");

var _onProviderConnect = (0, _classPrivateFieldLooseKey2.default)("onProviderConnect");

var _onProviderDisconnect = (0, _classPrivateFieldLooseKey2.default)("onProviderDisconnect");

var _onProviderError = (0, _classPrivateFieldLooseKey2.default)("onProviderError");

class Init extends _Decorate.default {
  constructor(options, type, decorateMethod) {
    super(options, type, decorateMethod);
    Object.defineProperty(this, _healthTimer, {
      writable: true,
      value: null
    });
    Object.defineProperty(this, _registries, {
      writable: true,
      value: []
    });
    Object.defineProperty(this, _updateSub, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _onProviderConnect, {
      writable: true,
      value: async () => {
        this.emit('connected');

        this._isConnected.next(true);

        try {
          const [hasMeta, cryptoReady] = await Promise.all([this._loadMeta(), this._options.initWasm === false ? Promise.resolve(true) : (0, _utilCrypto.cryptoWaitReady)()]);

          if (hasMeta && !this._isReady && cryptoReady) {
            this._isReady = true;
            this.emit('ready', this);
          }

          (0, _classPrivateFieldLooseBase2.default)(this, _healthTimer)[_healthTimer] = setInterval(() => {
            this._rpcCore.system.health().toPromise().catch(() => {// ignore
            });
          }, KEEPALIVE_INTERVAL);
        } catch (_error) {
          const error = new Error(`FATAL: Unable to initialize the API: ${_error.message}`);
          l.error(error);
          this.emit('error', error);
        }
      }
    });
    Object.defineProperty(this, _onProviderDisconnect, {
      writable: true,
      value: () => {
        this.emit('disconnected');

        this._isConnected.next(false);

        if ((0, _classPrivateFieldLooseBase2.default)(this, _healthTimer)[_healthTimer]) {
          clearInterval((0, _classPrivateFieldLooseBase2.default)(this, _healthTimer)[_healthTimer]);
          (0, _classPrivateFieldLooseBase2.default)(this, _healthTimer)[_healthTimer] = null;
        }
      }
    });
    Object.defineProperty(this, _onProviderError, {
      writable: true,
      value: error => {
        this.emit('error', error);
      }
    });

    if (!this.hasSubscriptions) {
      l.warn('Api will be available in a limited mode since the provider does not support subscriptions');
    } // all injected types added to the registry for overrides


    this.registry.setKnownTypes(options); // We only register the types (global) if this is not a cloned instance.
    // Do right up-front, so we get in the user types before we are actually
    // doing anything on-chain, this ensures we have the overrides in-place

    if (!options.source) {
      this.registerTypes(options.types);
    } else {
      (0, _classPrivateFieldLooseBase2.default)(this, _registries)[_registries] = (0, _classPrivateFieldLooseBase2.default)(options.source, _registries)[_registries];
    }

    this._rpc = this._decorateRpc(this._rpcCore, this._decorateMethod);
    this._rx.rpc = this._decorateRpc(this._rpcCore, this._rxDecorateMethod);
    this._queryMulti = this._decorateMulti(this._decorateMethod);
    this._rx.queryMulti = this._decorateMulti(this._rxDecorateMethod);
    this._rx.signer = options.signer;

    this._rpcCore.setRegistrySwap(hash => this.getBlockRegistry(hash));

    this._rpcCore.provider.on('disconnected', (0, _classPrivateFieldLooseBase2.default)(this, _onProviderDisconnect)[_onProviderDisconnect]);

    this._rpcCore.provider.on('error', (0, _classPrivateFieldLooseBase2.default)(this, _onProviderError)[_onProviderError]);

    this._rpcCore.provider.on('connected', (0, _classPrivateFieldLooseBase2.default)(this, _onProviderConnect)[_onProviderConnect]); // If the provider was instantiated earlier, and has already emitted a
    // 'connected' event, then the `on('connected')` won't fire anymore. To
    // cater for this case, we call manually `this._onProviderConnect`.


    if (this._rpcCore.provider.isConnected) {
      // eslint-disable-next-line @typescript-eslint/no-floating-promises
      (0, _classPrivateFieldLooseBase2.default)(this, _onProviderConnect)[_onProviderConnect]();
    }
  }
  /**
   * @description Decorates a registry based on the runtime version
   */


  _initRegistry(registry, chain, version, chainProps) {
    registry.setChainProperties(chainProps || this.registry.getChainProperties());
    registry.setKnownTypes(this._options);
    registry.register((0, _typesKnown.getSpecTypes)(registry, chain, version.specName, version.specVersion)); // for bundled types, pull through the aliasses defined

    if (registry.knownTypes.typesBundle) {
      registry.knownTypes.typesAlias = (0, _typesKnown.getSpecAlias)(registry, chain, version.specName);
    }

    return registry;
  }
  /**
   * @description Sets up a registry based on the block hash defined
   */


  async getBlockRegistry(blockHash) {
    // shortcut in the case where we have an immediate-same request
    const lastBlockHash = (0, _util.u8aToU8a)(blockHash);

    const existingViaHash = (0, _classPrivateFieldLooseBase2.default)(this, _registries)[_registries].find(r => r.lastBlockHash && (0, _util.u8aEq)(lastBlockHash, r.lastBlockHash));

    if (existingViaHash) {
      return existingViaHash;
    } // ensure we have everything required


    (0, _util.assert)(this._genesisHash && this._runtimeVersion, 'Cannot retrieve data on an uninitialized chain'); // We have to assume that on the RPC layer the calls used here does not call back into
    // the registry swap, so getHeader & getRuntimeVersion should not be historic

    const header = this._genesisHash.eq(blockHash) ? {
      number: DEFAULT_BLOCKNUMBER,
      parentHash: this._genesisHash
    } : await this._rpcCore.chain.getHeader(blockHash).toPromise();
    (0, _util.assert)((header === null || header === void 0 ? void 0 : header.parentHash) && !header.parentHash.isEmpty, 'Unable to retrieve header and parent from supplied hash'); // get the runtime version, either on-chain or via an known upgrade history

    const [firstVersion, lastVersion] = (0, _typesKnown.getUpgradeVersion)(this._genesisHash, header.number.unwrap());
    const version = firstVersion && (lastVersion || firstVersion.specVersion.eq(this._runtimeVersion.specVersion)) ? {
      specName: this._runtimeVersion.specName,
      specVersion: firstVersion.specVersion
    } : await this._rpcCore.state.getRuntimeVersion(header.parentHash).toPromise(); // check for pre-existing registries

    const existingViaVersion = (0, _classPrivateFieldLooseBase2.default)(this, _registries)[_registries].find(r => r.specVersion.eq(version.specVersion));

    if (existingViaVersion) {
      existingViaVersion.lastBlockHash = lastBlockHash;
      return existingViaVersion;
    } // nothing has been found, construct new


    const registry = this._initRegistry(new _types.TypeRegistry(), this._runtimeChain, version);

    const metadata = await this._rpcCore.state.getMetadata(header.parentHash).toPromise();
    const result = {
      isDefault: false,
      lastBlockHash,
      metadata,
      metadataConsts: null,
      registry,
      specVersion: version.specVersion
    };
    registry.setMetadata(metadata);

    (0, _classPrivateFieldLooseBase2.default)(this, _registries)[_registries].push(result);

    return result;
  }

  async _loadMeta() {
    var _this$_options$source;

    const genesisHash = await this._rpcCore.chain.getBlockHash(0).toPromise(); // on re-connection to the same chain, we don't want to re-do everything from chain again

    if (this._isReady && !this._options.source && genesisHash.eq(this._genesisHash)) {
      return true;
    }

    if (this._genesisHash) {
      l.warn('Connection to new genesis detected, re-initializing');
    }

    this._genesisHash = genesisHash;

    if ((0, _classPrivateFieldLooseBase2.default)(this, _updateSub)[_updateSub]) {
      (0, _classPrivateFieldLooseBase2.default)(this, _updateSub)[_updateSub].unsubscribe();
    }

    const {
      metadata = {}
    } = this._options; // only load from on-chain if we are not a clone (default path), alternatively
    // just use the values from the source instance provided

    this._runtimeMetadata = ((_this$_options$source = this._options.source) === null || _this$_options$source === void 0 ? void 0 : _this$_options$source._isReady) ? await this._metaFromSource(this._options.source) : await this._metaFromChain(metadata);
    return this._initFromMeta(this._runtimeMetadata);
  } // eslint-disable-next-line @typescript-eslint/require-await


  async _metaFromSource(source) {
    this._extrinsicType = source.extrinsicVersion;
    this._runtimeChain = source.runtimeChain;
    this._runtimeVersion = source.runtimeVersion;
    this._genesisHash = source.genesisHash;
    const methods = []; // manually build a list of all available methods in this RPC, we are
    // going to filter on it to align the cloned RPC without making a call

    Object.keys(source.rpc).forEach(section => {
      Object.keys(source.rpc[section]).forEach(method => {
        methods.push(`${section}_${method}`);
      });
    });

    this._filterRpcMethods(methods);

    return source.runtimeMetadata;
  } // subscribe to metadata updates, inject the types on changes


  _subscribeUpdates() {
    if ((0, _classPrivateFieldLooseBase2.default)(this, _updateSub)[_updateSub] || !this.hasSubscriptions) {
      return;
    }

    (0, _classPrivateFieldLooseBase2.default)(this, _updateSub)[_updateSub] = this._rpcCore.state.subscribeRuntimeVersion().pipe((0, _operators.switchMap)(version => {
      var _this$_runtimeVersion;

      return (// only retrieve the metadata when the on-chain version has been changed
        ((_this$_runtimeVersion = this._runtimeVersion) === null || _this$_runtimeVersion === void 0 ? void 0 : _this$_runtimeVersion.specVersion.eq(version.specVersion)) ? (0, _rxjs.of)(false) : this._rpcCore.state.getMetadata().pipe((0, _operators.map)(metadata => {
          l.log(`Runtime version updated to spec=${version.specVersion.toString()}, tx=${version.transactionVersion.toString()}`);
          this._runtimeMetadata = metadata;
          this._runtimeVersion = version;
          this._rx.runtimeVersion = version; // update the default registry version

          const thisRegistry = (0, _classPrivateFieldLooseBase2.default)(this, _registries)[_registries].find(({
            isDefault
          }) => isDefault);

          (0, _util.assert)(thisRegistry, 'Initialization error, cannot find the default registry'); // setup the data as per the current versions

          thisRegistry.metadata = metadata;
          thisRegistry.metadataConsts = null;
          thisRegistry.registry.setMetadata(metadata);
          thisRegistry.specVersion = version.specVersion; // clear the registry types to ensure that we override correctly

          this._initRegistry(thisRegistry.registry.init(), this._runtimeChain, version);

          this.injectMetadata(metadata, false, thisRegistry.registry);
          return true;
        }))
      );
    })).subscribe();
  }

  async _metaFromChain(optMetadata) {
    var _this$_genesisHash;

    const [runtimeVersion, chain, chainProps] = await Promise.all([this._rpcCore.state.getRuntimeVersion().toPromise(), this._rpcCore.system.chain().toPromise(), this._rpcCore.system.properties().toPromise()]); // set our chain version & genesisHash as returned

    this._runtimeChain = chain;
    this._runtimeVersion = runtimeVersion;
    this._rx.runtimeVersion = runtimeVersion; // initializes the registry

    this._initRegistry(this.registry, chain, runtimeVersion, chainProps);

    this._subscribeUpdates(); // filter the RPC methods (this does an rpc-methods call)


    await this._filterRpc(); // retrieve metadata, either from chain  or as pass-in via options

    const metadataKey = `${((_this$_genesisHash = this._genesisHash) === null || _this$_genesisHash === void 0 ? void 0 : _this$_genesisHash.toHex()) || '0x'}-${runtimeVersion.specVersion.toString()}`;
    const metadata = metadataKey in optMetadata ? new _types.Metadata(this.registry, optMetadata[metadataKey]) : await this._rpcCore.state.getMetadata().toPromise();
    this.registry.setMetadata(metadata); // setup the initial registry, when we have none

    if (!(0, _classPrivateFieldLooseBase2.default)(this, _registries)[_registries].length) {
      (0, _classPrivateFieldLooseBase2.default)(this, _registries)[_registries].push({
        isDefault: true,
        lastBlockHash: null,
        metadata,
        metadataConsts: null,
        registry: this.registry,
        specVersion: runtimeVersion.specVersion
      });
    } // get unique types & validate


    metadata.getUniqTypes(false);
    return metadata;
  }

  async _initFromMeta(metadata) {
    const metaExtrinsic = metadata.asLatest.extrinsic; // only inject if we are not a clone (global init)

    if (metaExtrinsic.version.gt(_util.BN_ZERO)) {
      this._extrinsicType = metaExtrinsic.version.toNumber();
    } else if (!this._options.source) {
      // detect the extrinsic version in-use based on the last block
      const {
        block: {
          extrinsics: [firstTx]
        }
      } = await this._rpcCore.chain.getBlock().toPromise(); // If we haven't sync-ed to 1 yes, this won't have any values

      this._extrinsicType = firstTx ? firstTx.type : _Extrinsic.LATEST_EXTRINSIC_VERSION;
    }

    this._rx.extrinsicType = this._extrinsicType;
    this._rx.genesisHash = this._genesisHash;
    this._rx.runtimeVersion = this._runtimeVersion;
    this.injectMetadata(metadata, true); // derive is last, since it uses the decorated rx

    this._rx.derive = this._decorateDeriveRx(this._rxDecorateMethod);
    this._derive = this._decorateDerive(this._decorateMethod);
    return true;
  }

}

exports.default = Init;

/***/ }),

/***/ "../../node_modules/@polkadot/api/base/index.js":
/*!***********************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api/base/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js"));

var _interopRequireWildcard2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "../../node_modules/@babel/runtime/helpers/interopRequireWildcard.js"));

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _Init = _interopRequireDefault(__webpack_require__(/*! ./Init */ "../../node_modules/@polkadot/api/base/Init.js"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

let pkgJson = {
  name: '@polkadot/api',
  version: '-'
};
Promise.resolve().then(() => (0, _interopRequireWildcard2.default)(__webpack_require__(/*! ../package.json */ "../../node_modules/@polkadot/api/package.json"))).then(_pkgJson => {
  pkgJson = _pkgJson;
}).catch(() => {// ignore
});

function assertResult(value) {
  (0, _util.assert)(!(0, _util.isUndefined)(value), 'Api needs to be initialized before using, listen on \'ready\'');
  return value;
}

class ApiBase extends _Init.default {
  /**
   * @description Create an instance of the class
   *
   * @param options Options object to create API instance or a Provider instance
   *
   * @example
   * <BR>
   *
   * ```javascript
   * import Api from '@polkadot/api/promise';
   *
   * const api = new Api().isReady();
   *
   * api.rpc.subscribeNewHeads((header) => {
   *   console.log(`new block #${header.number.toNumber()}`);
   * });
   * ```
   */
  constructor(options = {}, type, decorateMethod) {
    super(options, type, decorateMethod);
  }
  /**
   * @description Contains the parameter types (constants) of all modules.
   *
   * The values are instances of the appropriate type and are accessible using `section`.`constantName`,
   *
   * @example
   * <BR>
   *
   * ```javascript
   * console.log(api.consts.democracy.enactmentPeriod.toString())
   * ```
   */


  get consts() {
    return assertResult(this._consts);
  }
  /**
   * @description Derived results that are injected into the API, allowing for combinations of various query results.
   *
   * @example
   * <BR>
   *
   * ```javascript
   * api.derive.chain.bestNumber((number) => {
   *   console.log('best number', number);
   * });
   * ```
   */


  get derive() {
    return assertResult(this._derive);
  }
  /**
   * @description  Returns the version of extrinsics in-use on this chain
   */


  get extrinsicVersion() {
    return this._extrinsicType;
  }
  /**
   * @description Contains the genesis Hash of the attached chain. Apart from being useful to determine the actual chain, it can also be used to sign immortal transactions.
   */


  get genesisHash() {
    return assertResult(this._genesisHash);
  }
  /**
   * @description `true` when subscriptions are supported
   */


  get hasSubscriptions() {
    return this._rpcCore.provider.hasSubscriptions;
  }
  /**
   * @description true is the underlying provider is connected
   */


  get isConnected() {
    return this._isConnected.getValue();
  }
  /**
   * @description The library information name & version (from package.json)
   */


  get libraryInfo() {
    return `${pkgJson.name} v${pkgJson.version}`;
  }
  /**
   * @description Contains all the chain state modules and their subsequent methods in the API. These are attached dynamically from the runtime metadata.
   *
   * All calls inside the namespace, is denoted by `section`.`method` and may take an optional query parameter. As an example, `api.query.timestamp.now()` (current block timestamp) does not take parameters, while `api.query.system.account(<accountId>)` (retrieving the associated nonce & balances for an account), takes the `AccountId` as a parameter.
   *
   * @example
   * <BR>
   *
   * ```javascript
   * api.query.system.account(<accountId>, ([nonce, balance]) => {
   *   console.log('new free balance', balance.free, 'new nonce', nonce);
   * });
   * ```
   */


  get query() {
    return assertResult(this._query);
  }
  /**
   * @description Allows for the querying of multiple storage entries and the combination thereof into a single result. This is a very optimal way to make multiple queries since it only makes a single connection to the node and retrieves the data over one subscription.
   *
   * @example
   * <BR>
   *
   * ```javascript
   * const unsub = await api.queryMulti(
   *   [
   *     // you can include the storage without any parameters
   *     api.query.balances.totalIssuance,
   *     // or you can pass parameters to the storage query
   *     [api.query.system.account, '5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY']
   *   ],
   *   ([existential, [, { free }]]) => {
   *     console.log(`You have ${free.sub(existential)} more than the existential deposit`);
   *
   *     unsub();
   *   }
   * );
   * ```
   */


  get queryMulti() {
    return assertResult(this._queryMulti);
  }
  /**
   * @description Contains all the raw rpc sections and their subsequent methods in the API as defined by the jsonrpc interface definitions. Unlike the dynamic `api.query` and `api.tx` sections, these methods are fixed (although extensible with node upgrades) and not determined by the runtime.
   *
   * RPC endpoints available here allow for the query of chain, node and system information, in addition to providing interfaces for the raw queries of state (using known keys) and the submission of transactions.
   *
   * @example
   * <BR>
   *
   * ```javascript
   * api.rpc.chain.subscribeNewHeads((header) => {
   *   console.log('new header', header);
   * });
   * ```
   */


  get rpc() {
    return assertResult(this._rpc);
  }
  /**
   * @description Contains the chain information for the current node.
   */


  get runtimeChain() {
    return assertResult(this._runtimeChain);
  }
  /**
   * @description Yields the current attached runtime metadata. Generally this is only used to construct extrinsics & storage, but is useful for current runtime inspection.
   */


  get runtimeMetadata() {
    return assertResult(this._runtimeMetadata);
  }
  /**
   * @description Contains the version information for the current runtime.
   */


  get runtimeVersion() {
    return assertResult(this._runtimeVersion);
  }
  /**
   * @description The underlying Rx API interface
   */


  get rx() {
    return assertResult(this._rx);
  }
  /**
   * @description The type of this API instance, either 'rxjs' or 'promise'
   */


  get type() {
    return this._type;
  }
  /**
   * @description Contains all the extrinsic modules and their subsequent methods in the API. It allows for the construction of transactions and the submission thereof. These are attached dynamically from the runtime metadata.
   *
   * @example
   * <BR>
   *
   * ```javascript
   * api.tx.balances
   *   .transfer(<recipientId>, <balance>)
   *   .signAndSend(<keyPair>, ({status}) => {
   *     console.log('tx status', status.asFinalized.toHex());
   *   });
   * ```
   */


  get tx() {
    return assertResult(this._extrinsics);
  }
  /**
   * @description Connect from the underlying provider, halting all network traffic
   */


  connect() {
    return this._rpcCore.connect();
  }
  /**
   * @description Disconnect from the underlying provider, halting all network traffic
   */


  disconnect() {
    return this._rpcCore.disconnect();
  }
  /**
   * @description Finds the definition for a specific [[CallFunction]] based on the index supplied
   */


  findCall(callIndex) {
    return this.registry.findMetaCall((0, _util.u8aToU8a)(callIndex));
  }
  /**
   * @description Finds the definition for a specific [[RegistryError]] based on the index supplied
   */


  findError(errorIndex) {
    return this.registry.findMetaError((0, _util.u8aToU8a)(errorIndex));
  }
  /**
   * @description Set an external signer which will be used to sign extrinsic when account passed in is not KeyringPair
   */


  setSigner(signer) {
    this._rx.signer = signer;
  }
  /**
   * @description Signs a raw signer payload, string or Uint8Array
   */


  async sign(address, data, {
    signer
  } = {}) {
    if ((0, _util.isString)(address)) {
      const _signer = signer || this._rx.signer;

      (0, _util.assert)(_signer === null || _signer === void 0 ? void 0 : _signer.signRaw, 'No signer exists with a signRaw interface. You possibly need to pass through an explicit keypair for the origin so it can be used for signing.');
      return (await _signer.signRaw(_objectSpread(_objectSpread({
        type: 'bytes'
      }, data), {}, {
        address
      }))).signature;
    }

    return (0, _util.u8aToHex)(address.sign((0, _util.u8aToU8a)(data.data)));
  }

}

exports.default = ApiBase;

/***/ }),

/***/ "../../node_modules/@polkadot/api/index.js":
/*!******************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__dirname) {

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  Keyring: true,
  WsProvider: true,
  ApiPromise: true,
  ApiRx: true
};
Object.defineProperty(exports, "Keyring", {
  enumerable: true,
  get: function () {
    return _keyring.Keyring;
  }
});
Object.defineProperty(exports, "WsProvider", {
  enumerable: true,
  get: function () {
    return _rpcProvider.WsProvider;
  }
});
Object.defineProperty(exports, "ApiPromise", {
  enumerable: true,
  get: function () {
    return _promise.default;
  }
});
Object.defineProperty(exports, "ApiRx", {
  enumerable: true,
  get: function () {
    return _rx.default;
  }
});

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _keyring = __webpack_require__(/*! @polkadot/keyring */ "../../node_modules/@polkadot/keyring/index.js");

var _rpcProvider = __webpack_require__(/*! @polkadot/rpc-provider */ "../../node_modules/@polkadot/rpc-provider/index.js");

var _promise = _interopRequireDefault(__webpack_require__(/*! ./promise */ "../../node_modules/@polkadot/api/promise/index.js"));

var _rx = _interopRequireDefault(__webpack_require__(/*! ./rx */ "../../node_modules/@polkadot/api/rx/index.js"));

var _submittable = __webpack_require__(/*! ./submittable */ "../../node_modules/@polkadot/api/submittable/index.js");

Object.keys(_submittable).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _submittable[key];
    }
  });
});
// Copyright 2017-2020 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0
// FIXME This really should be `import(...).then(...)`, but need to check rejections
// eslint-disable-next-line @typescript-eslint/no-var-requires
(0, _util.detectPackage)(__webpack_require__(/*! ./package.json */ "../../node_modules/@polkadot/api/package.json"),  true && __dirname);
/* WEBPACK VAR INJECTION */}.call(this, "/"))

/***/ }),

/***/ "../../node_modules/@polkadot/api/package.json":
/*!**********************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api/package.json ***!
  \**********************************************************/
/*! exports provided: name, version, description, main, keywords, author, maintainers, contributors, license, publishConfig, repository, bugs, homepage, dependencies, devDependencies, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"name\":\"@polkadot/api\",\"version\":\"2.2.2-2\",\"description\":\"Promise and RxJS wrappers around the Polkadot JS RPC\",\"main\":\"index.js\",\"keywords\":[\"Polkadot\",\"RxJs\"],\"author\":\"Jaco Greeff <jacogr@gmail.com>\",\"maintainers\":[\"Jaco Greeff <jacogr@gmail.com>\"],\"contributors\":[],\"license\":\"Apache-2.0\",\"publishConfig\":{\"access\":\"public\",\"registry\":\"https://registry.npmjs.org\"},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/polkadot-js/api.git\"},\"bugs\":{\"url\":\"https://github.com/polkadot-js/api/issues\"},\"homepage\":\"https://github.com/polkadot-js/api/tree/master/packages/api#readme\",\"dependencies\":{\"@babel/runtime\":\"^7.11.2\",\"@polkadot/api-derive\":\"2.2.2-2\",\"@polkadot/keyring\":\"^3.5.1\",\"@polkadot/metadata\":\"2.2.2-2\",\"@polkadot/rpc-core\":\"2.2.2-2\",\"@polkadot/rpc-provider\":\"2.2.2-2\",\"@polkadot/types\":\"2.2.2-2\",\"@polkadot/types-known\":\"2.2.2-2\",\"@polkadot/util\":\"^3.5.1\",\"@polkadot/util-crypto\":\"^3.5.1\",\"bn.js\":\"^5.1.3\",\"eventemitter3\":\"^4.0.7\",\"rxjs\":\"^6.6.3\"},\"devDependencies\":{\"@polkadot/keyring\":\"^3.5.1\"}}");

/***/ }),

/***/ "../../node_modules/@polkadot/api/promise/Api.js":
/*!************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api/promise/Api.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decorateMethod = decorateMethod;
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js"));

var _classPrivateFieldLooseBase2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classPrivateFieldLooseBase */ "../../node_modules/@babel/runtime/helpers/classPrivateFieldLooseBase.js"));

var _classPrivateFieldLooseKey2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classPrivateFieldLooseKey */ "../../node_modules/@babel/runtime/helpers/classPrivateFieldLooseKey.js"));

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _base = _interopRequireDefault(__webpack_require__(/*! ../base */ "../../node_modules/@polkadot/api/base/index.js"));

var _Combinator = _interopRequireDefault(__webpack_require__(/*! ./Combinator */ "../../node_modules/@polkadot/api/promise/Combinator.js"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// extract the arguments and callback params from a value array possibly containing a callback
function extractArgs(args, needsCallback) {
  let callback;
  const actualArgs = args.slice(); // If the last arg is a function, we pop it, put it into callback.
  // actualArgs will then hold the actual arguments to be passed to `method`

  if (args.length && (0, _util.isFunction)(args[args.length - 1])) {
    callback = actualArgs.pop();
  } // When we need a subscription, ensure that a valid callback is actually passed


  (0, _util.assert)(!needsCallback || (0, _util.isFunction)(callback), 'Expected a callback to be passed with subscriptions');
  return [actualArgs, callback];
} // a Promise completion tracker, wrapping an isComplete variable that ensures the promise only resolves once


function promiseTracker(resolve, reject) {
  let isCompleted = false;
  return {
    reject: error => {
      if (!isCompleted) {
        isCompleted = true;
        reject(error);
      }

      return _rxjs.EMPTY;
    },
    resolve: value => {
      if (!isCompleted) {
        isCompleted = true;
        resolve(value);
      }
    }
  };
} // Decorate a call for a single-shot result - retrieve and then immediate unsubscribe


function decorateCall(method, actualArgs) {
  return new Promise((resolve, reject) => {
    // single result tracker - either reject with Error or resolve with Codec result
    const tracker = promiseTracker(resolve, reject); // encoding errors reject immediately, any result unsubscribes and resolves

    const subscription = method(...actualArgs).pipe((0, _operators.catchError)(error => tracker.reject(error))).subscribe(result => {
      tracker.resolve(result);
      setTimeout(() => subscription.unsubscribe(), 0);
    });
  });
} // Decorate a subscription where we have a result callback specified


function decorateSubscribe(method, actualArgs, resultCb) {
  return new Promise((resolve, reject) => {
    // either reject with error or resolve with unsubscribe callback
    const tracker = promiseTracker(resolve, reject); // errors reject immediately, the first result resolves with an unsubscribe promise, all results via callback

    const subscription = method(...actualArgs).pipe((0, _operators.catchError)(error => tracker.reject(error)), (0, _operators.tap)(() => tracker.resolve(() => subscription.unsubscribe()))).subscribe(result => {
      // queue result (back of queue to clear current)
      setTimeout(() => resultCb(result), 0);
    });
  });
}
/**
 * @description Decorate method for ApiPromise, where the results are converted to the Promise equivalent
 */


function decorateMethod(method, options) {
  const needsCallback = options && options.methodName && options.methodName.includes('subscribe');
  return function (...args) {
    const [actualArgs, resultCb] = extractArgs(args, !!needsCallback);
    return resultCb ? decorateSubscribe(method, actualArgs, resultCb) : decorateCall((options === null || options === void 0 ? void 0 : options.overrideNoSub) || method, actualArgs);
  };
}
/**
 * # @polkadot/api/promise
 *
 * ## Overview
 *
 * @name ApiPromise
 * @description
 * ApiPromise is a standard JavaScript wrapper around the RPC and interfaces on the Polkadot network. As a full Promise-based, all interface calls return Promises, including the static `.create(...)`. Subscription calls utilise `(value) => {}` callbacks to pass through the latest values.
 *
 * The API is well suited to real-time applications where either the single-shot state is needed or use is to be made of the subscription-based features of Polkadot (and Substrate) clients.
 *
 * @see [[ApiRx]]
 *
 * ## Usage
 *
 * Making rpc calls -
 * <BR>
 *
 * ```javascript
 * import ApiPromise from '@polkadot/api/promise';
 *
 * // initialise via static create
 * const api = await ApiPromise.create();
 *
 * // make a subscription to the network head
 * api.rpc.chain.subscribeNewHeads((header) => {
 *   console.log(`Chain is at #${header.number}`);
 * });
 * ```
 * <BR>
 *
 * Subscribing to chain state -
 * <BR>
 *
 * ```javascript
 * import { ApiPromise, WsProvider } from '@polkadot/api';
 *
 * // initialise a provider with a specific endpoint
 * const provider = new WsProvider('wss://example.com:9944')
 *
 * // initialise via isReady & new with specific provider
 * const api = await new ApiPromise({ provider }).isReady;
 *
 * // retrieve the block target time
 * const blockPeriod = await api.query.timestamp.blockPeriod().toNumber();
 * let last = 0;
 *
 * // subscribe to the current block timestamp, updates automatically (callback provided)
 * api.query.timestamp.now((timestamp) => {
 *   const elapsed = last
 *     ? `, ${timestamp.toNumber() - last}s since last`
 *     : '';
 *
 *   last = timestamp.toNumber();
 *   console.log(`timestamp ${timestamp}${elapsed} (${blockPeriod}s target)`);
 * });
 * ```
 * <BR>
 *
 * Submitting a transaction -
 * <BR>
 *
 * ```javascript
 * import ApiPromise from '@polkadot/api/promise';
 *
 * ApiPromise.create().then((api) => {
 *   const [nonce] = await api.query.system.account(keyring.alice.address);
 *
 *   api.tx.balances
 *     // create transfer
 *     transfer(keyring.bob.address, 12345)
 *     // sign the transcation
 *     .sign(keyring.alice, { nonce })
 *     // send the transaction (optional status callback)
 *     .send((status) => {
 *       console.log(`current status ${status.type}`);
 *     })
 *     // retrieve the submitted extrinsic hash
 *     .then((hash) => {
 *       console.log(`submitted with hash ${hash}`);
 *     });
 * });
 * ```
 */


var _isReadyPromise = (0, _classPrivateFieldLooseKey2.default)("isReadyPromise");

var _isReadyOrErrorPromise = (0, _classPrivateFieldLooseKey2.default)("isReadyOrErrorPromise");

class ApiPromise extends _base.default {
  /**
   * @description Creates an ApiPromise instance using the supplied provider. Returns an Promise containing the actual Api instance.
   * @param options options that is passed to the class contructor. Can be either [[ApiOptions]] or a
   * provider (see the constructor arguments)
   * @example
   * <BR>
   *
   * ```javascript
   * import Api from '@polkadot/api/promise';
   *
   * Api.create().then(async (api) => {
   *   const timestamp = await api.query.timestamp.now();
   *
   *   console.log(`lastest block timestamp ${timestamp}`);
   * });
   * ```
   */
  static create(options) {
    return new ApiPromise(options).isReady;
  }
  /**
   * @description Creates an instance of the ApiPromise class
   * @param options Options to create an instance. This can be either [[ApiOptions]] or
   * an [[WsProvider]].
   * @example
   * <BR>
   *
   * ```javascript
   * import Api from '@polkadot/api/promise';
   *
   * new Api().isReady.then((api) => {
   *   api.rpc.subscribeNewHeads((header) => {
   *     console.log(`new block #${header.number.toNumber()}`);
   *   });
   * });
   * ```
   */


  constructor(options) {
    super(options, 'promise', decorateMethod);
    Object.defineProperty(this, _isReadyPromise, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _isReadyOrErrorPromise, {
      writable: true,
      value: void 0
    });
    (0, _classPrivateFieldLooseBase2.default)(this, _isReadyPromise)[_isReadyPromise] = new Promise(resolve => {
      super.once('ready', () => {
        resolve(this);
      });
    });
    (0, _classPrivateFieldLooseBase2.default)(this, _isReadyOrErrorPromise)[_isReadyOrErrorPromise] = new Promise((resolve, reject) => {
      super.once('ready', () => {
        resolve(this);
      });
      super.once('error', e => {
        reject(e);
      });
    });
  }
  /**
   * @description Promise that resolves the first time we are connected and loaded
   */


  get isReady() {
    return (0, _classPrivateFieldLooseBase2.default)(this, _isReadyPromise)[_isReadyPromise];
  }
  /**
   * @description Promise that resolves if we can connect, or reject if there is an error
   */


  get isReadyOrError() {
    return (0, _classPrivateFieldLooseBase2.default)(this, _isReadyOrErrorPromise)[_isReadyOrErrorPromise];
  }
  /**
   * @description Returns a clone of this ApiPromise instance (new underlying provider connection)
   */


  clone() {
    return new ApiPromise(_objectSpread(_objectSpread({}, this._options), {}, {
      source: this
    }));
  }
  /**
   * @description Creates a combinator that can be used to combine the latest results from multiple subscriptions
   * @param fns An array of function to combine, each in the form of `(cb: (value: void)) => void`
   * @param callback A callback that will return an Array of all the values this combinator has been applied to
   * @example
   * <BR>
   *
   * ```javascript
   * const address = '5DTestUPts3kjeXSTMyerHihn1uwMfLj8vU8sqF7qYrFacT7';
   *
   * // combines values from balance & nonce as it updates
   * api.combineLatest([
   *   api.rpc.chain.subscribeNewHeads,
   *   (cb) => api.query.system.account(address, cb)
   * ], ([head, [balance, nonce]]) => {
   *   console.log(`#${head.number}: You have ${balance.free} units, with ${nonce} transactions sent`);
   * });
   * ```
   */
  // eslint-disable-next-line @typescript-eslint/require-await


  async combineLatest(fns, callback) {
    const combinator = new _Combinator.default(fns, callback);
    return () => {
      combinator.unsubscribe();
    };
  }

}

exports.default = ApiPromise;

/***/ }),

/***/ "../../node_modules/@polkadot/api/promise/Combinator.js":
/*!*******************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api/promise/Combinator.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classPrivateFieldLooseBase2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classPrivateFieldLooseBase */ "../../node_modules/@babel/runtime/helpers/classPrivateFieldLooseBase.js"));

var _classPrivateFieldLooseKey2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classPrivateFieldLooseKey */ "../../node_modules/@babel/runtime/helpers/classPrivateFieldLooseKey.js"));

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

// Copyright 2017-2020 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _allHasFired = (0, _classPrivateFieldLooseKey2.default)("allHasFired");

var _callback = (0, _classPrivateFieldLooseKey2.default)("callback");

var _fired = (0, _classPrivateFieldLooseKey2.default)("fired");

var _fns = (0, _classPrivateFieldLooseKey2.default)("fns");

var _isActive = (0, _classPrivateFieldLooseKey2.default)("isActive");

var _results = (0, _classPrivateFieldLooseKey2.default)("results");

var _subscriptions = (0, _classPrivateFieldLooseKey2.default)("subscriptions");

class Combinator {
  constructor(fns, callback) {
    Object.defineProperty(this, _allHasFired, {
      writable: true,
      value: false
    });
    Object.defineProperty(this, _callback, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _fired, {
      writable: true,
      value: []
    });
    Object.defineProperty(this, _fns, {
      writable: true,
      value: []
    });
    Object.defineProperty(this, _isActive, {
      writable: true,
      value: true
    });
    Object.defineProperty(this, _results, {
      writable: true,
      value: []
    });
    Object.defineProperty(this, _subscriptions, {
      writable: true,
      value: []
    });
    (0, _classPrivateFieldLooseBase2.default)(this, _callback)[_callback] = callback; // eslint-disable-next-line @typescript-eslint/require-await

    (0, _classPrivateFieldLooseBase2.default)(this, _subscriptions)[_subscriptions] = fns.map(async (input, index) => {
      const [fn, ...args] = Array.isArray(input) ? input : [input];

      (0, _classPrivateFieldLooseBase2.default)(this, _fired)[_fired].push(false);

      (0, _classPrivateFieldLooseBase2.default)(this, _fns)[_fns].push(fn); // Not quite 100% how to have a variable number at the front here
      // eslint-disable-next-line @typescript-eslint/no-unsafe-return,@typescript-eslint/ban-types


      return fn(...args, this._createCallback(index));
    });
  }

  _allHasFired() {
    if (!(0, _classPrivateFieldLooseBase2.default)(this, _allHasFired)[_allHasFired]) {
      (0, _classPrivateFieldLooseBase2.default)(this, _allHasFired)[_allHasFired] = (0, _classPrivateFieldLooseBase2.default)(this, _fired)[_fired].filter(hasFired => !hasFired).length === 0;
    }

    return (0, _classPrivateFieldLooseBase2.default)(this, _allHasFired)[_allHasFired];
  }

  _createCallback(index) {
    return value => {
      (0, _classPrivateFieldLooseBase2.default)(this, _fired)[_fired][index] = true;
      (0, _classPrivateFieldLooseBase2.default)(this, _results)[_results][index] = value;

      this._triggerUpdate();
    };
  }

  _triggerUpdate() {
    if (!(0, _classPrivateFieldLooseBase2.default)(this, _isActive)[_isActive] || !(0, _util.isFunction)((0, _classPrivateFieldLooseBase2.default)(this, _callback)[_callback]) || !this._allHasFired()) {
      return;
    }

    try {
      // eslint-disable-next-line @typescript-eslint/no-floating-promises
      (0, _classPrivateFieldLooseBase2.default)(this, _callback)[_callback]((0, _classPrivateFieldLooseBase2.default)(this, _results)[_results]);
    } catch (error) {// swallow, we don't want the handler to trip us up
    }
  }

  unsubscribe() {
    if (!(0, _classPrivateFieldLooseBase2.default)(this, _isActive)[_isActive]) {
      return;
    }

    (0, _classPrivateFieldLooseBase2.default)(this, _isActive)[_isActive] = false; // eslint-disable-next-line @typescript-eslint/no-misused-promises

    (0, _classPrivateFieldLooseBase2.default)(this, _subscriptions)[_subscriptions].forEach(async subscription => {
      try {
        const unsubscribe = await subscription;

        if ((0, _util.isFunction)(unsubscribe)) {
          unsubscribe();
        }
      } catch (error) {// ignore
      }
    });
  }

}

exports.default = Combinator;

/***/ }),

/***/ "../../node_modules/@polkadot/api/promise/index.js":
/*!**************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api/promise/index.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "../../node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "decorateMethod", {
  enumerable: true,
  get: function () {
    return _Api.decorateMethod;
  }
});
exports.default = void 0;

var _Api = _interopRequireWildcard(__webpack_require__(/*! ./Api */ "../../node_modules/@polkadot/api/promise/Api.js"));

// Copyright 2017-2020 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _default = _Api.default;
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/api/rx/Api.js":
/*!*******************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api/rx/Api.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decorateMethod = decorateMethod;
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js"));

var _classPrivateFieldLooseBase2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classPrivateFieldLooseBase */ "../../node_modules/@babel/runtime/helpers/classPrivateFieldLooseBase.js"));

var _classPrivateFieldLooseKey2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classPrivateFieldLooseKey */ "../../node_modules/@babel/runtime/helpers/classPrivateFieldLooseKey.js"));

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _base = _interopRequireDefault(__webpack_require__(/*! ../base */ "../../node_modules/@polkadot/api/base/index.js"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function decorateMethod(method) {
  return method;
}
/**
 * # @polkadot/api/rx
 *
 *  ## Overview
 *
 * @name ApiRx
 *
 * @description
 * ApiRx is a powerful RxJS Observable wrapper around the RPC and interfaces on the Polkadot network. As a full Observable API, all interface calls return RxJS Observables, including the static `.create(...)`. In the same fashion and subscription-based methods return long-running Observables that update with the latest values.
 *
 * The API is well suited to real-time applications where the latest state is needed, unlocking the subscription-based features of Polkadot (and Substrate) clients. Some familiarity with RxJS is a requirement to use the API, however just understanding `.subscribe` and `.pipe` on Observables will unlock full-scale use thereof.
 *
 * @see [[ApiPromise]]
 *
 * ## Usage
 *
 * Making rpc calls -
 * <BR>
 *
 * ```javascript
 * import ApiRx from '@polkadot/api/rx';
 *
 * // initialize via Promise & static create
 * const api = await ApiRx.create().toPromise();
 *
 * // make a call to retrieve the current network head
 * api.rpc.chain.subscribeNewHeads().subscribe((header) => {
 *   console.log(`Chain is at #${header.number}`);
 * });
 * ```
 * <BR>
 *
 * Subscribing to chain state -
 * <BR>
 *
 * ```javascript
 * import { combineLatest } from 'rxjs';
 * import { pairwise, switchMap } from 'rxjs/operators';
 * import { ApiRx, WsProvider } from '@polkadot/api';
 *
 *
 * // initialize a provider with a specific endpoint
 * const provider = new WsProvider('wss://example.com:9944')
 *
 * // initialize via isReady & new with specific provider
 * new ApiRx({ provider })
 *   .isReady
 *   .pipe(
 *     switchMap((api) =>
 *       combineLatest([
 *         api.query.timestamp.blockPeriod(),
 *         api.query.timestamp.now().pipe(pairwise())
 *       ])
 *     )
 *   )
 *   .subscribe(([blockPeriod, timestamp]) => {
 *      const elapsed = timestamp[1].toNumber() - timestamp[0].toNumber();
 *      console.log(`timestamp ${timestamp[1]} \nelapsed ${elapsed} \n(${blockPeriod}s target)`);
 *   });
 * ```
 * <BR>
 *
 * Submitting a transaction -
 * <BR>
 *
 * ```javascript
 * import { first, switchMap } from 'rxjs/operators';
 * import ApiRx from '@polkadot/api/rx';
 *
 * // import the test keyring (already has dev keys for Alice, Bob, Charlie, Eve & Ferdie)
 * import testingPairs from '@polkadot/keyring/testingPairs';
 * const keyring = testingPairs();
 *
 * // get api via Promise
 * const api = await ApiRx.create().toPromise();
 *
 * // retrieve nonce for the account
 * api.query.system
 *   .account(keyring.alice.address)
 *   .pipe(
 *      first(),
 *      // pipe nonce into transfer
 *      switchMap(([nonce]) =>
 *        api.tx.balances
 *          // create transfer
 *          .transfer(keyring.bob.address, 12345)
 *          // sign the transaction
 *          .sign(keyring.alice, { nonce })
 *          // send the transaction
 *          .send()
 *      )
 *   )
 *   // subscribe to overall result
 *   .subscribe(({ status }) => {
 *     if (status.isInBlock) {
 *       console.log('Completed at block hash', status.asFinalized.toHex());
 *     }
 *   });
 * ```
 */


var _isReadyRx = (0, _classPrivateFieldLooseKey2.default)("isReadyRx");

class ApiRx extends _base.default {
  /**
   * @description Creates an ApiRx instance using the supplied provider. Returns an Observable containing the actual Api instance.
   * @param options options that is passed to the class constructor. Can be either [[ApiOptions]] or [[WsProvider]]
   * @example
   * <BR>
   *
   * ```javascript
   * import { switchMap } from 'rxjs/operators';
   * import Api from '@polkadot/api/rx';
   *
   * Api.create()
   *   .pipe(
   *     switchMap((api) =>
   *       api.rpc.chain.subscribeNewHeads()
   *   ))
   *   .subscribe((header) => {
   *     console.log(`new block #${header.number.toNumber()}`);
   *   });
   * ```
   */
  static create(options) {
    return new ApiRx(options).isReady;
  }
  /**
   * @description Create an instance of the ApiRx class
   * @param options Options to create an instance. Can be either [[ApiOptions]] or [[WsProvider]]
   * @example
   * <BR>
   *
   * ```javascript
   * import { switchMap } from 'rxjs/operators';
   * import Api from '@polkadot/api/rx';
   *
   * new Api().isReady
   *   .pipe(
   *     switchMap((api) =>
   *       api.rpc.chain.subscribeNewHeads()
   *   ))
   *   .subscribe((header) => {
   *     console.log(`new block #${header.number.toNumber()}`);
   *   });
   * ```
   */


  constructor(options) {
    super(options, 'rxjs', decorateMethod);
    Object.defineProperty(this, _isReadyRx, {
      writable: true,
      value: void 0
    });
    (0, _classPrivateFieldLooseBase2.default)(this, _isReadyRx)[_isReadyRx] = (0, _rxjs.from)( // You can create an observable from an event, however my mind groks this form better
    new Promise(resolve => {
      super.on('ready', () => {
        resolve(this);
      });
    }));
  }
  /**
   * @description Observable that returns the first time we are connected and loaded
   */


  get isReady() {
    return (0, _classPrivateFieldLooseBase2.default)(this, _isReadyRx)[_isReadyRx];
  }
  /**
   * @description Returns a clone of this ApiRx instance (new underlying provider connection)
   */


  clone() {
    return new ApiRx(_objectSpread(_objectSpread({}, this._options), {}, {
      source: this
    }));
  }

}

exports.default = ApiRx;

/***/ }),

/***/ "../../node_modules/@polkadot/api/rx/index.js":
/*!*********************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api/rx/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "../../node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "decorateMethod", {
  enumerable: true,
  get: function () {
    return _Api.decorateMethod;
  }
});
exports.default = void 0;

var _Api = _interopRequireWildcard(__webpack_require__(/*! ./Api */ "../../node_modules/@polkadot/api/rx/Api.js"));

// Copyright 2017-2020 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _default = _Api.default;
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/api/submittable/Result.js":
/*!*******************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api/submittable/Result.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

// Copyright 2017-2020 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0
class SubmittableResult {
  constructor({
    events,
    status
  }) {
    this.events = void 0;
    this.status = void 0;
    this.events = events || [];
    this.status = status;
  }

  get isCompleted() {
    return this.isError || this.status.isInBlock || this.status.isFinalized;
  }

  get isError() {
    return this.status.isDropped || this.status.isFinalityTimeout || this.status.isInvalid || this.status.isUsurped;
  }

  get isFinalized() {
    return this.status.isFinalized;
  }

  get isInBlock() {
    return this.status.isInBlock;
  }

  get isWarning() {
    return this.status.isRetracted;
  }
  /**
   * @description Filters EventRecords for the specified method & section (there could be multiple)
   */


  filterRecords(section, method) {
    return this.events.filter(({
      event
    }) => event.section === section && event.method === method);
  }
  /**
   * @description Finds an EventRecord for the specified method & section
   */


  findRecord(section, method) {
    return this.events.find(({
      event
    }) => event.section === section && event.method === method);
  }
  /**
   * @description Creates a human representation of the output
   */


  toHuman(isExtended) {
    return {
      events: this.events.map(event => event.toHuman(isExtended)),
      status: this.status.toHuman(isExtended)
    };
  }

}

exports.default = SubmittableResult;

/***/ }),

/***/ "../../node_modules/@polkadot/api/submittable/createClass.js":
/*!************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api/submittable/createClass.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createClass;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js"));

var _classPrivateFieldLooseBase2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classPrivateFieldLooseBase */ "../../node_modules/@babel/runtime/helpers/classPrivateFieldLooseBase.js"));

var _classPrivateFieldLooseKey2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classPrivateFieldLooseKey */ "../../node_modules/@babel/runtime/helpers/classPrivateFieldLooseKey.js"));

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _util2 = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/api/util/index.js");

var _Result = _interopRequireDefault(__webpack_require__(/*! ./Result */ "../../node_modules/@polkadot/api/submittable/Result.js"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const identity = input => input;

function createClass({
  api,
  apiType,
  decorateMethod
}) {
  var _ignoreStatusCb, _transformResult, _makeEraOptions, _makeSignOptions, _makeSignAndSendOptions, _observeSign, _observeStatus, _observeSend, _observeSubscribe, _optionsOrNonce, _signViaSigner, _updateSigner, _temp;

  // an instance of the base extrinsic for us to extend
  const ExtrinsicBase = api.registry.createClass('Extrinsic');
  return _temp = (_ignoreStatusCb = (0, _classPrivateFieldLooseKey2.default)("ignoreStatusCb"), _transformResult = (0, _classPrivateFieldLooseKey2.default)("transformResult"), _makeEraOptions = (0, _classPrivateFieldLooseKey2.default)("makeEraOptions"), _makeSignOptions = (0, _classPrivateFieldLooseKey2.default)("makeSignOptions"), _makeSignAndSendOptions = (0, _classPrivateFieldLooseKey2.default)("makeSignAndSendOptions"), _observeSign = (0, _classPrivateFieldLooseKey2.default)("observeSign"), _observeStatus = (0, _classPrivateFieldLooseKey2.default)("observeStatus"), _observeSend = (0, _classPrivateFieldLooseKey2.default)("observeSend"), _observeSubscribe = (0, _classPrivateFieldLooseKey2.default)("observeSubscribe"), _optionsOrNonce = (0, _classPrivateFieldLooseKey2.default)("optionsOrNonce"), _signViaSigner = (0, _classPrivateFieldLooseKey2.default)("signViaSigner"), _updateSigner = (0, _classPrivateFieldLooseKey2.default)("updateSigner"), class Submittable extends ExtrinsicBase {
    constructor(registry, extrinsic) {
      super(registry, extrinsic, {
        version: api.extrinsicType
      });
      Object.defineProperty(this, _ignoreStatusCb, {
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, _transformResult, {
        writable: true,
        value: identity
      });
      Object.defineProperty(this, _makeEraOptions, {
        writable: true,
        value: (options, {
          header,
          mortalLength,
          nonce
        }) => {
          if (!header) {
            if ((0, _util.isNumber)(options.era)) {
              // since we have no header, it is immortal, remove any option overrides
              // so we only supply the genesisHash and no era to the construction
              delete options.era;
              delete options.blockHash;
            }

            return (0, _classPrivateFieldLooseBase2.default)(this, _makeSignOptions)[_makeSignOptions](options, {
              nonce
            });
          }

          return (0, _classPrivateFieldLooseBase2.default)(this, _makeSignOptions)[_makeSignOptions](options, {
            blockHash: header.hash,
            era: this.registry.createType('ExtrinsicEra', {
              current: header.number,
              period: options.era || mortalLength
            }),
            nonce
          });
        }
      });
      Object.defineProperty(this, _makeSignOptions, {
        writable: true,
        value: (options, extras) => {
          return _objectSpread(_objectSpread(_objectSpread({
            blockHash: api.genesisHash,
            genesisHash: api.genesisHash
          }, options), extras), {}, {
            runtimeVersion: api.runtimeVersion,
            signedExtensions: api.registry.signedExtensions,
            version: api.extrinsicType
          });
        }
      });
      Object.defineProperty(this, _makeSignAndSendOptions, {
        writable: true,
        value: (optionsOrStatus, statusCb) => {
          let options = {};

          if ((0, _util.isFunction)(optionsOrStatus)) {
            statusCb = optionsOrStatus;
          } else {
            options = _objectSpread({}, optionsOrStatus);
          }

          return [options, statusCb];
        }
      });
      Object.defineProperty(this, _observeSign, {
        writable: true,
        value: (account, optionsOrNonce) => {
          const address = (0, _util2.isKeyringPair)(account) ? account.address : account.toString();

          const options = (0, _classPrivateFieldLooseBase2.default)(this, _optionsOrNonce)[_optionsOrNonce](optionsOrNonce);

          let updateId;
          return api.derive.tx.signingInfo(address, options.nonce, options.era).pipe((0, _operators.first)(), (0, _operators.mergeMap)(async signingInfo => {
            const eraOptions = (0, _classPrivateFieldLooseBase2.default)(this, _makeEraOptions)[_makeEraOptions](options, signingInfo);

            if ((0, _util2.isKeyringPair)(account)) {
              this.sign(account, eraOptions);
            } else {
              updateId = await (0, _classPrivateFieldLooseBase2.default)(this, _signViaSigner)[_signViaSigner](address, eraOptions, signingInfo.header);
            }
          }), (0, _operators.mapTo)(updateId));
        }
      });
      Object.defineProperty(this, _observeStatus, {
        writable: true,
        value: (hash, status) => {
          if (!status.isFinalized && !status.isInBlock) {
            return (0, _rxjs.of)((0, _classPrivateFieldLooseBase2.default)(this, _transformResult)[_transformResult](new _Result.default({
              status
            })));
          }

          const blockHash = status.isInBlock ? status.asInBlock : status.asFinalized;
          return api.derive.tx.events(blockHash).pipe((0, _operators.map)(({
            block,
            events
          }) => (0, _classPrivateFieldLooseBase2.default)(this, _transformResult)[_transformResult](new _Result.default({
            events: (0, _util2.filterEvents)(hash, block, events, status),
            status
          }))));
        }
      });
      Object.defineProperty(this, _observeSend, {
        writable: true,
        value: (updateId = -1) => {
          return api.rpc.author.submitExtrinsic(this).pipe((0, _operators.tap)(hash => {
            (0, _classPrivateFieldLooseBase2.default)(this, _updateSigner)[_updateSigner](updateId, hash);
          }));
        }
      });
      Object.defineProperty(this, _observeSubscribe, {
        writable: true,
        value: (updateId = -1) => {
          const hash = this.hash;
          return api.rpc.author.submitAndWatchExtrinsic(this).pipe((0, _operators.switchMap)(status => (0, _classPrivateFieldLooseBase2.default)(this, _observeStatus)[_observeStatus](hash, status)), (0, _operators.tap)(status => {
            (0, _classPrivateFieldLooseBase2.default)(this, _updateSigner)[_updateSigner](updateId, status);
          }));
        }
      });
      Object.defineProperty(this, _optionsOrNonce, {
        writable: true,
        value: (optionsOrNonce = {}) => {
          return (0, _util.isBn)(optionsOrNonce) || (0, _util.isNumber)(optionsOrNonce) ? {
            nonce: optionsOrNonce
          } : optionsOrNonce;
        }
      });
      Object.defineProperty(this, _signViaSigner, {
        writable: true,
        value: async (address, options, header) => {
          const signer = options.signer || api.signer;
          (0, _util.assert)(signer, 'No signer specified, either via api.setSigner or via sign options. You possibly need to pass through an explicit keypair for the origin so it can be used for signing.');
          const payload = this.registry.createType('SignerPayload', _objectSpread(_objectSpread({}, options), {}, {
            address,
            blockNumber: header ? header.number : 0,
            method: this.method
          }));
          let result;

          if (signer.signPayload) {
            result = await signer.signPayload(payload.toPayload());
          } else if (signer.signRaw) {
            result = await signer.signRaw(payload.toRaw());
          } else {
            throw new Error('Invalid signer interface, it should implement either signPayload or signRaw (or both)');
          } // Here we explicitly call `toPayload()` again instead of working with an object
          // (reference) as passed to the signer. This means that we are sure that the
          // payload data is not modified from our inputs, but the signer


          super.addSignature(address, result.signature, payload.toPayload());
          return result.id;
        }
      });
      Object.defineProperty(this, _updateSigner, {
        writable: true,
        value: (updateId, status) => {
          if (updateId !== -1 && api.signer && api.signer.update) {
            api.signer.update(updateId, status);
          }
        }
      });
      (0, _classPrivateFieldLooseBase2.default)(this, _ignoreStatusCb)[_ignoreStatusCb] = apiType === 'rxjs';
    } // adds a transform to the result, applied before result is returned


    withResultTransform(transform) {
      (0, _classPrivateFieldLooseBase2.default)(this, _transformResult)[_transformResult] = transform;
      return this;
    } // calculate the payment info for this transaction (if signed and submitted)


    paymentInfo(account, optionsOrHash) {
      if ((0, _util.isString)(optionsOrHash) || (0, _util.isU8a)(optionsOrHash)) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return decorateMethod(() => api.rpc.payment.queryInfo(this.toHex(), optionsOrHash));
      }

      const [allOptions] = (0, _classPrivateFieldLooseBase2.default)(this, _makeSignAndSendOptions)[_makeSignAndSendOptions](optionsOrHash);

      const address = (0, _util2.isKeyringPair)(account) ? account.address : account.toString(); // eslint-disable-next-line @typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-call

      return decorateMethod(() => api.derive.tx.signingInfo(address, allOptions.nonce, allOptions.era).pipe((0, _operators.first)(), (0, _operators.switchMap)(signingInfo => {
        // setup our options (same way as in signAndSend)
        const eraOptions = (0, _classPrivateFieldLooseBase2.default)(this, _makeEraOptions)[_makeEraOptions](allOptions, signingInfo);

        const signOptions = (0, _classPrivateFieldLooseBase2.default)(this, _makeSignOptions)[_makeSignOptions](eraOptions, {}); // add a fake signature to the extrinsic


        this.signFake(address, signOptions);
        return api.rpc.payment.queryInfo(this.toHex());
      })))();
    }
    /**
     * @description Sign a transaction, returning the this to allow chaining, i.e. .sign(...).send(). When options, e.g. nonce/blockHash are not specified, it will be inferred. To retrieve eg. nonce use `signAsync` (the preferred interface, this is provided for backwards compatibility)
     * @deprecated
     */


    sign(account, optionsOrNonce) {
      super.sign(account, (0, _classPrivateFieldLooseBase2.default)(this, _makeSignOptions)[_makeSignOptions]((0, _classPrivateFieldLooseBase2.default)(this, _optionsOrNonce)[_optionsOrNonce](optionsOrNonce), {}));
      return this;
    }
    /**
     * @description Signs a transaction, returning `this` to allow chaining. E.g.: `sign(...).send()`. Like `.signAndSend` this will retrieve the nonce and blockHash to send the tx with.
     */


    signAsync(account, optionsOrNonce) {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-call
      return decorateMethod(() => (0, _classPrivateFieldLooseBase2.default)(this, _observeSign)[_observeSign](account, optionsOrNonce).pipe((0, _operators.mapTo)(this)))();
    } // signAndSend with an immediate Hash result


    // signAndSend implementation for all 3 cases above
    signAndSend(account, optionsOrStatus, optionalStatusCb) {
      const [options, statusCb] = (0, _classPrivateFieldLooseBase2.default)(this, _makeSignAndSendOptions)[_makeSignAndSendOptions](optionsOrStatus, optionalStatusCb);

      const isSubscription = api.hasSubscriptions && ((0, _classPrivateFieldLooseBase2.default)(this, _ignoreStatusCb)[_ignoreStatusCb] || !!statusCb); // eslint-disable-next-line @typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-call

      return decorateMethod(() => (0, _classPrivateFieldLooseBase2.default)(this, _observeSign)[_observeSign](account, options).pipe((0, _operators.switchMap)(updateId => isSubscription ? (0, _classPrivateFieldLooseBase2.default)(this, _observeSubscribe)[_observeSubscribe](updateId) : (0, _classPrivateFieldLooseBase2.default)(this, _observeSend)[_observeSend](updateId))) // FIXME This is wrong, SubmittableResult is _not_ a codec
      )(statusCb);
    } // send with an immediate Hash result


    // send implementation for both immediate Hash and statusCb variants
    send(statusCb) {
      const isSubscription = api.hasSubscriptions && ((0, _classPrivateFieldLooseBase2.default)(this, _ignoreStatusCb)[_ignoreStatusCb] || !!statusCb); // eslint-disable-next-line @typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-call

      return decorateMethod(isSubscription ? (0, _classPrivateFieldLooseBase2.default)(this, _observeSubscribe)[_observeSubscribe] : (0, _classPrivateFieldLooseBase2.default)(this, _observeSend)[_observeSend])(statusCb);
    }

  }), _temp;
}

/***/ }),

/***/ "../../node_modules/@polkadot/api/submittable/createSubmittable.js":
/*!******************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api/submittable/createSubmittable.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createSubmittable;

var _createClass = _interopRequireDefault(__webpack_require__(/*! ./createClass */ "../../node_modules/@polkadot/api/submittable/createClass.js"));

// Copyright 2017-2020 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0
function createSubmittable(apiType, api, decorateMethod) {
  const Submittable = (0, _createClass.default)({
    api,
    apiType,
    decorateMethod
  });
  return extrinsic => new Submittable(api.registry, extrinsic);
}

/***/ }),

/***/ "../../node_modules/@polkadot/api/submittable/index.js":
/*!******************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api/submittable/index.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "createSubmittable", {
  enumerable: true,
  get: function () {
    return _createSubmittable.default;
  }
});
Object.defineProperty(exports, "SubmittableResult", {
  enumerable: true,
  get: function () {
    return _Result.default;
  }
});

var _createSubmittable = _interopRequireDefault(__webpack_require__(/*! ./createSubmittable */ "../../node_modules/@polkadot/api/submittable/createSubmittable.js"));

var _Result = _interopRequireDefault(__webpack_require__(/*! ./Result */ "../../node_modules/@polkadot/api/submittable/Result.js"));

/***/ }),

/***/ "../../node_modules/@polkadot/api/util/augmentObject.js":
/*!*******************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api/util/augmentObject.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = augmentObject;

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

// Copyright 2017-2020 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0
const l = (0, _util.logger)('api/augment');

function logLength(type, values, and = []) {
  return values.length ? ` ${values.length} ${type}${and.length ? ' and' : ''}` : '';
}

function logValues(type, values) {
  return values.length ? `\n\t${type.padStart(7)}: ${values.sort().join(', ')}` : '';
} // log details to console


function warn(prefix, type, [added, removed]) {
  if (added.length || removed.length) {
    l.warn(`api.${prefix}: Found${logLength('added', added, removed)}${logLength('removed', removed)} ${type}:${logValues('added', added)}${logValues('removed', removed)}`);
  }
}

function extractKeys(src, dst) {
  return [Object.keys(src), Object.keys(dst)];
}

function findSectionExcludes(a, b) {
  return a.filter(section => !b.includes(section));
}

function extractSections(src, dst) {
  const [srcSections, dstSections] = extractKeys(src, dst);
  return [findSectionExcludes(srcSections, dstSections), findSectionExcludes(dstSections, srcSections)];
}

function findMethodExcludes(src, dst) {
  const srcSections = Object.keys(src);
  const dstSections = Object.keys(dst);
  return dstSections.filter(section => srcSections.includes(section)).reduce((rmMethods, section) => {
    const srcMethods = Object.keys(src[section]);
    return rmMethods.concat(...Object.keys(dst[section]).filter(method => !srcMethods.includes(method)).map(method => `${section}.${method}`));
  }, []);
}

function extractMethods(src, dst) {
  return [findMethodExcludes(dst, src), findMethodExcludes(src, dst)];
}
/**
 * Takes a decorated api section (e.g. api.tx) and augment it with the details. It does not override what is
 * already available, but rather just adds new missing ites into the result object.
 * @internal
 */


function augmentObject(prefix, src, dst, fromEmpty = false) {
  if (fromEmpty) {
    Object.keys(dst).forEach(key => {
      delete dst[key];
    });
  }

  if (prefix && Object.keys(dst).length) {
    warn(prefix, 'modules', extractSections(src, dst));
    warn(prefix, 'calls', extractMethods(src, dst));
  }

  return Object.keys(src).reduce((newSection, sectionName) => {
    const section = src[sectionName];
    newSection[sectionName] = Object.keys(section).reduce((result, methodName) => {
      // TODO When it does match, check the actual details and warn when there are differences
      if (!result[methodName]) {
        result[methodName] = section[methodName];
      }

      return result;
    }, dst[sectionName] || {});
    return newSection;
  }, dst);
}

/***/ }),

/***/ "../../node_modules/@polkadot/api/util/decorate.js":
/*!**************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api/util/decorate.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decorateSections = decorateSections;

// Copyright 2017-2020 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Most generic typings for `api.derive.*.*`
// Exact typings for a particular section `api.derive.section.*`
// Exact typings for all sections `api.derive.*.*`
// A technically unsafe version of Object.keys(obj) that assumes that
// obj only has known properties of T
function keys(obj) {
  return Object.keys(obj);
}
/**
 * This is a methods decorator which keeps all type information.
 */


function decorateMethods(section, decorateMethod) {
  return keys(section).reduce((acc, methodName) => {
    const method = section[methodName]; // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment

    acc[methodName] = decorateMethod(method);
    return acc;
  }, {});
}
/**
 * This is a section decorator which keeps all type information.
 */


function decorateSections(allSections, decorateMethod) {
  return keys(allSections).reduce((acc, sectionName) => {
    acc[sectionName] = decorateMethods(allSections[sectionName], decorateMethod);
    return acc;
  }, {});
}

/***/ }),

/***/ "../../node_modules/@polkadot/api/util/filterEvents.js":
/*!******************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api/util/filterEvents.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = filterEvents;

var _logging = _interopRequireDefault(__webpack_require__(/*! ./logging */ "../../node_modules/@polkadot/api/util/logging.js"));

// Copyright 2017-2020 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0
function filterEvents(extHash, {
  block: {
    extrinsics,
    header
  }
}, allEvents, status) {
  // extrinsics to hashes
  const myHash = extHash.toHex();
  const allHashes = extrinsics.map(ext => ext.hash.toHex()); // find the index of our extrinsic in the block

  const index = allHashes.indexOf(myHash); // if we do get the block after finalized, it _should_ be there

  if (index === -1) {
    // only warn on filtering with isInBlock (finalization finalizes after)
    if (status.isInBlock) {
      _logging.default.warn(`block ${header.hash.toHex()}: Unable to find extrinsic ${myHash} inside ${allHashes.join(', ')}`);
    }

    return;
  }

  return allEvents.filter(({
    phase
  }) => // only ApplyExtrinsic has the extrinsic index
  phase.isApplyExtrinsic && phase.asApplyExtrinsic.eqn(index));
}

/***/ }),

/***/ "../../node_modules/@polkadot/api/util/index.js":
/*!***********************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api/util/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  filterEvents: true,
  isKeyringPair: true,
  l: true
};
Object.defineProperty(exports, "filterEvents", {
  enumerable: true,
  get: function () {
    return _filterEvents.default;
  }
});
Object.defineProperty(exports, "isKeyringPair", {
  enumerable: true,
  get: function () {
    return _isKeyringPair.default;
  }
});
Object.defineProperty(exports, "l", {
  enumerable: true,
  get: function () {
    return _logging.default;
  }
});

var _decorate = __webpack_require__(/*! ./decorate */ "../../node_modules/@polkadot/api/util/decorate.js");

Object.keys(_decorate).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _decorate[key];
    }
  });
});

var _filterEvents = _interopRequireDefault(__webpack_require__(/*! ./filterEvents */ "../../node_modules/@polkadot/api/util/filterEvents.js"));

var _isKeyringPair = _interopRequireDefault(__webpack_require__(/*! ./isKeyringPair */ "../../node_modules/@polkadot/api/util/isKeyringPair.js"));

var _logging = _interopRequireDefault(__webpack_require__(/*! ./logging */ "../../node_modules/@polkadot/api/util/logging.js"));

/***/ }),

/***/ "../../node_modules/@polkadot/api/util/isKeyringPair.js":
/*!*******************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api/util/isKeyringPair.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isKeyringPair;

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

// Copyright 2017-2020 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0
function isKeyringPair(account) {
  return (0, _util.isFunction)(account.sign);
}

/***/ }),

/***/ "../../node_modules/@polkadot/api/util/logging.js":
/*!*************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api/util/logging.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

// Copyright 2017-2020 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0
const l = (0, _util.logger)('api/util');
var _default = l;
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/api/util/validate.js":
/*!**************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/api/util/validate.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractStorageArgs = extractStorageArgs;

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

// Copyright 2017-2019 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0
function sig({
  method,
  section
}, ...args) {
  return `${section}.${method}(${args.join(', ')})`;
}

function doDoubleMap(creator, args) {
  const {
    key1,
    key2
  } = creator.meta.type.asDoubleMap;
  (0, _util.assert)(args.length === 2, `${sig(creator, key1, key2)} is a doublemap, requiring 2 arguments, ${args.length} found`); // pass as tuple

  return [creator, args];
}

function doMap(creator, args) {
  const {
    key
  } = creator.meta.type.asMap;
  (0, _util.assert)(args.length === 1, `${sig(creator, key)} is a map, requiring 1 argument, ${args.length} found`); // expand

  return args.length ? [creator, args[0]] : [creator];
} // sets up the arguments in the form of [creator, args] ready to be used in a storage
// call. Additionally, it verifies that the correct number of arguments have been passed


function extractStorageArgs(creator, _args) {
  const args = _args.filter(arg => !(0, _util.isUndefined)(arg));

  if (creator.meta.type.isDoubleMap) {
    return doDoubleMap(creator, args);
  } else if (creator.meta.type.isMap) {
    return doMap(creator, args);
  }

  (0, _util.assert)(args.length === 0, `${sig(creator)} does not take any arguments, ${args.length} found`); // no args

  return [creator];
}

/***/ }),

/***/ "../../node_modules/@polkadot/metadata/Decorated/Decorated.js":
/*!*************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/metadata/Decorated/Decorated.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _Metadata = _interopRequireDefault(__webpack_require__(/*! ../Metadata */ "../../node_modules/@polkadot/metadata/Metadata/index.js"));

var _fromMetadata = _interopRequireDefault(__webpack_require__(/*! ./consts/fromMetadata */ "../../node_modules/@polkadot/metadata/Decorated/consts/fromMetadata/index.js"));

var _fromMetadata2 = _interopRequireDefault(__webpack_require__(/*! ./extrinsics/fromMetadata */ "../../node_modules/@polkadot/metadata/Decorated/extrinsics/fromMetadata/index.js"));

var _fromMetadata3 = _interopRequireDefault(__webpack_require__(/*! ./storage/fromMetadata */ "../../node_modules/@polkadot/metadata/Decorated/storage/fromMetadata/index.js"));

// Copyright 2017-2020 @polkadot/metadata authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * This class represents a decorated wrapper over the [[Metadata]]. The
 * [[Metadata]] type is a Codec type returned by the node, and `Decorated`
 * composes it and populates the `.query`, `.tx` and `.consts` sections.
 */
class Decorated {
  constructor(registry, value) {
    this.consts = void 0;
    this.metadata = void 0;
    this.registry = void 0;
    this.query = void 0;
    this.tx = void 0;
    (0, _util.assert)(value instanceof _Metadata.default, 'You need to pass a valid Metadata instance to Decorated');
    this.registry = registry;
    this.metadata = value; // decoration

    this.tx = (0, _fromMetadata2.default)(registry, this.metadata);
    this.query = (0, _fromMetadata3.default)(registry, this.metadata);
    this.consts = (0, _fromMetadata.default)(registry, this.metadata);
  }

}

exports.default = Decorated;

/***/ }),

/***/ "../../node_modules/@polkadot/metadata/Decorated/consts/fromMetadata/index.js":
/*!*****************************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/metadata/Decorated/consts/fromMetadata/index.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = fromMetadata;

var _create = __webpack_require__(/*! @polkadot/types/create */ "../../node_modules/@polkadot/types/create/index.js");

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

// Copyright 2017-2020 @polkadot/metadata authors & contributors
// SPDX-License-Identifier: Apache-2.0

/** @internal */
function fromMetadata(registry, metadata) {
  return metadata.asLatest.modules.reduce((result, moduleMetadata) => {
    if (moduleMetadata.constants.isEmpty) {
      return result;
    }

    const {
      name
    } = moduleMetadata; // For access, we change the index names, i.e. Democracy.EnactmentPeriod -> democracy.enactmentPeriod

    result[(0, _util.stringCamelCase)(name.toString())] = moduleMetadata.constants.reduce((newModule, meta) => {
      // convert to the natural type as received
      const type = meta.type.toString();
      const codec = (0, _create.createTypeUnsafe)(registry, type, [(0, _util.hexToU8a)(meta.value.toHex())]);
      codec.meta = meta;
      newModule[(0, _util.stringCamelCase)(meta.name.toString())] = codec;
      return newModule;
    }, {});
    return result;
  }, {});
}

/***/ }),

/***/ "../../node_modules/@polkadot/metadata/Decorated/extrinsics/fromMetadata/createUnchecked.js":
/*!*******************************************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/metadata/Decorated/extrinsics/fromMetadata/createUnchecked.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createDescriptor;

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

// Copyright 2017-2020 @polkadot/metadata authors & contributors
// SPDX-License-Identifier: Apache-2.0

/** @internal */
function createDescriptor(registry, section, sectionIndex, methodIndex, callMetadata) {
  const callIndex = new Uint8Array([sectionIndex, methodIndex]);
  const expectedArgs = callMetadata.args;
  const funcName = (0, _util.stringCamelCase)(callMetadata.name.toString());

  const extrinsicFn = (...args) => {
    (0, _util.assert)(expectedArgs.length.valueOf() === args.length, `Extrinsic ${section}.${funcName} expects ${expectedArgs.length.valueOf()} arguments, got ${args.length}.`);
    return registry.createType('Call', {
      args,
      callIndex
    }, callMetadata);
  };

  extrinsicFn.callIndex = callIndex;
  extrinsicFn.meta = callMetadata;
  extrinsicFn.method = funcName;
  extrinsicFn.section = section;

  extrinsicFn.toJSON = () => callMetadata.toJSON();

  return extrinsicFn;
}

/***/ }),

/***/ "../../node_modules/@polkadot/metadata/Decorated/extrinsics/fromMetadata/index.js":
/*!*********************************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/metadata/Decorated/extrinsics/fromMetadata/index.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = fromMetadata;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js"));

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _ = _interopRequireDefault(__webpack_require__(/*! ../ */ "../../node_modules/@polkadot/metadata/Decorated/extrinsics/index.js"));

var _createUnchecked = _interopRequireDefault(__webpack_require__(/*! ./createUnchecked */ "../../node_modules/@polkadot/metadata/Decorated/extrinsics/fromMetadata/createUnchecked.js"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/** @internal */
function fromMetadata(registry, metadata) {
  const modules = metadata.asLatest.modules;
  const isIndexed = modules.some(({
    index
  }) => !index.eqn(255));
  return modules.filter(({
    calls
  }) => calls.isSome).reduce((result, {
    calls,
    index,
    name
  }, _sectionIndex) => {
    const sectionIndex = isIndexed ? index.toNumber() : _sectionIndex;
    const section = (0, _util.stringCamelCase)(name.toString());
    result[section] = calls.unwrap().reduce((newModule, callMetadata, methodIndex) => {
      const method = (0, _util.stringCamelCase)(callMetadata.name.toString());
      newModule[method] = (0, _createUnchecked.default)(registry, section, sectionIndex, methodIndex, callMetadata);
      return newModule;
    }, {});
    return result;
  }, _objectSpread({}, _.default));
}

/***/ }),

/***/ "../../node_modules/@polkadot/metadata/Decorated/extrinsics/index.js":
/*!********************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/metadata/Decorated/extrinsics/index.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// Copyright 2017-2020 @polkadot/metadata authors & contributors
// SPDX-License-Identifier: Apache-2.0
const extrinsics = {};
var _default = extrinsics;
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/metadata/Decorated/index.js":
/*!*********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/metadata/Decorated/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Decorated = _interopRequireDefault(__webpack_require__(/*! ./Decorated */ "../../node_modules/@polkadot/metadata/Decorated/Decorated.js"));

// Copyright 2017-2020 @polkadot/metadata authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _default = _Decorated.default;
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/metadata/Decorated/storage/fromMetadata/createFunction.js":
/*!***************************************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/metadata/Decorated/storage/fromMetadata/createFunction.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createFunction;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js"));

var _codec = __webpack_require__(/*! @polkadot/types/codec */ "../../node_modules/@polkadot/types/codec/index.js");

var _create = __webpack_require__(/*! @polkadot/types/create */ "../../node_modules/@polkadot/types/create/index.js");

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _utilCrypto = __webpack_require__(/*! @polkadot/util-crypto */ "../../node_modules/@polkadot/util-crypto/index.js");

var _getHasher = _interopRequireDefault(__webpack_require__(/*! ./getHasher */ "../../node_modules/@polkadot/metadata/Decorated/storage/fromMetadata/getHasher.js"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const EMPTY_U8A = new Uint8Array([]);

const NULL_HASHER = value => value; // with the prefix, method & options, create both the string & raw keys

/** @internal */


function expandKey({
  method,
  prefix
}, options) {
  return options.key ? options.key : `${prefix} ${method}`;
} // get the hashers, the base (and  in the case of DoubleMap), the second key

/** @internal */


function getHashers({
  meta: {
    type
  }
}) {
  if (type.isDoubleMap) {
    return [(0, _getHasher.default)(type.asDoubleMap.hasher), (0, _getHasher.default)(type.asDoubleMap.key2Hasher)];
  } else if (type.isMap) {
    return [(0, _getHasher.default)(type.asMap.hasher)];
  } // the default


  return [(0, _getHasher.default)()];
} // create a base prefixed key

/** @internal */


function createPrefixedKey({
  method,
  prefix
}) {
  return (0, _util.u8aConcat)((0, _utilCrypto.xxhashAsU8a)(prefix, 128), (0, _utilCrypto.xxhashAsU8a)(method, 128));
} // create a key for a DoubleMap type

/** @internal */


function createKeyDoubleMap(registry, itemFn, stringKey, args, [hasher1, hasher2]) {
  const {
    meta: {
      name,
      type
    }
  } = itemFn; // since we are passing an almost-unknown through, trust, but verify

  (0, _util.assert)(Array.isArray(args) && !(0, _util.isUndefined)(args[0]) && !(0, _util.isNull)(args[0]) && !(0, _util.isUndefined)(args[1]) && !(0, _util.isNull)(args[1]), `${(name || 'unknown').toString()} is a DoubleMap and requires two arguments`); // if this fails, we have bigger issues

  (0, _util.assert)(!(0, _util.isUndefined)(hasher2), '2 hashing functions should be defined for DoubleMaps');
  const [key1, key2] = args;
  const map = type.asDoubleMap;
  const val1 = (0, _create.createTypeUnsafe)(registry, map.key1.toString(), [key1]).toU8a();
  const val2 = (0, _create.createTypeUnsafe)(registry, map.key2.toString(), [key2]).toU8a(); // as per createKey, always add the length prefix (underlying it is Bytes)

  return _codec.Compact.addLengthPrefix((0, _util.u8aConcat)(createPrefixedKey(itemFn), hasher1(val1), hasher2(val2)));
} // create a key for either a map or a plain value

/** @internal */


function createKey(registry, itemFn, stringKey, arg, hasher) {
  const {
    meta: {
      name,
      type
    }
  } = itemFn;
  let param = EMPTY_U8A;

  if (type.isMap) {
    const map = type.asMap;
    (0, _util.assert)(!(0, _util.isUndefined)(arg) && !(0, _util.isNull)(arg), `${name.toString()} is a Map and requires one argument`);
    param = (0, _create.createTypeUnsafe)(registry, map.key.toString(), [arg]).toU8a();
  } // StorageKey is a Bytes, so is length-prefixed


  return _codec.Compact.addLengthPrefix((0, _util.u8aConcat)(createPrefixedKey(itemFn), param.length ? hasher(param) : EMPTY_U8A));
} // attach the metadata to expand to a StorageFunction

/** @internal */


function expandWithMeta({
  meta,
  method,
  prefix,
  section
}, storageFn) {
  storageFn.meta = meta;
  storageFn.method = (0, _util.stringLowerFirst)(method);
  storageFn.prefix = prefix;
  storageFn.section = section; // explicitly add the actual method in the toJSON, this gets used to determine caching and without it
  // instances (e.g. collective) will not work since it is only matched on param meta

  storageFn.toJSON = () => _objectSpread(_objectSpread({}, meta.toJSON()), {}, {
    storage: {
      method,
      prefix,
      section
    }
  });

  return storageFn;
}
/** @internal */


function extendHeadMeta(registry, {
  meta: {
    documentation,
    name,
    type
  },
  section
}, {
  method
}, iterFn) {
  const outputType = type.isMap ? type.asMap.key.toString() : type.asDoubleMap.key1.toString(); // metadata with a fallback value using the type of the key, the normal
  // meta fallback only applies to actual entry values, create one for head

  iterFn.meta = registry.createType('StorageEntryMetadataLatest', {
    documentation,
    fallback: registry.createType('Bytes', (0, _create.createTypeUnsafe)(registry, outputType).toHex()),
    modifier: registry.createType('StorageEntryModifierLatest', 1),
    // required
    name,
    type: registry.createType('StorageEntryTypeLatest', registry.createType('Type', type.isMap ? type.asMap.key : type.asDoubleMap.key1), 0)
  });
  const prefixKey = registry.createType('StorageKey', iterFn, {
    method,
    section
  });
  return arg => !(0, _util.isUndefined)(arg) && !(0, _util.isNull)(arg) ? registry.createType('StorageKey', iterFn(arg), {
    method,
    section
  }) : prefixKey;
} // attach the full list hashing for prefixed maps

/** @internal */


function extendPrefixedMap(registry, itemFn, storageFn) {
  const {
    meta: {
      type
    }
  } = itemFn;
  storageFn.iterKey = extendHeadMeta(registry, itemFn, storageFn, arg => {
    (0, _util.assert)(type.isDoubleMap || (0, _util.isUndefined)(arg), 'Filtering arguments for keys/entries are only valid on double maps');
    return type.isDoubleMap && !(0, _util.isUndefined)(arg) && !(0, _util.isNull)(arg) ? new _codec.Raw(registry, (0, _util.u8aConcat)(createPrefixedKey(itemFn), (0, _getHasher.default)(type.asDoubleMap.hasher)(registry.createType(type.asDoubleMap.key1.toString(), arg).toU8a()))) : new _codec.Raw(registry, createPrefixedKey(itemFn));
  });
  return storageFn;
} // attach the full list hashing for double maps

/** @internal */


function extendDoubleMap(registry, itemFn, storageFn) {
  return extendPrefixedMap(registry, itemFn, storageFn);
}
/** @internal */


function createFunction(registry, itemFn, options) {
  const {
    meta: {
      type
    }
  } = itemFn;
  const stringKey = expandKey(itemFn, options);
  const [hasher, key2Hasher] = getHashers(itemFn); // Can only have zero or one argument:
  //   - storage.system.account(address)
  //   - storage.timestamp.blockPeriod()
  // For doublemap queries the params is passed in as an tuple, [key1, key2]

  const _storageFn = arg => type.isDoubleMap ? createKeyDoubleMap(registry, itemFn, stringKey, arg, [hasher, key2Hasher]) : createKey(registry, itemFn, stringKey, arg, options.skipHashing ? NULL_HASHER : hasher);

  const storageFn = expandWithMeta(itemFn, _storageFn);

  if (type.isMap) {
    extendPrefixedMap(registry, itemFn, storageFn);
  } else if (type.isDoubleMap) {
    extendDoubleMap(registry, itemFn, storageFn);
  }

  storageFn.keyPrefix = arg => storageFn.iterKey && storageFn.iterKey(arg) || (0, _util.compactStripLength)(storageFn())[1];

  return storageFn;
}

/***/ }),

/***/ "../../node_modules/@polkadot/metadata/Decorated/storage/fromMetadata/getHasher.js":
/*!**********************************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/metadata/Decorated/storage/fromMetadata/getHasher.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getHasher;

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _utilCrypto = __webpack_require__(/*! @polkadot/util-crypto */ "../../node_modules/@polkadot/util-crypto/index.js");

// Copyright 2017-2020 @polkadot/metadata authors & contributors
// SPDX-License-Identifier: Apache-2.0
const DEFAULT_FN = data => (0, _utilCrypto.xxhashAsU8a)(data, 128);

const HASHERS = {
  Blake2_128: data => // eslint-disable-line camelcase
  (0, _utilCrypto.blake2AsU8a)(data, 128),
  Blake2_128Concat: data => // eslint-disable-line camelcase
  (0, _util.u8aConcat)((0, _utilCrypto.blake2AsU8a)(data, 128), (0, _util.u8aToU8a)(data)),
  Blake2_256: data => // eslint-disable-line camelcase
  (0, _utilCrypto.blake2AsU8a)(data, 256),
  Identity: data => (0, _util.u8aToU8a)(data),
  Twox128: data => (0, _utilCrypto.xxhashAsU8a)(data, 128),
  Twox256: data => (0, _utilCrypto.xxhashAsU8a)(data, 256),
  Twox64Concat: data => (0, _util.u8aConcat)((0, _utilCrypto.xxhashAsU8a)(data, 64), (0, _util.u8aToU8a)(data))
};
/** @internal */

function getHasher(hasher) {
  return HASHERS[hasher === null || hasher === void 0 ? void 0 : hasher.type] || DEFAULT_FN;
}

/***/ }),

/***/ "../../node_modules/@polkadot/metadata/Decorated/storage/fromMetadata/index.js":
/*!******************************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/metadata/Decorated/storage/fromMetadata/index.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = fromMetadata;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js"));

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _createFunction = _interopRequireDefault(__webpack_require__(/*! ./createFunction */ "../../node_modules/@polkadot/metadata/Decorated/storage/fromMetadata/createFunction.js"));

var _storage = _interopRequireDefault(__webpack_require__(/*! ./storage */ "../../node_modules/@polkadot/metadata/Decorated/storage/fromMetadata/storage.js"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/** @internal */
function fromMetadata(registry, metadata) {
  return metadata.asLatest.modules.reduce((result, moduleMetadata) => {
    if (moduleMetadata.storage.isNone) {
      return result;
    }

    const {
      name
    } = moduleMetadata;
    const section = (0, _util.stringCamelCase)(name.toString());
    const unwrapped = moduleMetadata.storage.unwrap();
    const prefix = unwrapped.prefix.toString(); // For access, we change the index names, i.e. System.Account -> system.account

    result[section] = unwrapped.items.reduce((newModule, meta) => {
      const method = meta.name.toString();
      newModule[(0, _util.stringLowerFirst)(method)] = (0, _createFunction.default)(registry, {
        meta,
        method,
        prefix,
        section
      }, {
        metaVersion: metadata.version
      });
      return newModule;
    }, {});
    return result;
  }, _objectSpread({}, (0, _storage.default)(registry, metadata.version)));
}

/***/ }),

/***/ "../../node_modules/@polkadot/metadata/Decorated/storage/fromMetadata/storage.js":
/*!********************************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/metadata/Decorated/storage/fromMetadata/storage.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "../../node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getStorage;

var substrate = _interopRequireWildcard(__webpack_require__(/*! ./substrate */ "../../node_modules/@polkadot/metadata/Decorated/storage/fromMetadata/substrate.js"));

// Copyright 2017-2020 @polkadot/metadata authors & contributors
// SPDX-License-Identifier: Apache-2.0

/** @internal */
function getStorage(registry, metaVersion) {
  return {
    substrate: Object.entries(substrate).reduce((storage, [key, fn]) => {
      storage[key] = fn(registry, metaVersion);
      return storage;
    }, {})
  };
}

/***/ }),

/***/ "../../node_modules/@polkadot/metadata/Decorated/storage/fromMetadata/substrate.js":
/*!**********************************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/metadata/Decorated/storage/fromMetadata/substrate.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.childStorageKeyPrefix = exports.changesTrieConfig = exports.extrinsicIndex = exports.heapPages = exports.code = void 0;

var _createFunction = _interopRequireDefault(__webpack_require__(/*! ./createFunction */ "../../node_modules/@polkadot/metadata/Decorated/storage/fromMetadata/createFunction.js"));

// Copyright 2017-2020 @polkadot/metadata authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Small helper function to factorize code on this page.

/** @internal */
function createRuntimeFunction(method, key, {
  documentation,
  type
}) {
  return (registry, metaVersion) => (0, _createFunction.default)(registry, {
    meta: {
      documentation: registry.createType('Vec<Text>', [documentation]),
      modifier: registry.createType('StorageEntryModifierLatest', 1),
      // required
      toJSON: () => key,
      type: registry.createType('StorageEntryTypeLatest', type, 0)
    },
    method,
    prefix: 'Substrate',
    section: 'substrate'
  }, {
    key,
    metaVersion,
    skipHashing: true
  });
}

const code = createRuntimeFunction('code', ':code', {
  documentation: 'Wasm code of the runtime.',
  type: 'Bytes'
});
exports.code = code;
const heapPages = createRuntimeFunction('heapPages', ':heappages', {
  documentation: 'Number of wasm linear memory pages required for execution of the runtime.',
  type: 'u64'
});
exports.heapPages = heapPages;
const extrinsicIndex = createRuntimeFunction('extrinsicIndex', ':extrinsic_index', {
  documentation: 'Current extrinsic index (u32) is stored under this key.',
  type: 'u32'
});
exports.extrinsicIndex = extrinsicIndex;
const changesTrieConfig = createRuntimeFunction('changesTrieConfig', ':changes_trie', {
  documentation: 'Changes trie configuration is stored under this key.',
  type: 'u32'
});
exports.changesTrieConfig = changesTrieConfig;
const childStorageKeyPrefix = createRuntimeFunction('childStorageKeyPrefix', ':child_storage:', {
  documentation: 'Prefix of child storage keys.',
  type: 'u32'
});
exports.childStorageKeyPrefix = childStorageKeyPrefix;

/***/ }),

/***/ "../../node_modules/@polkadot/metadata/Metadata/MagicNumber.js":
/*!**************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/metadata/Metadata/MagicNumber.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.MAGIC_NUMBER = void 0;

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _U = _interopRequireDefault(__webpack_require__(/*! @polkadot/types/primitive/U32 */ "../../node_modules/@polkadot/types/primitive/U32.js"));

// Copyright 2017-2020 @polkadot/metadata authors & contributors
// SPDX-License-Identifier: Apache-2.0
const MAGIC_NUMBER = 0x6174656d; // `meta`, reversed for Little Endian encoding

exports.MAGIC_NUMBER = MAGIC_NUMBER;

class MagicNumber extends _U.default {
  constructor(registry, value) {
    super(registry, value);

    if (!this.isEmpty) {
      const magic = registry.createType('u32', MAGIC_NUMBER);
      (0, _util.assert)(this.eq(magic), `MagicNumber mismatch: expected ${magic.toHex()}, found ${this.toHex()}`);
    }
  }

}

exports.default = MagicNumber;

/***/ }),

/***/ "../../node_modules/@polkadot/metadata/Metadata/Metadata.js":
/*!***********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/metadata/Metadata/Metadata.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _MetadataVersioned = _interopRequireDefault(__webpack_require__(/*! ./MetadataVersioned */ "../../node_modules/@polkadot/metadata/Metadata/MetadataVersioned.js"));

// Copyright 2017-2020 @polkadot/metadata authors & contributors
// SPDX-License-Identifier: Apache-2.0
// magic u32 preceding the version id
const VERSION_IDX = 4; // magic + lowest supported version

const EMPTY_METADATA = (0, _util.u8aConcat)(new Uint8Array([0x6d, 0x65, 0x74, 0x61, 9]));
const EMPTY_U8A = new Uint8Array();

function sanitizeInput(_value = EMPTY_U8A) {
  if ((0, _util.isString)(_value)) {
    return sanitizeInput((0, _util.u8aToU8a)(_value));
  }

  return _value.length === 0 ? EMPTY_METADATA : _value;
}

function decodeMetadata(registry, _value) {
  const value = sanitizeInput(_value);
  const version = value[VERSION_IDX];

  try {
    return new _MetadataVersioned.default(registry, value);
  } catch (error) {
    // This is an f-ing hack as a follow-up to another ugly hack
    // https://github.com/polkadot-js/api/commit/a9211690be6b68ad6c6dad7852f1665cadcfa5b2
    // when we fail on V9, try to re-parse it as v10... yes... HACK
    if (version === 9) {
      value[VERSION_IDX] = 10;
      return decodeMetadata(registry, value);
    }

    throw error;
  }
}
/**
 * @name Metadata
 * @description
 * The versioned runtime metadata as a decoded structure
 */


class Metadata extends _MetadataVersioned.default {
  constructor(registry, value) {
    super(registry, decodeMetadata(registry, value));
  }

}

exports.default = Metadata;

/***/ }),

/***/ "../../node_modules/@polkadot/metadata/Metadata/MetadataVersioned.js":
/*!********************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/metadata/Metadata/MetadataVersioned.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classPrivateFieldLooseBase2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classPrivateFieldLooseBase */ "../../node_modules/@babel/runtime/helpers/classPrivateFieldLooseBase.js"));

var _classPrivateFieldLooseKey2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classPrivateFieldLooseKey */ "../../node_modules/@babel/runtime/helpers/classPrivateFieldLooseKey.js"));

var _Struct = _interopRequireDefault(__webpack_require__(/*! @polkadot/types/codec/Struct */ "../../node_modules/@polkadot/types/codec/Struct.js"));

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _MagicNumber = _interopRequireDefault(__webpack_require__(/*! ./MagicNumber */ "../../node_modules/@polkadot/metadata/Metadata/MagicNumber.js"));

var _toV = _interopRequireDefault(__webpack_require__(/*! ./v9/toV10 */ "../../node_modules/@polkadot/metadata/Metadata/v9/toV10.js"));

var _toV2 = _interopRequireDefault(__webpack_require__(/*! ./v10/toV11 */ "../../node_modules/@polkadot/metadata/Metadata/v10/toV11.js"));

var _toV3 = _interopRequireDefault(__webpack_require__(/*! ./v11/toV12 */ "../../node_modules/@polkadot/metadata/Metadata/v11/toV12.js"));

var _toLatest = _interopRequireDefault(__webpack_require__(/*! ./v12/toLatest */ "../../node_modules/@polkadot/metadata/Metadata/v12/toLatest.js"));

var _util2 = __webpack_require__(/*! ./util */ "../../node_modules/@polkadot/metadata/Metadata/util/index.js");

// Copyright 2017-2020 @polkadot/metadata authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _converted = (0, _classPrivateFieldLooseKey2.default)("converted");

/**
 * @name MetadataVersioned
 * @description
 * The versioned runtime metadata as a decoded structure
 */
class MetadataVersioned extends _Struct.default {
  constructor(registry, value) {
    super(registry, {
      magicNumber: _MagicNumber.default,
      metadata: 'MetadataAll'
    }, value);
    Object.defineProperty(this, _converted, {
      writable: true,
      value: new Map()
    });
  }

  _assertVersion(version) {
    (0, _util.assert)(this.version <= version, `Cannot convert metadata from v${this.version} to v${version}`);
    return this.version === version;
  }

  _getVersion(version, fromPrev) {
    const asCurr = `asV${version}`;
    const asPrev = `asV${version - 1}`;

    if (this._assertVersion(version)) {
      return this._metadata[asCurr];
    }

    if (!(0, _classPrivateFieldLooseBase2.default)(this, _converted)[_converted].has(version)) {
      (0, _classPrivateFieldLooseBase2.default)(this, _converted)[_converted].set(version, fromPrev(this.registry, this[asPrev]));
    }

    return (0, _classPrivateFieldLooseBase2.default)(this, _converted)[_converted].get(version);
  }
  /**
   * @description Returns the wrapped metadata as a limited calls-only (latest) version
   */


  get asCallsOnly() {
    return new MetadataVersioned(this.registry, {
      magicNumber: this.magicNumber,
      metadata: this.registry.createType('MetadataAll', (0, _util2.toCallsOnly)(this.registry, this.asLatest), this.version)
    });
  }
  /**
   * @description Returns the wrapped metadata as a V1 object
   */


  get asV9() {
    this._assertVersion(9);

    return this._metadata.asV9;
  }
  /**
   * @description Returns the wrapped values as a V10 object
   */


  get asV10() {
    return this._getVersion(10, _toV.default);
  }
  /**
   * @description Returns the wrapped values as a V10 object
   */


  get asV11() {
    return this._getVersion(11, _toV2.default);
  }
  /**
   * @description Returns the wrapped values as a V10 object
   */


  get asV12() {
    return this._getVersion(12, _toV3.default);
  }
  /**
   * @description Returns the wrapped values as a latest version object
   */


  get asLatest() {
    // This is non-existent & latest - applied here to do the module-specific type conversions
    return this._getVersion(13, _toLatest.default);
  }
  /**
   * @description
   */


  get magicNumber() {
    return this.get('magicNumber');
  }
  /**
   * @description the metadata wrapped
   */


  get _metadata() {
    return this.get('metadata');
  }
  /**
   * @description the metadata version this structure represents
   */


  get version() {
    return this._metadata.index;
  }

  getUniqTypes(throwError) {
    return (0, _util2.getUniqTypes)(this.registry, this.asLatest, throwError);
  }

}

exports.default = MetadataVersioned;

/***/ }),

/***/ "../../node_modules/@polkadot/metadata/Metadata/index.js":
/*!********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/metadata/Metadata/index.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Metadata = _interopRequireDefault(__webpack_require__(/*! ./Metadata */ "../../node_modules/@polkadot/metadata/Metadata/Metadata.js"));

// Copyright 2017-2020 @polkadot/metadata authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _default = _Metadata.default;
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/metadata/Metadata/util/extractTypes.js":
/*!********************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/metadata/Metadata/util/extractTypes.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = extractTypes;

var _types = __webpack_require__(/*! @polkadot/types/types */ "../../node_modules/@polkadot/types/types/index.js");

var _create = __webpack_require__(/*! @polkadot/types/create */ "../../node_modules/@polkadot/types/create/index.js");

// Copyright 2017-2020 @polkadot/metadata authors & contributors
// SPDX-License-Identifier: Apache-2.0

/** @internal */
function extractTypes(types) {
  return types.map(type => {
    const decoded = (0, _create.getTypeDef)(type);

    switch (decoded.info) {
      case _types.TypeDefInfo.Plain:
        return decoded.type;

      case _types.TypeDefInfo.BTreeSet:
      case _types.TypeDefInfo.Compact:
      case _types.TypeDefInfo.Option:
      case _types.TypeDefInfo.Vec:
      case _types.TypeDefInfo.VecFixed:
        return extractTypes([decoded.sub.type]);

      case _types.TypeDefInfo.BTreeMap:
      case _types.TypeDefInfo.HashMap:
      case _types.TypeDefInfo.Result:
      case _types.TypeDefInfo.Tuple:
        return extractTypes(decoded.sub.map(sub => sub.type));

      default:
        throw new Error(`Unhandled: Unable to create and validate type from ${type}`);
    }
  });
}

/***/ }),

/***/ "../../node_modules/@polkadot/metadata/Metadata/util/flattenUniq.js":
/*!*******************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/metadata/Metadata/util/flattenUniq.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = flattenUniq;

// Copyright 2017-2020 @polkadot/metadata authors & contributors
// SPDX-License-Identifier: Apache-2.0

/** @internal */
function flattenUniq(list) {
  const flat = list.reduce((result, entry) => {
    return result.concat(Array.isArray(entry) ? flattenUniq(entry) : entry);
  }, []);
  return [...new Set(flat)].filter(value => value).sort();
}

/***/ }),

/***/ "../../node_modules/@polkadot/metadata/Metadata/util/getUniqTypes.js":
/*!********************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/metadata/Metadata/util/getUniqTypes.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getUniqTypes;

var _flattenUniq = _interopRequireDefault(__webpack_require__(/*! ./flattenUniq */ "../../node_modules/@polkadot/metadata/Metadata/util/flattenUniq.js"));

var _validateTypes = _interopRequireDefault(__webpack_require__(/*! ./validateTypes */ "../../node_modules/@polkadot/metadata/Metadata/util/validateTypes.js"));

// Copyright 2017-2020 @polkadot/metadata authors & contributors
// SPDX-License-Identifier: Apache-2.0

/** @internal */
function unwrapCalls(mod) {
  return mod.calls ? mod.calls.unwrapOr([]) // V0
  : mod.module ? mod.module.call.functions : [];
}
/** @internal */


function getCallNames({
  modules
}) {
  return modules.map(mod => unwrapCalls(mod).map(({
    args
  }) => args.map(arg => arg.type.toString())));
}
/** @internal */


function getConstantNames({
  modules
}) {
  return modules.map(({
    constants
  }) => constants ? constants.map(constant => constant.type.toString()) : []);
}
/** @internal */


function unwrapEvents(events) {
  if (!events) {
    return [];
  }

  return events.unwrapOr([]);
}
/** @internal */


function getEventNames({
  modules,
  outerEvent
}) {
  const mapArg = ({
    args
  }) => args.map(arg => arg.toString()); // V0


  if (outerEvent) {
    return outerEvent.events.map(([, events]) => events.map(mapArg));
  } // V1+


  return modules.map(({
    events
  }) => unwrapEvents(events).map(mapArg));
}
/** @internal */


function unwrapStorage(storage) {
  if (!storage) {
    return [];
  }

  const data = storage.unwrapOr([]);
  return Array.isArray(data) ? data : data.items || data.functions;
}
/** @internal */


function getStorageNames({
  modules
}) {
  return modules.map(({
    storage
  }) => unwrapStorage(storage).map(({
    type
  }) => {
    if (type.isDoubleMap && type.asDoubleMap) {
      return [type.asDoubleMap.key1.toString(), type.asDoubleMap.key2.toString(), type.asDoubleMap.value.toString()];
    } else if (type.isMap) {
      return [type.asMap.key.toString(), type.asMap.value.toString()];
    } else {
      return [type.asPlain.toString()];
    }
  }));
}
/** @internal */


function getUniqTypes(registry, meta, throwError) {
  const types = (0, _flattenUniq.default)([getCallNames(meta), getConstantNames(meta), getEventNames(meta), getStorageNames(meta)]);
  (0, _validateTypes.default)(registry, types, throwError);
  return types;
}

/***/ }),

/***/ "../../node_modules/@polkadot/metadata/Metadata/util/index.js":
/*!*************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/metadata/Metadata/util/index.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "flattenUniq", {
  enumerable: true,
  get: function () {
    return _flattenUniq.default;
  }
});
Object.defineProperty(exports, "getUniqTypes", {
  enumerable: true,
  get: function () {
    return _getUniqTypes.default;
  }
});
Object.defineProperty(exports, "toCallsOnly", {
  enumerable: true,
  get: function () {
    return _toCallsOnly.default;
  }
});
Object.defineProperty(exports, "validateTypes", {
  enumerable: true,
  get: function () {
    return _validateTypes.default;
  }
});

var _flattenUniq = _interopRequireDefault(__webpack_require__(/*! ./flattenUniq */ "../../node_modules/@polkadot/metadata/Metadata/util/flattenUniq.js"));

var _getUniqTypes = _interopRequireDefault(__webpack_require__(/*! ./getUniqTypes */ "../../node_modules/@polkadot/metadata/Metadata/util/getUniqTypes.js"));

var _toCallsOnly = _interopRequireDefault(__webpack_require__(/*! ./toCallsOnly */ "../../node_modules/@polkadot/metadata/Metadata/util/toCallsOnly.js"));

var _validateTypes = _interopRequireDefault(__webpack_require__(/*! ./validateTypes */ "../../node_modules/@polkadot/metadata/Metadata/util/validateTypes.js"));

/***/ }),

/***/ "../../node_modules/@polkadot/metadata/Metadata/util/toCallsOnly.js":
/*!*******************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/metadata/Metadata/util/toCallsOnly.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = toCallsOnly;

// Copyright 2017-2020 @polkadot/metadata authors & contributors
// SPDX-License-Identifier: Apache-2.0
function trimDocs(documentation) {
  const strings = documentation.map(doc => doc.toString().trim());
  const firstEmpty = strings.findIndex(doc => !doc.length);
  return firstEmpty === -1 ? strings : strings.slice(0, firstEmpty);
}

function mapCalls(registry, _calls) {
  const calls = _calls.unwrapOr(null);

  return registry.createType('Option<Vec<FunctionMetadataLatest>>', calls ? calls.map(({
    args,
    documentation,
    name
  }) => registry.createType('FunctionMetadataLatest', {
    args,
    documentation: trimDocs(documentation),
    name
  })) : null);
}
/** @internal */


function toCallsOnly(registry, {
  extrinsic,
  modules
}) {
  return registry.createType('MetadataLatest', {
    extrinsic,
    modules: modules.map(({
      calls,
      index,
      name
    }) => ({
      calls: mapCalls(registry, calls),
      index,
      name
    }))
  }).toJSON();
}

/***/ }),

/***/ "../../node_modules/@polkadot/metadata/Metadata/util/validateTypes.js":
/*!*********************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/metadata/Metadata/util/validateTypes.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = validateTypes;

var _extractTypes = _interopRequireDefault(__webpack_require__(/*! ./extractTypes */ "../../node_modules/@polkadot/metadata/Metadata/util/extractTypes.js"));

var _flattenUniq = _interopRequireDefault(__webpack_require__(/*! ./flattenUniq */ "../../node_modules/@polkadot/metadata/Metadata/util/flattenUniq.js"));

// Copyright 2017-2020 @polkadot/metadata authors & contributors
// SPDX-License-Identifier: Apache-2.0

/** @internal */
function validateTypes(registry, types, throwError) {
  const missing = (0, _flattenUniq.default)((0, _extractTypes.default)(types)).filter(type => !registry.hasType(type));

  if (missing.length !== 0) {
    const message = `Unknown types found, no types for ${missing.join(', ')}`;

    if (throwError) {
      throw new Error(message);
    } else {
      console.warn(message);
    }
  }
}

/***/ }),

/***/ "../../node_modules/@polkadot/metadata/Metadata/v10/toV11.js":
/*!************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/metadata/Metadata/v10/toV11.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = toV11;

// Copyright 2017-2020 @polkadot/metadata authors & contributors
// SPDX-License-Identifier: Apache-2.0

/** @internal */
function toV11(registry, {
  modules
}) {
  return registry.createType('MetadataV11', {
    // This is new in V11, pass V0 here - something non-existing, telling the API to use
    // the fallback for this information (on-chain detection)
    extrinsic: {
      signedExtensions: [],
      version: 0
    },
    modules
  });
}

/***/ }),

/***/ "../../node_modules/@polkadot/metadata/Metadata/v11/toV12.js":
/*!************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/metadata/Metadata/v11/toV12.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = toV12;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Copyright 2017-2020 @polkadot/metadata authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @internal
 **/
function toV12(registry, {
  extrinsic,
  modules
}) {
  return registry.createType('MetadataLatest', {
    extrinsic,
    modules: modules.map(mod => registry.createType('ModuleMetadataV12', _objectSpread(_objectSpread({}, mod), {}, {
      index: 255
    })))
  });
}

/***/ }),

/***/ "../../node_modules/@polkadot/metadata/Metadata/v12/toLatest.js":
/*!***************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/metadata/Metadata/v12/toLatest.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = toLatest;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js"));

var _typesKnown = __webpack_require__(/*! @polkadot/types-known */ "../../node_modules/@polkadot/types-known/index.js");

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Since we don't have insight into the origin specification, we can only define what we know about
// in a pure Substrate/Polkadot implementation, any other custom origins won't be handled at all
const KNOWN_ORIGINS = {
  Council: 'CollectiveOrigin',
  System: 'SystemOrigin',
  TechnicalCommittee: 'CollectiveOrigin'
}; // TODO Handle consts as well

/**
 * Find and apply the correct type override
 * @internal
 **/

function setTypeOverride(sectionTypes, type) {
  const override = Object.keys(sectionTypes).find(aliased => type.eq(aliased));

  if (override) {
    type.setOverride(sectionTypes[override]);
  } else {
    // FIXME: NOT happy with this approach, but gets over the initial hump cased by (Vec<Announcement>,BalanceOf)
    const orig = type.toString();
    const alias = Object.entries(sectionTypes).reduce((result, [from, to]) => [['<', '>'], ['<', ','], [',', '>'], ['(', ')'], ['(', ','], [',', ','], [',', ')']].reduce((result, [one, two]) => result.replace(`${one}${from}${two}`, `${one}${to}${two}`), result), orig);

    if (orig !== alias) {
      type.setOverride(alias);
    }
  }
}
/**
 * Apply module-specific type overrides (always be done as part of toLatest)
 * @internal
 **/


function convertCalls(registry, calls, sectionTypes) {
  return calls.map(({
    args,
    documentation,
    name
  }) => {
    args.forEach(({
      type
    }) => setTypeOverride(sectionTypes, type));
    return registry.createType('FunctionMetadataLatest', {
      args,
      documentation,
      name
    });
  });
}
/**
 * Apply module-specific type overrides (always be done as part of toLatest)
 * @internal
 **/


function convertEvents(registry, events, sectionTypes) {
  return events.map(({
    args,
    documentation,
    name
  }) => {
    args.forEach(type => setTypeOverride(sectionTypes, type));
    return registry.createType('EventMetadataLatest', {
      args,
      documentation,
      name
    });
  });
}
/**
 * Apply module-specific storage type overrides (always part of toLatest)
 * @internal
 **/


function convertStorage(registry, {
  items,
  prefix
}, sectionTypes) {
  return registry.createType('StorageMetadataLatest', {
    items: items.map(({
      documentation,
      fallback,
      modifier,
      name,
      type
    }) => {
      let resultType;

      if (type.isMap) {
        resultType = type.asMap.value;
      } else if (type.isDoubleMap) {
        resultType = type.asDoubleMap.value;
      } else {
        resultType = type.asPlain;
      }

      setTypeOverride(sectionTypes, resultType);
      return registry.createType('StorageEntryMetadataLatest', {
        documentation,
        fallback,
        modifier,
        name,
        type
      });
    }),
    prefix
  });
} // generate & register the OriginCaller type


function registerOriginCaller(registry, modules) {
  const isIndexed = modules.some(({
    index
  }) => !index.eqn(255));
  registry.register({
    OriginCaller: {
      _enum: modules.map((mod, index) => [mod.name.toString(), isIndexed ? mod.index.toNumber() : index]).sort((a, b) => a[1] - b[1]).reduce((result, [name, index]) => {
        for (let i = Object.keys(result).length; i < index; i++) {
          result[`Empty${i}`] = 'Null';
        }

        result[name] = KNOWN_ORIGINS[name] || 'Null';
        return result;
      }, {})
    }
  });
}
/**
 * Convert the Metadata (which is an alias) to latest - effectively this _always_ get applied to the top-level &
 * most-recent metadata, since it allows us a chance to actually apply call and storage specific type aliasses
 * @internal
 **/


function toLatest(registry, {
  extrinsic,
  modules
}) {
  registerOriginCaller(registry, modules);
  return registry.createType('MetadataLatest', {
    extrinsic,
    modules: modules.map(mod => {
      const calls = mod.calls.unwrapOr(null);
      const events = mod.events.unwrapOr(null);
      const storage = mod.storage.unwrapOr(null);
      const sectionTypes = (0, _typesKnown.getModuleTypes)(registry, (0, _util.stringCamelCase)(mod.name.toString()));
      return registry.createType('ModuleMetadataLatest', _objectSpread(_objectSpread({}, mod), {}, {
        calls: calls ? convertCalls(registry, calls, sectionTypes) : null,
        events: events ? convertEvents(registry, events, sectionTypes) : null,
        storage: storage ? convertStorage(registry, storage, sectionTypes) : null
      }));
    })
  });
}

/***/ }),

/***/ "../../node_modules/@polkadot/metadata/Metadata/v9/toV10.js":
/*!***********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/metadata/Metadata/v9/toV10.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = toV10;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Copyright 2017-2020 @polkadot/metadata authors & contributors
// SPDX-License-Identifier: Apache-2.0
// migrate a storage hasher type
// see https://github.com/paritytech/substrate/pull/4462

/** @internal */
function createStorageHasher(registry, hasher) {
  // Blake2_128_Concat has been added at index 2, so we increment all the
  // indexes greater than 2
  if (hasher.toNumber() >= 2) {
    return registry.createType('StorageHasherV10', hasher.toNumber() + 1);
  }

  return registry.createType('StorageHasherV10', hasher);
}
/** @internal */


function createStorageType(registry, entryType) {
  if (entryType.isMap) {
    return [_objectSpread(_objectSpread({}, entryType.asMap), {}, {
      hasher: createStorageHasher(registry, entryType.asMap.hasher)
    }), 1];
  }

  if (entryType.isDoubleMap) {
    return [_objectSpread(_objectSpread({}, entryType.asDoubleMap), {}, {
      hasher: createStorageHasher(registry, entryType.asDoubleMap.hasher),
      key2Hasher: createStorageHasher(registry, entryType.asDoubleMap.key2Hasher)
    }), 2];
  }

  return [entryType.asPlain, 0];
}
/** @internal */


function convertModule(registry, mod) {
  const storage = mod.storage.unwrapOr(null);
  return registry.createType('ModuleMetadataV10', _objectSpread(_objectSpread({}, mod), {}, {
    storage: storage ? _objectSpread(_objectSpread({}, storage), {}, {
      items: storage.items.map(item => _objectSpread(_objectSpread({}, item), {}, {
        type: registry.createType('StorageEntryTypeV10', ...createStorageType(registry, item.type))
      }))
    }) : null
  }));
}
/** @internal */


function toV10(registry, {
  modules
}) {
  return registry.createType('MetadataV10', {
    modules: modules.map(mod => convertModule(registry, mod))
  });
}

/***/ }),

/***/ "../../node_modules/@polkadot/rpc-core/index.js":
/*!***********************************************************!*\
  !*** /root/apps/node_modules/@polkadot/rpc-core/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js"));

var _classPrivateFieldLooseBase2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classPrivateFieldLooseBase */ "../../node_modules/@babel/runtime/helpers/classPrivateFieldLooseBase.js"));

var _classPrivateFieldLooseKey2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classPrivateFieldLooseKey */ "../../node_modules/@babel/runtime/helpers/classPrivateFieldLooseKey.js"));

var _memoizee = _interopRequireDefault(__webpack_require__(/*! memoizee */ "../../node_modules/memoizee/index.js"));

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _jsonrpc = _interopRequireDefault(__webpack_require__(/*! @polkadot/types/interfaces/jsonrpc */ "../../node_modules/@polkadot/types/interfaces/jsonrpc.js"));

var _types = __webpack_require__(/*! @polkadot/types */ "../../node_modules/@polkadot/types/index.js");

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _rxjs2 = __webpack_require__(/*! ./rxjs */ "../../node_modules/@polkadot/rpc-core/rxjs/index.js");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const l = (0, _util.logger)('rpc-core');
const EMPTY_META = {
  fallback: undefined,
  modifier: {
    isOptional: true
  },
  type: {
    asMap: {
      linked: {
        isTrue: false
      }
    },
    isMap: false
  }
}; // utility method to create a nicely-formatted error

/** @internal */

function logErrorMessage(method, {
  params,
  type
}, error) {
  const inputs = params.map(({
    isOptional,
    name,
    type
  }) => `${name}${isOptional ? '?' : ''}: ${type}`).join(', ');
  l.error(`${method}(${inputs}): ${type}:: ${error.message}`);
}
/**
 * @name Rpc
 * @summary The API may use a HTTP or WebSockets provider.
 * @description It allows for querying a Polkadot Client Node.
 * WebSockets provider is recommended since HTTP provider only supports basic querying.
 *
 * ```mermaid
 * graph LR;
 *   A[Api] --> |WebSockets| B[WsProvider];
 *   B --> |endpoint| C[ws://127.0.0.1:9944]
 * ```
 *
 * @example
 * <BR>
 *
 * ```javascript
 * import Rpc from '@polkadot/rpc-core';
 * import WsProvider from '@polkadot/rpc-provider/ws';
 *
 * const provider = new WsProvider('ws://127.0.0.1:9944');
 * const rpc = new Rpc(provider);
 * ```
 */


var _instanceId = (0, _classPrivateFieldLooseKey2.default)("instanceId");

var _registryDefault = (0, _classPrivateFieldLooseKey2.default)("registryDefault");

var _getBlockRegistry = (0, _classPrivateFieldLooseKey2.default)("getBlockRegistry");

var _storageCache = (0, _classPrivateFieldLooseKey2.default)("storageCache");

class Rpc {
  // Ok, this is quite horrible - we really should not be using the ! here, but we are actually assigning
  // these via the createInterfaces inside the constructor. However... this is not quite visible. The reason
  // why we don't do for individual assignments is to allow user-defined RPCs to also be defined

  /**
   * @constructor
   * Default constructor for the Api Object
   * @param  {ProviderInterface} provider An API provider using HTTP or WebSocket
   */
  constructor(instanceId, registry, provider, userRpc = {}) {
    Object.defineProperty(this, _instanceId, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _registryDefault, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _getBlockRegistry, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _storageCache, {
      writable: true,
      value: new Map()
    });
    this.mapping = new Map();
    this.provider = void 0;
    this.sections = [];
    this.author = void 0;
    this.babe = void 0;
    this.chain = void 0;
    this.childstate = void 0;
    this.contracts = void 0;
    this.engine = void 0;
    this.grandpa = void 0;
    this.offchain = void 0;
    this.payment = void 0;
    this.rpc = void 0;
    this.state = void 0;
    this.system = void 0;
    // eslint-disable-next-line @typescript-eslint/unbound-method
    (0, _util.assert)(provider && (0, _util.isFunction)(provider.send), 'Expected Provider to API create');
    (0, _classPrivateFieldLooseBase2.default)(this, _instanceId)[_instanceId] = instanceId;
    (0, _classPrivateFieldLooseBase2.default)(this, _registryDefault)[_registryDefault] = registry;
    this.provider = provider;
    const sectionNames = Object.keys(_jsonrpc.default); // these are the base keys (i.e. part of jsonrpc)

    this.sections.push(...sectionNames);
    this.addUserInterfaces(userRpc);
  }
  /**
   * @description Returns the connected status of a provider
   */


  get isConnected() {
    return this.provider.isConnected;
  }
  /**
   * @description Manually connect from the attached provider
   */


  connect() {
    return this.provider.connect();
  }
  /**
   * @description Manually disconnect from the attached provider
   */


  disconnect() {
    return this.provider.disconnect();
  }
  /**
   * @description Sets a registry swap (typically from Api)
   */


  setRegistrySwap(registrySwap) {
    (0, _classPrivateFieldLooseBase2.default)(this, _getBlockRegistry)[_getBlockRegistry] = registrySwap;
  }

  addUserInterfaces(userRpc) {
    // add any extra user-defined sections
    this.sections.push(...Object.keys(userRpc).filter(key => !this.sections.includes(key))); // decorate the sections with base and user methods

    this.sections.forEach(sectionName => {
      if (!this[sectionName]) {
        this[sectionName] = {};
      }

      const section = this[sectionName];
      Object.entries(_objectSpread(_objectSpread({}, this._createInterface(sectionName, _jsonrpc.default[sectionName] || {})), this._createInterface(sectionName, userRpc[sectionName] || {}))).forEach(([key, value]) => {
        // we don't want to clobber existing, i.e. when this is called again after chain is determined
        if (!section[key]) {
          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
          section[key] = value;
        }
      });
    });
  }

  _createInterface(section, methods) {
    return Object.keys(methods).filter(method => !this.mapping.has(`${section}_${method}`)).reduce((exposed, method) => {
      const def = methods[method];
      const isSubscription = !!def.pubsub;
      this.mapping.set(`${section}_${method}`, _objectSpread(_objectSpread({}, def), {}, {
        isSubscription,
        jsonrpc: `${section}_${method}`,
        method,
        section
      })); // FIXME Remove any here
      // To do so, remove `RpcInterfaceMethod` from './types.ts', and refactor
      // every method inside this class to take:
      // `<S extends keyof RpcInterface, M extends keyof RpcInterface[S]>`
      // Not doing so, because it makes this class a little bit less readable,
      // and leaving it as-is doesn't harm much

      exposed[method] = isSubscription ? this._createMethodSubscribe(section, method, def) : this._createMethodSend(section, method, def);
      return exposed;
    }, {});
  }

  _createMethodWithRaw(creator) {
    const call = creator(false);
    call.raw = creator(true);
    return call;
  }

  _createMethodSend(section, method, def) {
    const rpcName = `${section}_${method}`;
    const hashIndex = def.params.findIndex(({
      isHistoric
    }) => isHistoric);
    const cacheIndex = def.params.findIndex(({
      isCached
    }) => isCached);
    let memoized = null; // execute the RPC call, doing a registry swap for historic as applicable

    const callWithRegistry = async (isRaw, values) => {
      const hash = hashIndex === -1 ? undefined : values[hashIndex];
      const {
        registry
      } = hash && (0, _classPrivateFieldLooseBase2.default)(this, _getBlockRegistry)[_getBlockRegistry] ? await (0, _classPrivateFieldLooseBase2.default)(this, _getBlockRegistry)[_getBlockRegistry](hash) : {
        registry: (0, _classPrivateFieldLooseBase2.default)(this, _registryDefault)[_registryDefault]
      };

      const params = this._formatInputs(registry, def, values);

      const data = await this.provider.send(rpcName, params.map(param => param.toJSON()));
      return isRaw ? registry.createType('Raw', data) : this._formatOutput(registry, method, def, params, data);
    };

    const creator = isRaw => (...values) => {
      const isDelayed = hashIndex !== -1 && !!values[hashIndex] || cacheIndex !== -1 && !!values[cacheIndex];
      return new _rxjs.Observable(observer => {
        callWithRegistry(isRaw, values).then(value => {
          observer.next(value);
          observer.complete();
        }).catch(error => {
          logErrorMessage(method, def, error);
          observer.error(error);
          observer.complete();
        });
        return () => {
          var _memoized;

          // delete old results from cache
          (_memoized = memoized) === null || _memoized === void 0 ? void 0 : _memoized.delete(...values);
        };
      }).pipe((0, _operators.publishReplay)(1), // create a Replay(1)
      isDelayed ? (0, _rxjs2.refCountDelay)() // Unsubscribe after delay
      : (0, _operators.refCount)());
    };

    memoized = (0, _memoizee.default)(this._createMethodWithRaw(creator), {
      length: false,
      normalizer: args => (0, _classPrivateFieldLooseBase2.default)(this, _instanceId)[_instanceId] + JSON.stringify(args)
    });
    return memoized;
  } // create a subscriptor, it subscribes once and resolves with the id as subscribe


  _createSubscriber({
    paramsJson,
    subName,
    subType,
    update
  }, errorHandler) {
    return new Promise((resolve, reject) => {
      this.provider.subscribe(subType, subName, paramsJson, update).then(resolve).catch(error => {
        errorHandler(error);
        reject(error);
      });
    });
  }

  _createMethodSubscribe(section, method, def) {
    const [updateType, subMethod, unsubMethod] = def.pubsub;
    const subName = `${section}_${subMethod}`;
    const unsubName = `${section}_${unsubMethod}`;
    const subType = `${section}_${updateType}`;
    let memoized = null;

    const creator = isRaw => (...values) => {
      return new _rxjs.Observable(observer => {
        // Have at least an empty promise, as used in the unsubscribe
        let subscriptionPromise = Promise.resolve(null);

        const registry = (0, _classPrivateFieldLooseBase2.default)(this, _registryDefault)[_registryDefault];

        const errorHandler = error => {
          logErrorMessage(method, def, error);
          observer.error(error);
        };

        try {
          const params = this._formatInputs(registry, def, values);

          const paramsJson = params.map(param => param.toJSON());

          const update = (error, result) => {
            if (error) {
              logErrorMessage(method, def, error);
              return;
            }

            try {
              observer.next(isRaw ? registry.createType('Raw', result) : this._formatOutput(registry, method, def, params, result));
            } catch (error) {
              observer.error(error);
            }
          };

          subscriptionPromise = this._createSubscriber({
            paramsJson,
            subName,
            subType,
            update
          }, errorHandler);
        } catch (error) {
          errorHandler(error);
        } // Teardown logic


        return () => {
          var _memoized2;

          // Delete from cache, so old results don't hang around
          (_memoized2 = memoized) === null || _memoized2 === void 0 ? void 0 : _memoized2.delete(...values); // Unsubscribe from provider

          subscriptionPromise.then(subscriptionId => (0, _util.isNull)(subscriptionId) ? Promise.resolve(false) : this.provider.unsubscribe(subType, unsubName, subscriptionId)).catch(error => logErrorMessage(method, def, error));
        };
      }).pipe((0, _rxjs2.drr)());
    };

    memoized = (0, _memoizee.default)(this._createMethodWithRaw(creator), {
      // Dynamic length for argument
      length: false,
      // Normalize args so that different args that should be cached
      // together are cached together.
      // E.g.: `query.my.method('abc') === query.my.method(createType('AccountId', 'abc'));`
      // eslint-disable-next-line @typescript-eslint/unbound-method
      normalizer: args => (0, _classPrivateFieldLooseBase2.default)(this, _instanceId)[_instanceId] + JSON.stringify(args)
    });
    return memoized;
  }

  _formatInputs(registry, def, inputs) {
    const reqArgCount = def.params.filter(({
      isOptional
    }) => !isOptional).length;
    const optText = reqArgCount === def.params.length ? '' : ` (${def.params.length - reqArgCount} optional)`;
    (0, _util.assert)(inputs.length >= reqArgCount && inputs.length <= def.params.length, `Expected ${def.params.length} parameters${optText}, ${inputs.length} found instead`);
    return inputs.map((input, index) => (0, _types.createTypeUnsafe)(registry, def.params[index].type, [input]));
  }

  _treatAsHex(key) {
    // :code is problematic - it does not have the length attached, which is
    // unlike all other storage entries where it is indeed properly encoded
    return ['0x3a636f6465'].includes(key.toHex());
  }

  _formatOutput(registry, method, rpc, params, result) {
    if (rpc.type === 'StorageData') {
      const key = params[0];

      try {
        return this._formatStorageData(registry, key, result);
      } catch (error) {
        console.error(`Unable to decode storage ${key.section || 'unknown'}.${key.method || 'unknown'}:`, error.message);
        throw error;
      }
    } else if (rpc.type === 'StorageChangeSet') {
      const keys = params[0];
      return keys ? this._formatStorageSet(registry, keys, result.changes) : registry.createType('StorageChangeSet', result);
    } else if (rpc.type === 'Vec<StorageChangeSet>') {
      const mapped = result.map(({
        block,
        changes
      }) => [registry.createType('Hash', block), this._formatStorageSet(registry, params[0], changes)]); // we only query at a specific block, not a range - flatten

      return method === 'queryStorageAt' ? mapped[0][1] : mapped;
    }

    return (0, _types.createTypeUnsafe)(registry, rpc.type, [result]);
  }

  _formatStorageData(registry, key, value) {
    // single return value (via state.getStorage), decode the value based on the
    // outputType that we have specified. Fallback to Raw on nothing
    const type = key.outputType || 'Raw';
    const meta = key.meta || EMPTY_META;
    const isEmpty = (0, _util.isNull)(value); // we convert to Uint8Array since it maps to the raw encoding, all
    // data will be correctly encoded (incl. numbers, excl. :code)

    const input = isEmpty ? null : this._treatAsHex(key) ? value : (0, _util.u8aToU8a)(value);

    if (meta.modifier.isOptional) {
      return new _types.Option(registry, (0, _types.createClass)(registry, type), isEmpty ? null : (0, _types.createTypeUnsafe)(registry, type, [input], true));
    }

    return (0, _types.createTypeUnsafe)(registry, type, [isEmpty ? meta.fallback ? (0, _util.hexToU8a)(meta.fallback.toHex()) : undefined : input], true);
  }

  _formatStorageSet(registry, keys, changes) {
    // For StorageChangeSet, the changes has the [key, value] mappings
    const withCache = keys.length !== 1; // multiple return values (via state.storage subscription), decode the values
    // one at a time, all based on the query types. Three values can be returned -
    //   - Codec - There is a valid value, non-empty
    //   - null - The storage key is empty

    return keys.reduce((results, key) => {
      try {
        results.push(this._formatStorageSetEntry(registry, key, changes, withCache));
      } catch (error) {
        console.error(`Unable to decode storage ${key.section || 'unknown'}.${key.method || 'unknown'}:`, error.message);
        throw error;
      }

      return results;
    }, []);
  }

  _formatStorageSetEntry(registry, key, changes, witCache) {
    // Fallback to Raw (i.e. just the encoding) if we don't have a specific type
    const type = key.outputType || 'Raw';
    const hexKey = key.toHex();
    const meta = key.meta || EMPTY_META;
    const found = changes.find(([key]) => key === hexKey); // if we don't find the value, this is our fallback
    //   - in the case of an array of values, fill the hole from the cache
    //   - if a single result value, don't fill - it is not an update hole
    //   - fallback to an empty option in all cases

    const value = (0, _util.isUndefined)(found) ? witCache && (0, _classPrivateFieldLooseBase2.default)(this, _storageCache)[_storageCache].get(hexKey) || null : found[1];
    const isEmpty = (0, _util.isNull)(value);
    const input = isEmpty || this._treatAsHex(key) ? value : (0, _util.u8aToU8a)(value); // store the retrieved result - the only issue with this cache is that there is no
    // clearing of it, so very long running processes (not just a couple of hours, longer)
    // will increase memory beyond what is allowed.

    (0, _classPrivateFieldLooseBase2.default)(this, _storageCache)[_storageCache].set(hexKey, value);

    if (meta.modifier.isOptional) {
      return new _types.Option(registry, (0, _types.createClass)(registry, type), isEmpty ? null : (0, _types.createTypeUnsafe)(registry, type, [input], true));
    }

    return (0, _types.createTypeUnsafe)(registry, type, [isEmpty ? meta.fallback ? (0, _util.hexToU8a)(meta.fallback.toHex()) : undefined : input], true);
  }

}

exports.default = Rpc;

/***/ }),

/***/ "../../node_modules/@polkadot/rpc-core/rxjs/drr.js":
/*!**************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/rpc-core/rxjs/drr.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.drr = void 0;

var _operators = __webpack_require__(/*! rxjs/operators */ "../../node_modules/rxjs/_esm5/operators/index.js");

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _refCountDelay = __webpack_require__(/*! ./refCountDelay */ "../../node_modules/@polkadot/rpc-core/rxjs/refCountDelay.js");

// Copyright 2017-2020 @polkadot/rpc-core authors & contributors
// SPDX-License-Identifier: Apache-2.0
const l = (0, _util.logger)('drr');

const CMP = (a, b) => JSON.stringify({
  t: a
}) === JSON.stringify({
  t: b
});

const ERR = error => {
  l.error(error);
  throw error;
};

const NOOP = () => undefined;
/**
 * Shorthand for distinctUntilChanged(), publishReplay(1) and refCount().
 *
 * @ignore
 * @internal
 */


const drr = ({
  delay,
  skipChange = false,
  skipTimeout = false
} = {}) => source$ => source$.pipe((0, _operators.catchError)(ERR), skipChange ? (0, _operators.tap)(NOOP) : (0, _operators.distinctUntilChanged)(CMP), (0, _operators.publishReplay)(1), skipTimeout ? (0, _operators.refCount)() : (0, _refCountDelay.refCountDelay)(delay));

exports.drr = drr;

/***/ }),

/***/ "../../node_modules/@polkadot/rpc-core/rxjs/index.js":
/*!****************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/rpc-core/rxjs/index.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _drr = __webpack_require__(/*! ./drr */ "../../node_modules/@polkadot/rpc-core/rxjs/drr.js");

Object.keys(_drr).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _drr[key];
    }
  });
});

var _refCountDelay = __webpack_require__(/*! ./refCountDelay */ "../../node_modules/@polkadot/rpc-core/rxjs/refCountDelay.js");

Object.keys(_refCountDelay).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _refCountDelay[key];
    }
  });
});

/***/ }),

/***/ "../../node_modules/@polkadot/rpc-core/rxjs/refCountDelay.js":
/*!************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/rpc-core/rxjs/refCountDelay.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.refCountDelay = refCountDelay;

var _rxjs = __webpack_require__(/*! rxjs */ "../../node_modules/rxjs/_esm5/index.js");

// Copyright 2017-2020 @polkadot/rpc-core authors & contributors
// SPDX-License-Identifier: Apache-2.0

/** @internal */
function refCountDelay(delay = 1750) {
  return source => {
    // state: 0 = disconnected, 1 = disconnecting, 2 = connecting, 3 = connected
    let [state, refCount, connection, scheduler] = [0, 0, _rxjs.Subscription.EMPTY, _rxjs.Subscription.EMPTY];
    return new _rxjs.Observable(ob => {
      source.subscribe(ob);

      if (refCount++ === 0) {
        if (state === 1) {
          scheduler.unsubscribe();
        } else {
          connection = source.connect();
        }

        state = 3;
      }

      return () => {
        if (--refCount === 0) {
          if (state === 2) {
            state = 0;
            scheduler.unsubscribe();
          } else {
            // state === 3
            state = 1;
            scheduler = _rxjs.asapScheduler.schedule(() => {
              state = 0;
              connection.unsubscribe();
            }, delay);
          }
        }
      };
    });
  };
}

/***/ }),

/***/ "../../node_modules/@polkadot/rpc-provider/coder/index.js":
/*!*********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/rpc-provider/coder/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classPrivateFieldLooseBase2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classPrivateFieldLooseBase */ "../../node_modules/@babel/runtime/helpers/classPrivateFieldLooseBase.js"));

var _classPrivateFieldLooseKey2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classPrivateFieldLooseKey */ "../../node_modules/@babel/runtime/helpers/classPrivateFieldLooseKey.js"));

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

// Copyright 2017-2020 @polkadot/rpc-provider authors & contributors
// SPDX-License-Identifier: Apache-2.0
function formatErrorData(data) {
  if ((0, _util.isUndefined)(data)) {
    return '';
  }

  const formatted = `: ${(0, _util.isString)(data) ? data.replace(/Error\("/g, '').replace(/\("/g, '(').replace(/"\)/g, ')').replace(/\(/g, ', ').replace(/\)/g, '') : JSON.stringify(data)}`; // We need some sort of cut-off here since these can be very large and
  // very nested, pick a number and trim the result display to it

  return formatted.length <= 256 ? formatted : `${formatted.substr(0, 255)}…`;
}
/** @internal */


var _id = (0, _classPrivateFieldLooseKey2.default)("id");

class RpcCoder {
  constructor() {
    Object.defineProperty(this, _id, {
      writable: true,
      value: 0
    });
  }

  decodeResponse(response) {
    (0, _util.assert)(response, 'Empty response object received');
    (0, _util.assert)(response.jsonrpc === '2.0', 'Invalid jsonrpc field in decoded object');
    const isSubscription = !(0, _util.isUndefined)(response.params) && !(0, _util.isUndefined)(response.method);
    (0, _util.assert)((0, _util.isNumber)(response.id) || isSubscription && ((0, _util.isNumber)(response.params.subscription) || (0, _util.isString)(response.params.subscription)), 'Invalid id field in decoded object');

    this._checkError(response.error);

    (0, _util.assert)(!(0, _util.isUndefined)(response.result) || isSubscription, 'No result found in JsonRpc response');

    if (isSubscription) {
      this._checkError(response.params.error);

      return response.params.result;
    }

    return response.result;
  }

  encodeJson(method, params) {
    return JSON.stringify(this.encodeObject(method, params));
  }

  encodeObject(method, params) {
    return {
      id: ++(0, _classPrivateFieldLooseBase2.default)(this, _id)[_id],
      jsonrpc: '2.0',
      method,
      params
    };
  }

  getId() {
    return (0, _classPrivateFieldLooseBase2.default)(this, _id)[_id];
  }

  _checkError(error) {
    if (error) {
      const {
        code,
        data,
        message
      } = error;
      throw new Error(`${code}: ${message}${formatErrorData(data)}`);
    }
  }

}

exports.default = RpcCoder;

/***/ }),

/***/ "../../node_modules/@polkadot/rpc-provider/defaults.js":
/*!******************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/rpc-provider/defaults.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// Copyright 2017-2020 @polkadot/rpc-provider authors & contributors
// SPDX-License-Identifier: Apache-2.0
const HTTP_URL = 'http://127.0.0.1:9933';
const WS_URL = 'ws://127.0.0.1:9944';
var _default = {
  HTTP_URL,
  WS_URL
};
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/rpc-provider/http/index.js":
/*!********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/rpc-provider/http/index.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js"));

var _classPrivateFieldLooseBase2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classPrivateFieldLooseBase */ "../../node_modules/@babel/runtime/helpers/classPrivateFieldLooseBase.js"));

var _classPrivateFieldLooseKey2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classPrivateFieldLooseKey */ "../../node_modules/@babel/runtime/helpers/classPrivateFieldLooseKey.js"));

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _xFetch = _interopRequireDefault(__webpack_require__(/*! @polkadot/x-fetch */ "../../node_modules/@polkadot/x-fetch/browser.js"));

var _coder2 = _interopRequireDefault(__webpack_require__(/*! ../coder */ "../../node_modules/@polkadot/rpc-provider/coder/index.js"));

var _defaults = _interopRequireDefault(__webpack_require__(/*! ../defaults */ "../../node_modules/@polkadot/rpc-provider/defaults.js"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const ERROR_SUBSCRIBE = 'HTTP Provider does not have subscriptions, use WebSockets instead';
const l = (0, _util.logger)('api-http');
/**
 * # @polkadot/rpc-provider/https
 *
 * @name HttpProvider
 *
 * @description The HTTP Provider allows sending requests using HTTP to a HTTP RPC server TCP port. It does not support subscriptions so you won't be able to listen to events such as new blocks or balance changes. It is usually preferrable using the [[WsProvider]].
 *
 * @example
 * <BR>
 *
 * ```javascript
 * import Api from '@polkadot/api/promise';
 * import HttpProvider from '@polkadot/rpc-provider/http';
 *
 * const provider = new HttpProvider('http://127.0.0.1:9933');
 * const api = new Api(provider);
 * ```
 *
 * @see [[WsProvider]]
 */

var _coder = (0, _classPrivateFieldLooseKey2.default)("coder");

var _endpoint = (0, _classPrivateFieldLooseKey2.default)("endpoint");

var _headers = (0, _classPrivateFieldLooseKey2.default)("headers");

class HttpProvider {
  /**
   * @param {string} endpoint The endpoint url starting with http://
   */
  constructor(endpoint = _defaults.default.HTTP_URL, headers = {}) {
    Object.defineProperty(this, _coder, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _endpoint, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _headers, {
      writable: true,
      value: void 0
    });
    (0, _util.assert)(/^(https|http):\/\//.test(endpoint), `Endpoint should start with 'http://', received '${endpoint}'`);
    (0, _classPrivateFieldLooseBase2.default)(this, _coder)[_coder] = new _coder2.default();
    (0, _classPrivateFieldLooseBase2.default)(this, _endpoint)[_endpoint] = endpoint;
    (0, _classPrivateFieldLooseBase2.default)(this, _headers)[_headers] = headers;
  }
  /**
   * @summary `true` when this provider supports subscriptions
   */


  get hasSubscriptions() {
    return false;
  }
  /**
   * @description Returns a clone of the object
   */


  clone() {
    throw new Error('Unimplemented');
  }
  /**
   * @description Manually connect from the connection
   */


  async connect() {// noop
  }
  /**
   * @description Manually disconnect from the connection
   */


  async disconnect() {// noop
  }
  /**
   * @summary Whether the node is connected or not.
   * @return {boolean} true if connected
   */


  get isConnected() {
    return true;
  }
  /**
   * @summary Events are not supported with the HttpProvider, see [[WsProvider]].
   * @description HTTP Provider does not have 'on' emitters. WebSockets should be used instead.
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars


  on(type, sub) {
    l.error('HTTP Provider does not have \'on\' emitters, use WebSockets instead');
    return () => {// noop
    };
  }
  /**
   * @summary Send HTTP POST Request with Body to configured HTTP Endpoint.
   */


  async send(method, params) {
    const body = (0, _classPrivateFieldLooseBase2.default)(this, _coder)[_coder].encodeJson(method, params);

    const response = await (0, _xFetch.default)((0, _classPrivateFieldLooseBase2.default)(this, _endpoint)[_endpoint], {
      body,
      headers: _objectSpread({
        Accept: 'application/json',
        'Content-Length': `${body.length}`,
        'Content-Type': 'application/json'
      }, (0, _classPrivateFieldLooseBase2.default)(this, _headers)[_headers]),
      method: 'POST'
    });
    (0, _util.assert)(response.ok, `[${response.status}]: ${response.statusText}`); // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment

    const result = await response.json();
    return (0, _classPrivateFieldLooseBase2.default)(this, _coder)[_coder].decodeResponse(result);
  }
  /**
   * @summary Subscriptions are not supported with the HttpProvider, see [[WsProvider]].
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars,@typescript-eslint/require-await


  async subscribe(types, method, params, cb) {
    l.error(ERROR_SUBSCRIBE);
    throw new Error(ERROR_SUBSCRIBE);
  }
  /**
   * @summary Subscriptions are not supported with the HttpProvider, see [[WsProvider]].
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars,@typescript-eslint/require-await


  async unsubscribe(type, method, id) {
    l.error(ERROR_SUBSCRIBE);
    throw new Error(ERROR_SUBSCRIBE);
  }

}

exports.default = HttpProvider;

/***/ }),

/***/ "../../node_modules/@polkadot/rpc-provider/index.js":
/*!***************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/rpc-provider/index.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "HttpProvider", {
  enumerable: true,
  get: function () {
    return _http.default;
  }
});
Object.defineProperty(exports, "WsProvider", {
  enumerable: true,
  get: function () {
    return _ws.default;
  }
});

var _http = _interopRequireDefault(__webpack_require__(/*! ./http */ "../../node_modules/@polkadot/rpc-provider/http/index.js"));

var _ws = _interopRequireDefault(__webpack_require__(/*! ./ws */ "../../node_modules/@polkadot/rpc-provider/ws/index.js"));

/***/ }),

/***/ "../../node_modules/@polkadot/rpc-provider/ws/Provider.js":
/*!*********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/rpc-provider/ws/Provider.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js"));

var _classPrivateFieldLooseBase2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classPrivateFieldLooseBase */ "../../node_modules/@babel/runtime/helpers/classPrivateFieldLooseBase.js"));

var _classPrivateFieldLooseKey2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classPrivateFieldLooseKey */ "../../node_modules/@babel/runtime/helpers/classPrivateFieldLooseKey.js"));

var _eventemitter2 = _interopRequireDefault(__webpack_require__(/*! eventemitter3 */ "../../node_modules/eventemitter3/index.js"));

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _xWs = _interopRequireDefault(__webpack_require__(/*! @polkadot/x-ws */ "../../node_modules/@polkadot/x-ws/browser.js"));

var _coder2 = _interopRequireDefault(__webpack_require__(/*! ../coder */ "../../node_modules/@polkadot/rpc-provider/coder/index.js"));

var _defaults = _interopRequireDefault(__webpack_require__(/*! ../defaults */ "../../node_modules/@polkadot/rpc-provider/defaults.js"));

var _errors = __webpack_require__(/*! ./errors */ "../../node_modules/@polkadot/rpc-provider/ws/errors.js");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const ALIASSES = {
  chain_finalisedHead: 'chain_finalizedHead',
  chain_subscribeFinalisedHeads: 'chain_subscribeFinalizedHeads',
  chain_unsubscribeFinalisedHeads: 'chain_unsubscribeFinalizedHeads'
};
const RETRY_DELAY = 1000;
const l = (0, _util.logger)('api-ws');
/**
 * # @polkadot/rpc-provider/ws
 *
 * @name WsProvider
 *
 * @description The WebSocket Provider allows sending requests using WebSocket to a WebSocket RPC server TCP port. Unlike the [[HttpProvider]], it does support subscriptions and allows listening to events such as new blocks or balance changes.
 *
 * @example
 * <BR>
 *
 * ```javascript
 * import Api from '@polkadot/api/promise';
 * import WsProvider from '@polkadot/rpc-provider/ws';
 *
 * const provider = new WsProvider('ws://127.0.0.1:9944');
 * const api = new Api(provider);
 * ```
 *
 * @see [[HttpProvider]]
 */

var _coder = (0, _classPrivateFieldLooseKey2.default)("coder");

var _endpoints = (0, _classPrivateFieldLooseKey2.default)("endpoints");

var _headers = (0, _classPrivateFieldLooseKey2.default)("headers");

var _eventemitter = (0, _classPrivateFieldLooseKey2.default)("eventemitter");

var _handlers = (0, _classPrivateFieldLooseKey2.default)("handlers");

var _queued = (0, _classPrivateFieldLooseKey2.default)("queued");

var _waitingForId = (0, _classPrivateFieldLooseKey2.default)("waitingForId");

var _autoConnectMs = (0, _classPrivateFieldLooseKey2.default)("autoConnectMs");

var _endpointIndex = (0, _classPrivateFieldLooseKey2.default)("endpointIndex");

var _isConnected = (0, _classPrivateFieldLooseKey2.default)("isConnected");

var _subscriptions = (0, _classPrivateFieldLooseKey2.default)("subscriptions");

var _websocket = (0, _classPrivateFieldLooseKey2.default)("websocket");

var _emit = (0, _classPrivateFieldLooseKey2.default)("emit");

var _onSocketClose = (0, _classPrivateFieldLooseKey2.default)("onSocketClose");

var _onSocketError = (0, _classPrivateFieldLooseKey2.default)("onSocketError");

var _onSocketMessage = (0, _classPrivateFieldLooseKey2.default)("onSocketMessage");

var _onSocketMessageResult = (0, _classPrivateFieldLooseKey2.default)("onSocketMessageResult");

var _onSocketMessageSubscribe = (0, _classPrivateFieldLooseKey2.default)("onSocketMessageSubscribe");

var _onSocketOpen = (0, _classPrivateFieldLooseKey2.default)("onSocketOpen");

var _resubscribe = (0, _classPrivateFieldLooseKey2.default)("resubscribe");

var _sendQueue = (0, _classPrivateFieldLooseKey2.default)("sendQueue");

class WsProvider {
  /**
   * @param {string | string[]}  endpoint    The endpoint url. Usually `ws://ip:9944` or `wss://ip:9944`, may provide an array of endpoint strings.
   * @param {boolean} autoConnect Whether to connect automatically or not.
   */
  constructor(endpoint = _defaults.default.WS_URL, autoConnectMs = RETRY_DELAY, headers = {}) {
    Object.defineProperty(this, _coder, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _endpoints, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _headers, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _eventemitter, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _handlers, {
      writable: true,
      value: {}
    });
    Object.defineProperty(this, _queued, {
      writable: true,
      value: {}
    });
    Object.defineProperty(this, _waitingForId, {
      writable: true,
      value: {}
    });
    Object.defineProperty(this, _autoConnectMs, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _endpointIndex, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _isConnected, {
      writable: true,
      value: false
    });
    Object.defineProperty(this, _subscriptions, {
      writable: true,
      value: {}
    });
    Object.defineProperty(this, _websocket, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _emit, {
      writable: true,
      value: (type, ...args) => {
        (0, _classPrivateFieldLooseBase2.default)(this, _eventemitter)[_eventemitter].emit(type, ...args);
      }
    });
    Object.defineProperty(this, _onSocketClose, {
      writable: true,
      value: event => {
        if ((0, _classPrivateFieldLooseBase2.default)(this, _autoConnectMs)[_autoConnectMs] > 0) {
          l.error(`disconnected from ${(0, _classPrivateFieldLooseBase2.default)(this, _endpoints)[_endpoints][(0, _classPrivateFieldLooseBase2.default)(this, _endpointIndex)[_endpointIndex]]}: ${event.code}:: ${event.reason || (0, _errors.getWSErrorString)(event.code)}`);
        }

        (0, _classPrivateFieldLooseBase2.default)(this, _isConnected)[_isConnected] = false;

        (0, _classPrivateFieldLooseBase2.default)(this, _emit)[_emit]('disconnected');

        if ((0, _classPrivateFieldLooseBase2.default)(this, _autoConnectMs)[_autoConnectMs] > 0) {
          setTimeout(() => {
            this.connectWithRetry().catch(() => {// does not throw
            });
          }, (0, _classPrivateFieldLooseBase2.default)(this, _autoConnectMs)[_autoConnectMs]);
        }
      }
    });
    Object.defineProperty(this, _onSocketError, {
      writable: true,
      value: error => {
        l.debug(() => ['socket error', error]);

        (0, _classPrivateFieldLooseBase2.default)(this, _emit)[_emit]('error', error);
      }
    });
    Object.defineProperty(this, _onSocketMessage, {
      writable: true,
      value: message => {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        l.debug(() => ['received', message.data]);
        const response = JSON.parse(message.data);
        return (0, _util.isUndefined)(response.method) ? (0, _classPrivateFieldLooseBase2.default)(this, _onSocketMessageResult)[_onSocketMessageResult](response) : (0, _classPrivateFieldLooseBase2.default)(this, _onSocketMessageSubscribe)[_onSocketMessageSubscribe](response);
      }
    });
    Object.defineProperty(this, _onSocketMessageResult, {
      writable: true,
      value: response => {
        const handler = (0, _classPrivateFieldLooseBase2.default)(this, _handlers)[_handlers][response.id];

        if (!handler) {
          l.debug(() => `Unable to find handler for id=${response.id}`);
          return;
        }

        try {
          const {
            method,
            params,
            subscription
          } = handler;

          const result = (0, _classPrivateFieldLooseBase2.default)(this, _coder)[_coder].decodeResponse(response); // first send the result - in case of subs, we may have an update
          // immediately if we have some queued results already


          handler.callback(null, result);

          if (subscription) {
            const subId = `${subscription.type}::${result}`;
            (0, _classPrivateFieldLooseBase2.default)(this, _subscriptions)[_subscriptions][subId] = _objectSpread(_objectSpread({}, subscription), {}, {
              method,
              params
            }); // if we have a result waiting for this subscription already

            if ((0, _classPrivateFieldLooseBase2.default)(this, _waitingForId)[_waitingForId][subId]) {
              (0, _classPrivateFieldLooseBase2.default)(this, _onSocketMessageSubscribe)[_onSocketMessageSubscribe]((0, _classPrivateFieldLooseBase2.default)(this, _waitingForId)[_waitingForId][subId]);
            }
          }
        } catch (error) {
          handler.callback(error, undefined);
        }

        delete (0, _classPrivateFieldLooseBase2.default)(this, _handlers)[_handlers][response.id];
      }
    });
    Object.defineProperty(this, _onSocketMessageSubscribe, {
      writable: true,
      value: response => {
        const method = ALIASSES[response.method] || response.method || 'invalid';
        const subId = `${method}::${response.params.subscription}`;

        const handler = (0, _classPrivateFieldLooseBase2.default)(this, _subscriptions)[_subscriptions][subId];

        if (!handler) {
          // store the JSON, we could have out-of-order subid coming in
          (0, _classPrivateFieldLooseBase2.default)(this, _waitingForId)[_waitingForId][subId] = response;
          l.debug(() => `Unable to find handler for subscription=${subId}`);
          return;
        } // housekeeping


        delete (0, _classPrivateFieldLooseBase2.default)(this, _waitingForId)[_waitingForId][subId];

        try {
          const result = (0, _classPrivateFieldLooseBase2.default)(this, _coder)[_coder].decodeResponse(response);

          handler.callback(null, result);
        } catch (error) {
          handler.callback(error, undefined);
        }
      }
    });
    Object.defineProperty(this, _onSocketOpen, {
      writable: true,
      value: () => {
        (0, _util.assert)(!(0, _util.isNull)((0, _classPrivateFieldLooseBase2.default)(this, _websocket)[_websocket]), 'WebSocket cannot be null in onOpen');
        l.debug(() => ['connected to', (0, _classPrivateFieldLooseBase2.default)(this, _endpoints)[_endpoints][(0, _classPrivateFieldLooseBase2.default)(this, _endpointIndex)[_endpointIndex]]]);
        (0, _classPrivateFieldLooseBase2.default)(this, _isConnected)[_isConnected] = true;

        (0, _classPrivateFieldLooseBase2.default)(this, _emit)[_emit]('connected');

        (0, _classPrivateFieldLooseBase2.default)(this, _sendQueue)[_sendQueue]();

        (0, _classPrivateFieldLooseBase2.default)(this, _resubscribe)[_resubscribe]();

        return true;
      }
    });
    Object.defineProperty(this, _resubscribe, {
      writable: true,
      value: () => {
        const subscriptions = (0, _classPrivateFieldLooseBase2.default)(this, _subscriptions)[_subscriptions];

        (0, _classPrivateFieldLooseBase2.default)(this, _subscriptions)[_subscriptions] = {}; // eslint-disable-next-line @typescript-eslint/no-misused-promises

        Object.keys(subscriptions).forEach(async id => {
          const {
            callback,
            method,
            params,
            type
          } = subscriptions[id]; // only re-create subscriptions which are not in author (only area where
          // transactions are created, i.e. submissions such as 'author_submitAndWatchExtrinsic'
          // are not included (and will not be re-broadcast)

          if (type.startsWith('author_')) {
            return;
          }

          try {
            await this.subscribe(type, method, params, callback);
          } catch (error) {
            l.error(error);
          }
        });
      }
    });
    Object.defineProperty(this, _sendQueue, {
      writable: true,
      value: () => {
        Object.keys((0, _classPrivateFieldLooseBase2.default)(this, _queued)[_queued]).forEach(id => {
          try {
            // we have done the websocket check in onSocketOpen, if an issue, will catch it
            (0, _classPrivateFieldLooseBase2.default)(this, _websocket)[_websocket].send((0, _classPrivateFieldLooseBase2.default)(this, _queued)[_queued][id]);

            delete (0, _classPrivateFieldLooseBase2.default)(this, _queued)[_queued][id];
          } catch (error) {
            l.error(error);
          }
        });
      }
    });
    const endpoints = Array.isArray(endpoint) ? endpoint : [endpoint];
    (0, _util.assert)(endpoints.length !== 0, 'WsProvider requires at least one Endpoint');
    endpoints.forEach(endpoint => {
      (0, _util.assert)(/^(wss|ws):\/\//.test(endpoint), `Endpoint should start with 'ws://', received '${endpoint}'`);
    });
    (0, _classPrivateFieldLooseBase2.default)(this, _eventemitter)[_eventemitter] = new _eventemitter2.default();
    (0, _classPrivateFieldLooseBase2.default)(this, _autoConnectMs)[_autoConnectMs] = autoConnectMs || 0;
    (0, _classPrivateFieldLooseBase2.default)(this, _coder)[_coder] = new _coder2.default();
    (0, _classPrivateFieldLooseBase2.default)(this, _endpointIndex)[_endpointIndex] = -1;
    (0, _classPrivateFieldLooseBase2.default)(this, _endpoints)[_endpoints] = endpoints;
    (0, _classPrivateFieldLooseBase2.default)(this, _headers)[_headers] = headers;
    (0, _classPrivateFieldLooseBase2.default)(this, _websocket)[_websocket] = null;

    if (autoConnectMs > 0) {
      this.connectWithRetry().catch(() => {// does not throw
      });
    }
  }
  /**
   * @summary `true` when this provider supports subscriptions
   */


  get hasSubscriptions() {
    return true;
  }
  /**
   * @summary Whether the node is connected or not.
   * @return {boolean} true if connected
   */


  get isConnected() {
    return (0, _classPrivateFieldLooseBase2.default)(this, _isConnected)[_isConnected];
  }
  /**
   * @description Returns a clone of the object
   */


  clone() {
    return new WsProvider((0, _classPrivateFieldLooseBase2.default)(this, _endpoints)[_endpoints]);
  }
  /**
   * @summary Manually connect
   * @description The [[WsProvider]] connects automatically by default, however if you decided otherwise, you may
   * connect manually using this method.
   */
  // eslint-disable-next-line @typescript-eslint/require-await


  async connect() {
    try {
      (0, _classPrivateFieldLooseBase2.default)(this, _endpointIndex)[_endpointIndex] = ((0, _classPrivateFieldLooseBase2.default)(this, _endpointIndex)[_endpointIndex] + 1) % (0, _classPrivateFieldLooseBase2.default)(this, _endpoints)[_endpoints].length;
      (0, _classPrivateFieldLooseBase2.default)(this, _websocket)[_websocket] = typeof WebSocket !== 'undefined' && (0, _util.isChildClass)(WebSocket, _xWs.default) ? new _xWs.default((0, _classPrivateFieldLooseBase2.default)(this, _endpoints)[_endpoints][(0, _classPrivateFieldLooseBase2.default)(this, _endpointIndex)[_endpointIndex]]) // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore - WS may be an instance of w3cwebsocket, which supports headers
      : new _xWs.default((0, _classPrivateFieldLooseBase2.default)(this, _endpoints)[_endpoints][(0, _classPrivateFieldLooseBase2.default)(this, _endpointIndex)[_endpointIndex]], undefined, undefined, (0, _classPrivateFieldLooseBase2.default)(this, _headers)[_headers]);
      (0, _classPrivateFieldLooseBase2.default)(this, _websocket)[_websocket].onclose = (0, _classPrivateFieldLooseBase2.default)(this, _onSocketClose)[_onSocketClose];
      (0, _classPrivateFieldLooseBase2.default)(this, _websocket)[_websocket].onerror = (0, _classPrivateFieldLooseBase2.default)(this, _onSocketError)[_onSocketError];
      (0, _classPrivateFieldLooseBase2.default)(this, _websocket)[_websocket].onmessage = (0, _classPrivateFieldLooseBase2.default)(this, _onSocketMessage)[_onSocketMessage];
      (0, _classPrivateFieldLooseBase2.default)(this, _websocket)[_websocket].onopen = (0, _classPrivateFieldLooseBase2.default)(this, _onSocketOpen)[_onSocketOpen];
    } catch (error) {
      l.error(error);

      (0, _classPrivateFieldLooseBase2.default)(this, _emit)[_emit]('error', error);

      throw error;
    }
  }
  /**
   * @description Connect, never throwing an error, but rather forcing a retry
   */


  async connectWithRetry() {
    try {
      await this.connect();
    } catch (error) {
      setTimeout(() => {
        this.connectWithRetry().catch(() => {// does not throw
        });
      }, (0, _classPrivateFieldLooseBase2.default)(this, _autoConnectMs)[_autoConnectMs] || RETRY_DELAY);
    }
  }
  /**
   * @description Manually disconnect from the connection, clearing autoconnect logic
   */
  // eslint-disable-next-line @typescript-eslint/require-await


  async disconnect() {
    try {
      (0, _util.assert)(!(0, _util.isNull)((0, _classPrivateFieldLooseBase2.default)(this, _websocket)[_websocket]), 'Cannot disconnect on a non-connected websocket'); // switch off autoConnect, we are in manual mode now

      (0, _classPrivateFieldLooseBase2.default)(this, _autoConnectMs)[_autoConnectMs] = 0; // 1000 - Normal closure; the connection successfully completed

      (0, _classPrivateFieldLooseBase2.default)(this, _websocket)[_websocket].close(1000);

      (0, _classPrivateFieldLooseBase2.default)(this, _websocket)[_websocket] = null;
    } catch (error) {
      l.error(error);

      (0, _classPrivateFieldLooseBase2.default)(this, _emit)[_emit]('error', error);

      throw error;
    }
  }
  /**
   * @summary Listens on events after having subscribed using the [[subscribe]] function.
   * @param  {ProviderInterfaceEmitted} type Event
   * @param  {ProviderInterfaceEmitCb}  sub  Callback
   * @return unsubscribe function
   */


  on(type, sub) {
    (0, _classPrivateFieldLooseBase2.default)(this, _eventemitter)[_eventemitter].on(type, sub);

    return () => {
      (0, _classPrivateFieldLooseBase2.default)(this, _eventemitter)[_eventemitter].removeListener(type, sub);
    };
  }
  /**
   * @summary Send JSON data using WebSockets to configured HTTP Endpoint or queue.
   * @param method The RPC methods to execute
   * @param params Encoded paramaters as appliucable for the method
   * @param subscription Subscription details (internally used)
   */


  send(method, params, subscription) {
    return new Promise((resolve, reject) => {
      try {
        const json = (0, _classPrivateFieldLooseBase2.default)(this, _coder)[_coder].encodeJson(method, params);

        const id = (0, _classPrivateFieldLooseBase2.default)(this, _coder)[_coder].getId();

        const callback = (error, result) => {
          error ? reject(error) : resolve(result);
        };

        l.debug(() => ['calling', method, json]);
        (0, _classPrivateFieldLooseBase2.default)(this, _handlers)[_handlers][id] = {
          callback,
          method,
          params,
          subscription
        };

        if (this.isConnected && !(0, _util.isNull)((0, _classPrivateFieldLooseBase2.default)(this, _websocket)[_websocket])) {
          (0, _classPrivateFieldLooseBase2.default)(this, _websocket)[_websocket].send(json);
        } else {
          (0, _classPrivateFieldLooseBase2.default)(this, _queued)[_queued][id] = json;
        }
      } catch (error) {
        reject(error);
      }
    });
  }
  /**
   * @name subscribe
   * @summary Allows subscribing to a specific event.
   * @param  {string}                     type     Subscription type
   * @param  {string}                     method   Subscription method
   * @param  {any[]}                 params   Parameters
   * @param  {ProviderInterfaceCallback} callback Callback
   * @return {Promise<number>}                     Promise resolving to the dd of the subscription you can use with [[unsubscribe]].
   *
   * @example
   * <BR>
   *
   * ```javascript
   * const provider = new WsProvider('ws://127.0.0.1:9944');
   * const rpc = new Rpc(provider);
   *
   * rpc.state.subscribeStorage([[storage.system.account, <Address>]], (_, values) => {
   *   console.log(values)
   * }).then((subscriptionId) => {
   *   console.log('balance changes subscription id: ', subscriptionId)
   * })
   * ```
   */


  async subscribe(type, method, params, callback) {
    const id = await this.send(method, params, {
      callback,
      type
    });
    return id;
  }
  /**
   * @summary Allows unsubscribing to subscriptions made with [[subscribe]].
   */


  async unsubscribe(type, method, id) {
    const subscription = `${type}::${id}`; // FIXME This now could happen with re-subscriptions. The issue is that with a re-sub
    // the assigned id now does not match what the API user originally received. It has
    // a slight complication in solving - since we cannot rely on the send id, but rather
    // need to find the actual subscription id to map it

    if ((0, _util.isUndefined)((0, _classPrivateFieldLooseBase2.default)(this, _subscriptions)[_subscriptions][subscription])) {
      l.debug(() => `Unable to find active subscription=${subscription}`);
      return false;
    }

    delete (0, _classPrivateFieldLooseBase2.default)(this, _subscriptions)[_subscriptions][subscription];
    const result = await this.send(method, [id]);
    return result;
  }

}

exports.default = WsProvider;

/***/ }),

/***/ "../../node_modules/@polkadot/rpc-provider/ws/errors.js":
/*!*******************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/rpc-provider/ws/errors.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getWSErrorString = getWSErrorString;
// Copyright 2017-2020 @polkadot/rpc-provider authors & contributors
// SPDX-License-Identifier: Apache-2.0
// from https://stackoverflow.com/questions/19304157/getting-the-reason-why-websockets-closed-with-close-code-1006
const specificStatusCodeMappings = {
  1000: 'Normal Closure',
  1001: 'Going Away',
  1002: 'Protocol Error',
  1003: 'Unsupported Data',
  1004: '(For future)',
  1005: 'No Status Received',
  1006: 'Abnormal Closure',
  1007: 'Invalid frame payload data',
  1008: 'Policy Violation',
  1009: 'Message too big',
  1010: 'Missing Extension',
  1011: 'Internal Error',
  1012: 'Service Restart',
  1013: 'Try Again Later',
  1014: 'Bad Gateway',
  1015: 'TLS Handshake'
};

function getWSErrorString(code) {
  if (code >= 0 && code <= 999) {
    return '(Unused)';
  } else if (code >= 1016) {
    if (code <= 1999) {
      return '(For WebSocket standard)';
    } else if (code <= 2999) {
      return '(For WebSocket extensions)';
    } else if (code <= 3999) {
      return '(For libraries and frameworks)';
    } else if (code <= 4999) {
      return '(For applications)';
    }
  }

  return specificStatusCodeMappings[code] || '(Unknown)';
}

/***/ }),

/***/ "../../node_modules/@polkadot/rpc-provider/ws/index.js":
/*!******************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/rpc-provider/ws/index.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Provider = _interopRequireDefault(__webpack_require__(/*! ./Provider */ "../../node_modules/@polkadot/rpc-provider/ws/Provider.js"));

// Copyright 2017-2020 @polkadot/rpc-provider authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _default = _Provider.default;
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types-known/chain/index.js":
/*!********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types-known/chain/index.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// Copyright 2017-2020 @polkadot/types-known authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Type overrides based on specific nodes
const typesChain = {};
var _default = typesChain;
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types-known/index.js":
/*!**************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types-known/index.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getModuleTypes = getModuleTypes;
exports.getSpecTypes = getSpecTypes;
exports.getSpecRpc = getSpecRpc;
exports.getSpecAlias = getSpecAlias;
exports.getUpgradeVersion = getUpgradeVersion;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js"));

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _chain = _interopRequireDefault(__webpack_require__(/*! ./chain */ "../../node_modules/@polkadot/types-known/chain/index.js"));

var _modules = _interopRequireDefault(__webpack_require__(/*! ./modules */ "../../node_modules/@polkadot/types-known/modules.js"));

var _spec = _interopRequireDefault(__webpack_require__(/*! ./spec */ "../../node_modules/@polkadot/types-known/spec/index.js"));

var _upgrades = _interopRequireDefault(__webpack_require__(/*! ./upgrades */ "../../node_modules/@polkadot/types-known/upgrades/index.js"));

var _warnings = _interopRequireDefault(__webpack_require__(/*! ./warnings */ "../../node_modules/@polkadot/types-known/warnings.js"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// flatten a VersionedType[] into a Record<string, string>

/** @internal */
function filterVersions(versions = [], specVersion) {
  return versions.filter(({
    minmax: [min, max]
  }) => ((0, _util.isUndefined)(min) || specVersion >= min) && ((0, _util.isUndefined)(max) || specVersion <= max)).reduce((result, {
    types
  }) => _objectSpread(_objectSpread({}, result), types), {});
}
/**
 * @description Get types for specific modules (metadata override)
 */


function getModuleTypes({
  knownTypes
}, section) {
  var _knownTypes$typesAlia;

  return _objectSpread(_objectSpread({}, _modules.default[section] || {}), ((_knownTypes$typesAlia = knownTypes.typesAlias) === null || _knownTypes$typesAlia === void 0 ? void 0 : _knownTypes$typesAlia[section]) || {});
}
/**
 * @description Based on the chain and runtimeVersion, get the applicable types (ready for registration)
 */


function getSpecTypes({
  knownTypes
}, chainName, specName, specVersion) {
  var _knownTypes$typesBund, _knownTypes$typesBund2, _knownTypes$typesBund3, _knownTypes$typesBund4, _knownTypes$typesBund5, _knownTypes$typesBund6, _knownTypes$typesSpec, _knownTypes$typesChai;

  const _chainName = chainName.toString();

  const _specName = specName.toString();

  const _specVersion = (0, _util.bnToBn)(specVersion).toNumber();

  (_warnings.default[_specName] || []).forEach(warning => console.warn(`*** ${warning}`));
  return _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, filterVersions(_spec.default[_specName], _specVersion)), filterVersions(_chain.default[_chainName], _specVersion)), filterVersions((_knownTypes$typesBund = knownTypes.typesBundle) === null || _knownTypes$typesBund === void 0 ? void 0 : (_knownTypes$typesBund2 = _knownTypes$typesBund.spec) === null || _knownTypes$typesBund2 === void 0 ? void 0 : (_knownTypes$typesBund3 = _knownTypes$typesBund2[_specName]) === null || _knownTypes$typesBund3 === void 0 ? void 0 : _knownTypes$typesBund3.types, _specVersion)), filterVersions((_knownTypes$typesBund4 = knownTypes.typesBundle) === null || _knownTypes$typesBund4 === void 0 ? void 0 : (_knownTypes$typesBund5 = _knownTypes$typesBund4.chain) === null || _knownTypes$typesBund5 === void 0 ? void 0 : (_knownTypes$typesBund6 = _knownTypes$typesBund5[_chainName]) === null || _knownTypes$typesBund6 === void 0 ? void 0 : _knownTypes$typesBund6.types, _specVersion)), ((_knownTypes$typesSpec = knownTypes.typesSpec) === null || _knownTypes$typesSpec === void 0 ? void 0 : _knownTypes$typesSpec[_specName]) || {}), ((_knownTypes$typesChai = knownTypes.typesChain) === null || _knownTypes$typesChai === void 0 ? void 0 : _knownTypes$typesChai[_chainName]) || {});
}
/**
 * @description Based on the chain and runtimeVersion, get the applicable rpc definitions (ready for registration)
 */


function getSpecRpc({
  knownTypes
}, chainName, specName) {
  var _knownTypes$typesBund7, _knownTypes$typesBund8, _knownTypes$typesBund9, _knownTypes$typesBund10, _knownTypes$typesBund11, _knownTypes$typesBund12;

  const _chainName = chainName.toString();

  const _specName = specName.toString();

  return _objectSpread(_objectSpread({}, ((_knownTypes$typesBund7 = knownTypes.typesBundle) === null || _knownTypes$typesBund7 === void 0 ? void 0 : (_knownTypes$typesBund8 = _knownTypes$typesBund7.spec) === null || _knownTypes$typesBund8 === void 0 ? void 0 : (_knownTypes$typesBund9 = _knownTypes$typesBund8[_specName]) === null || _knownTypes$typesBund9 === void 0 ? void 0 : _knownTypes$typesBund9.rpc) || {}), ((_knownTypes$typesBund10 = knownTypes.typesBundle) === null || _knownTypes$typesBund10 === void 0 ? void 0 : (_knownTypes$typesBund11 = _knownTypes$typesBund10.chain) === null || _knownTypes$typesBund11 === void 0 ? void 0 : (_knownTypes$typesBund12 = _knownTypes$typesBund11[_chainName]) === null || _knownTypes$typesBund12 === void 0 ? void 0 : _knownTypes$typesBund12.rpc) || {});
}
/**
 * @description Based on the chain and runtimeVersion, get the applicable alias definitions (ready for registration)
 */


function getSpecAlias({
  knownTypes
}, chainName, specName) {
  var _knownTypes$typesBund13, _knownTypes$typesBund14, _knownTypes$typesBund15, _knownTypes$typesBund16, _knownTypes$typesBund17, _knownTypes$typesBund18;

  const _chainName = chainName.toString();

  const _specName = specName.toString();

  return _objectSpread(_objectSpread(_objectSpread({}, knownTypes.typesAlias || {}), ((_knownTypes$typesBund13 = knownTypes.typesBundle) === null || _knownTypes$typesBund13 === void 0 ? void 0 : (_knownTypes$typesBund14 = _knownTypes$typesBund13.spec) === null || _knownTypes$typesBund14 === void 0 ? void 0 : (_knownTypes$typesBund15 = _knownTypes$typesBund14[_specName]) === null || _knownTypes$typesBund15 === void 0 ? void 0 : _knownTypes$typesBund15.alias) || {}), ((_knownTypes$typesBund16 = knownTypes.typesBundle) === null || _knownTypes$typesBund16 === void 0 ? void 0 : (_knownTypes$typesBund17 = _knownTypes$typesBund16.chain) === null || _knownTypes$typesBund17 === void 0 ? void 0 : (_knownTypes$typesBund18 = _knownTypes$typesBund17[_chainName]) === null || _knownTypes$typesBund18 === void 0 ? void 0 : _knownTypes$typesBund18.alias) || {});
}
/**
 * @description Returns a version record for known chains where upgrades are being tracked
 */


function getUpgradeVersion(genesisHash, blockNumber) {
  const known = _upgrades.default.find(u => genesisHash.eq(u.genesisHash));

  return known ? [known.versions.reduce((last, version) => {
    return blockNumber.gt(version.blockNumber) ? version : last;
  }, undefined), known.versions.find(version => blockNumber.lte(version.blockNumber))] : [undefined, undefined];
}

/***/ }),

/***/ "../../node_modules/@polkadot/types-known/modules.js":
/*!****************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types-known/modules.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// Copyright 2017-2020 @polkadot/types-known authors & contributors
// SPDX-License-Identifier: Apache-2.0
// type overrides for modules (where duplication between modules exist)
const typesModules = {
  babe: {
    EquivocationProof: 'BabeEquivocationProof'
  },
  balances: {
    Status: 'BalanceStatus'
  },
  contracts: {
    StorageKey: 'ContractStorageKey'
  },
  grandpa: {
    Equivocation: 'GrandpaEquivocation',
    EquivocationProof: 'GrandpaEquivocationProof'
  },
  identity: {
    Judgement: 'IdentityJudgement'
  },
  parachains: {
    Id: 'ParaId'
  },
  proposeParachain: {
    Proposal: 'ParachainProposal'
  },
  proxy: {
    Announcement: 'ProxyAnnouncement'
  },
  society: {
    Judgement: 'SocietyJudgement',
    Vote: 'SocietyVote'
  },
  staking: {
    Compact: 'CompactAssignments'
  },
  treasury: {
    Proposal: 'TreasuryProposal'
  }
};
var _default = typesModules;
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types-known/spec/centrifuge-chain.js":
/*!******************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types-known/spec/centrifuge-chain.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Copyright 2017-2020 @polkadot/types-known authors & contributors
// SPDX-License-Identifier: Apache-2.0
const sharedTypes = {
  Address: 'LookupSource',
  AnchorData: {
    anchoredBlock: 'u64',
    docRoot: 'H256',
    id: 'H256'
  },
  ChainId: 'u8',
  DepositNonce: 'u64',
  Fee: {
    key: 'Hash',
    price: 'Balance'
  },
  MultiAccountData: {
    deposit: 'Balance',
    depositor: 'AccountId',
    signatories: 'Vec<AccountId>',
    threshold: 'u16'
  },
  Multiplier: 'Fixed64',
  PreCommitData: {
    expirationBlock: 'u64',
    identity: 'H256',
    signingRoot: 'H256'
  },
  Proof: {
    leafHash: 'H256',
    sortedHashes: 'H256'
  },
  ResourceId: '[u8; 32]',
  'chainbridge::ChainId': 'u8'
};
const versioned = [{
  minmax: [229, 234],
  types: _objectSpread(_objectSpread({}, sharedTypes), {}, {
    RefCount: 'RefCountTo259',
    ReferendumInfo: 'ReferendumInfoTo239',
    StakingLedger: 'StakingLedgerTo240',
    Weight: 'u32'
  })
}, {
  minmax: [235, undefined],
  types: _objectSpread(_objectSpread({}, sharedTypes), {}, {
    RefCount: 'RefCountTo259'
  })
}];
var _default = versioned;
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types-known/spec/index.js":
/*!*******************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types-known/spec/index.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _centrifugeChain = _interopRequireDefault(__webpack_require__(/*! ./centrifuge-chain */ "../../node_modules/@polkadot/types-known/spec/centrifuge-chain.js"));

var _kusama = _interopRequireDefault(__webpack_require__(/*! ./kusama */ "../../node_modules/@polkadot/types-known/spec/kusama.js"));

var _polkadot = _interopRequireDefault(__webpack_require__(/*! ./polkadot */ "../../node_modules/@polkadot/types-known/spec/polkadot.js"));

var _rococo = _interopRequireDefault(__webpack_require__(/*! ./rococo */ "../../node_modules/@polkadot/types-known/spec/rococo.js"));

var _westend = _interopRequireDefault(__webpack_require__(/*! ./westend */ "../../node_modules/@polkadot/types-known/spec/westend.js"));

// Copyright 2017-2020 @polkadot/types-known authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Type overrides for specific spec types & versions as given in runtimeVersion
const typesSpec = {
  'centrifuge-chain': _centrifugeChain.default,
  kusama: _kusama.default,
  polkadot: _polkadot.default,
  rococo: _rococo.default,
  westend: _westend.default
};
var _default = typesSpec;
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types-known/spec/kusama.js":
/*!********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types-known/spec/kusama.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Copyright 2017-2020 @polkadot/types-known authors & contributors
// SPDX-License-Identifier: Apache-2.0
const sharedTypes = {
  Address: 'AccountId',
  Keys: 'SessionKeys5',
  LookupSource: 'AccountId',
  ProxyType: {
    _enum: ['Any', 'NonTransfer', 'Governance', 'Staking', 'IdentityJudgement']
  }
};
const versioned = [{
  // 1020 is first CC3
  minmax: [1019, 1031],
  types: {
    Address: 'LookupSource',
    BalanceLock: 'BalanceLockTo212',
    CompactAssignments: 'CompactAssignmentsTo257',
    DispatchError: 'DispatchErrorTo198',
    DispatchInfo: 'DispatchInfoTo244',
    Keys: 'SessionKeys5',
    Multiplier: 'Fixed64',
    OpenTip: 'OpenTipTo225',
    RefCount: 'RefCountTo259',
    ReferendumInfo: 'ReferendumInfoTo239',
    RewardDestination: 'RewardDestinationTo257',
    SlashingSpans: 'SlashingSpansTo204',
    StakingLedger: 'StakingLedgerTo223',
    Votes: 'VotesTo230',
    Weight: 'u32'
  }
}, {
  minmax: [1032, 1042],
  types: {
    Address: 'LookupSource',
    BalanceLock: 'BalanceLockTo212',
    CompactAssignments: 'CompactAssignmentsTo257',
    DispatchInfo: 'DispatchInfoTo244',
    Keys: 'SessionKeys5',
    Multiplier: 'Fixed64',
    OpenTip: 'OpenTipTo225',
    RefCount: 'RefCountTo259',
    ReferendumInfo: 'ReferendumInfoTo239',
    RewardDestination: 'RewardDestinationTo257',
    SlashingSpans: 'SlashingSpansTo204',
    StakingLedger: 'StakingLedgerTo223',
    Votes: 'VotesTo230',
    Weight: 'u32'
  }
}, {
  // actual at 1045 (1043-1044 is dev)
  minmax: [1043, 1045],
  types: {
    Address: 'LookupSource',
    BalanceLock: 'BalanceLockTo212',
    CompactAssignments: 'CompactAssignmentsTo257',
    DispatchInfo: 'DispatchInfoTo244',
    Keys: 'SessionKeys5',
    Multiplier: 'Fixed64',
    OpenTip: 'OpenTipTo225',
    RefCount: 'RefCountTo259',
    ReferendumInfo: 'ReferendumInfoTo239',
    RewardDestination: 'RewardDestinationTo257',
    StakingLedger: 'StakingLedgerTo223',
    Votes: 'VotesTo230',
    Weight: 'u32'
  }
}, {
  minmax: [1046, 1054],
  types: _objectSpread(_objectSpread({}, sharedTypes), {}, {
    CompactAssignments: 'CompactAssignmentsTo257',
    DispatchInfo: 'DispatchInfoTo244',
    Multiplier: 'Fixed64',
    OpenTip: 'OpenTipTo225',
    RefCount: 'RefCountTo259',
    ReferendumInfo: 'ReferendumInfoTo239',
    RewardDestination: 'RewardDestinationTo257',
    StakingLedger: 'StakingLedgerTo240',
    Weight: 'u32'
  })
}, {
  minmax: [1055, 1056],
  types: _objectSpread(_objectSpread({}, sharedTypes), {}, {
    CompactAssignments: 'CompactAssignmentsTo257',
    DispatchInfo: 'DispatchInfoTo244',
    Multiplier: 'Fixed64',
    OpenTip: 'OpenTipTo225',
    RefCount: 'RefCountTo259',
    RewardDestination: 'RewardDestinationTo257',
    StakingLedger: 'StakingLedgerTo240',
    Weight: 'u32'
  })
}, {
  minmax: [1057, 1061],
  types: _objectSpread(_objectSpread({}, sharedTypes), {}, {
    CompactAssignments: 'CompactAssignmentsTo257',
    DispatchInfo: 'DispatchInfoTo244',
    OpenTip: 'OpenTipTo225',
    RefCount: 'RefCountTo259',
    RewardDestination: 'RewardDestinationTo257'
  })
}, {
  minmax: [1062, 2012],
  types: _objectSpread(_objectSpread({}, sharedTypes), {}, {
    CompactAssignments: 'CompactAssignmentsTo257',
    OpenTip: 'OpenTipTo225',
    RefCount: 'RefCountTo259',
    RewardDestination: 'RewardDestinationTo257'
  })
}, {
  minmax: [2013, 2022],
  types: _objectSpread(_objectSpread({}, sharedTypes), {}, {
    CompactAssignments: 'CompactAssignmentsTo257',
    RefCount: 'RefCountTo259',
    RewardDestination: 'RewardDestinationTo257'
  })
}, {
  minmax: [2023, 2024],
  types: _objectSpread(_objectSpread({}, sharedTypes), {}, {
    RefCount: 'RefCountTo259'
  })
}, {
  minmax: [2025, undefined],
  types: _objectSpread({}, sharedTypes)
}];
var _default = versioned;
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types-known/spec/polkadot.js":
/*!**********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types-known/spec/polkadot.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Copyright 2017-2020 @polkadot/types-known authors & contributors
// SPDX-License-Identifier: Apache-2.0
const sharedTypes = {
  Address: 'AccountId',
  Keys: 'SessionKeys5',
  LookupSource: 'AccountId',
  ProxyType: {
    // was: SudoBalances
    _enum: ['Any', 'NonTransfer', 'Governance', 'Staking', 'Unused', 'IdentityJudgement']
  }
}; // these are override types for Polkadot

const versioned = [{
  minmax: [0, 12],
  types: _objectSpread(_objectSpread({}, sharedTypes), {}, {
    CompactAssignments: 'CompactAssignmentsTo257',
    OpenTip: 'OpenTipTo225',
    RefCount: 'RefCountTo259',
    RewardDestination: 'RewardDestinationTo257'
  })
}, {
  minmax: [13, 22],
  types: _objectSpread(_objectSpread({}, sharedTypes), {}, {
    CompactAssignments: 'CompactAssignmentsTo257',
    RefCount: 'RefCountTo259',
    RewardDestination: 'RewardDestinationTo257'
  })
}, {
  minmax: [23, 24],
  types: _objectSpread(_objectSpread({}, sharedTypes), {}, {
    RefCount: 'RefCountTo259'
  })
}, {
  minmax: [25, undefined],
  types: _objectSpread({}, sharedTypes)
}];
var _default = versioned;
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types-known/spec/rococo.js":
/*!********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types-known/spec/rococo.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Copyright 2017-2020 @polkadot/types-known authors & contributors
// SPDX-License-Identifier: Apache-2.0
const sharedTypes = {
  Address: 'AccountId',
  Keys: 'SessionKeys5',
  LookupSource: 'AccountId',
  RewardDestination: 'RewardDestinationTo257'
};
const versioned = [{
  minmax: [0, undefined],
  types: _objectSpread(_objectSpread({}, sharedTypes), {}, {
    CompactAssignments: 'CompactAssignmentsTo257',
    RefCount: 'RefCountTo259'
  })
}];
var _default = versioned;
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types-known/spec/westend.js":
/*!*********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types-known/spec/westend.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Copyright 2017-2020 @polkadot/types-known authors & contributors
// SPDX-License-Identifier: Apache-2.0
const sharedTypes = {
  Address: 'AccountId',
  Keys: 'SessionKeys5',
  LookupSource: 'AccountId',
  ProxyType: {
    // was: SudoBalances
    _enum: ['Any', 'NonTransfer', 'Staking', 'Unused', 'IdentityJudgement']
  }
};
const versioned = [{
  minmax: [1, 2],
  types: _objectSpread(_objectSpread({}, sharedTypes), {}, {
    CompactAssignments: 'CompactAssignmentsTo257',
    Multiplier: 'Fixed64',
    OpenTip: 'OpenTipTo225',
    RefCount: 'RefCountTo259',
    RewardDestination: 'RewardDestinationTo257',
    Weight: 'u32'
  })
}, {
  minmax: [3, 22],
  types: _objectSpread(_objectSpread({}, sharedTypes), {}, {
    CompactAssignments: 'CompactAssignmentsTo257',
    OpenTip: 'OpenTipTo225',
    RefCount: 'RefCountTo259',
    RewardDestination: 'RewardDestinationTo257'
  })
}, {
  minmax: [23, 42],
  types: _objectSpread(_objectSpread({}, sharedTypes), {}, {
    CompactAssignments: 'CompactAssignmentsTo257',
    RefCount: 'RefCountTo259',
    RewardDestination: 'RewardDestinationTo257'
  })
}, {
  minmax: [43, 44],
  types: _objectSpread(_objectSpread({}, sharedTypes), {}, {
    RefCount: 'RefCountTo259'
  })
}, {
  minmax: [45, undefined],
  types: _objectSpread({}, sharedTypes)
}];
var _default = versioned;
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types-known/upgrades/index.js":
/*!***********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types-known/upgrades/index.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _bn = _interopRequireDefault(__webpack_require__(/*! bn.js */ "../../node_modules/bn.js/lib/bn.js"));

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _kusama = _interopRequireDefault(__webpack_require__(/*! ./kusama */ "../../node_modules/@polkadot/types-known/upgrades/kusama.js"));

var _polkadot = _interopRequireDefault(__webpack_require__(/*! ./polkadot */ "../../node_modules/@polkadot/types-known/upgrades/polkadot.js"));

var _westend = _interopRequireDefault(__webpack_require__(/*! ./westend */ "../../node_modules/@polkadot/types-known/upgrades/westend.js"));

// Copyright 2017-2020 @polkadot/types-known authors & contributors
// SPDX-License-Identifier: Apache-2.0
function rawToFinal({
  genesisHash,
  versions
}) {
  return {
    genesisHash: (0, _util.hexToU8a)(genesisHash),
    versions: versions.map(([blockNumber, specVersion]) => ({
      blockNumber: new _bn.default(blockNumber),
      specVersion: new _bn.default(specVersion)
    }))
  };
} // Type overrides for specific spec types & versions as given in runtimeVersion


const upgrades = [rawToFinal(_kusama.default), rawToFinal(_polkadot.default), rawToFinal(_westend.default)];
var _default = upgrades;
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types-known/upgrades/kusama.js":
/*!************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types-known/upgrades/kusama.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// Copyright 2017-2020 @polkadot/types-known authors & contributors
// SPDX-License-Identifier: Apache-2.0
const upgrades = {
  genesisHash: '0xb0a8d493285c2df73290dfb7e61f870f17b41801197a149ca93654499ea3dafe',
  versions: [[0, 1020], [26669, 1021], [38245, 1022], [54248, 1023], [59659, 1024], [67651, 1025], [82191, 1027], [83238, 1028], [101503, 1029], [203466, 1030], [295787, 1031], [461692, 1032], [504329, 1033], [569327, 1038], [587687, 1039], [653183, 1040], [693488, 1042], [901442, 1045], [1375086, 1050], [1445458, 1051], [1472960, 1052], [1475648, 1053], [1491596, 1054], [1574408, 1055], [2064961, 1058], [2201991, 1062], [2671528, 2005], [2704202, 2007], [2728002, 2008], [2832534, 2011], [2962294, 2012], [3240000, 2013], [3274408, 2015], [3323565, 2019], [3534175, 2022], [3860281, 2023], [4143129, 2024]]
};
var _default = upgrades;
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types-known/upgrades/polkadot.js":
/*!**************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types-known/upgrades/polkadot.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// Copyright 2017-2020 @polkadot/types-known authors & contributors
// SPDX-License-Identifier: Apache-2.0
const upgrades = {
  genesisHash: '0x91b171bb158e2d3848fa23a9f1c25182fb8e20313b2c1eb49219da7a70ce90c3',
  versions: [[0, 0], [29231, 1], [188836, 5], [199405, 6], [214264, 7], [244358, 8], [303079, 9], [314201, 10], [342400, 11], [443963, 12], [528470, 13], [687751, 14], [746085, 15], [787923, 16], [799302, 17], [1205128, 18], [1603423, 23], [1733218, 24]]
};
var _default = upgrades;
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types-known/upgrades/westend.js":
/*!*************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types-known/upgrades/westend.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// Copyright 2017-2020 @polkadot/types-known authors & contributors
// SPDX-License-Identifier: Apache-2.0
const upgrades = {
  genesisHash: '0xe143f23803ac50e8f6f8e62695d1ce9e4e1d68aa36c1cd2cfd15340213f3423e',
  versions: [[214356, 4], [392764, 7], [409740, 8], [809976, 20], [877581, 24], [879238, 25], [889472, 26], [902937, 27], [932751, 28], [991142, 29], [1030162, 31], [1119657, 32], [1199282, 33], [1342534, 34], [1392263, 35], [1431703, 36], [1433369, 37], [1490972, 41], [2087397, 43], [2316688, 44]]
};
var _default = upgrades;
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types-known/warnings.js":
/*!*****************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types-known/warnings.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// Copyright 2017-2020 @polkadot/types-known authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Type overrides for specific spec types & versions as given in runtimeVersion
const warnings = {
  'node-template': ['', 'You are using the node-template, depending on your config and age of the template, you may', 'have some unexpected results without applying the correct config for your node type:', '', '- If you have trouble sending txs, apply https://polkadot.js.org/api/start/FAQ.html#i-cannot-send-transactions-from-my-node-template-based-chain', '- If you have trouble parsing events, apply https://polkadot.js.org/api/start/FAQ.html#using-a-non-current-master-node-i-have-issues-parsing-events', '']
};
var _default = warnings;
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types/augment/index.js":
/*!****************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/augment/index.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! ./registry */ "../../node_modules/@polkadot/types/augment/registry.js");

/***/ }),

/***/ "../../node_modules/@polkadot/types/augment/registry.js":
/*!*******************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/augment/registry.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),

/***/ "../../node_modules/@polkadot/types/codec/AbstractArray.js":
/*!**********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/codec/AbstractArray.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _Compact = _interopRequireDefault(__webpack_require__(/*! ./Compact */ "../../node_modules/@polkadot/types/codec/Compact.js"));

var _Raw = _interopRequireDefault(__webpack_require__(/*! ./Raw */ "../../node_modules/@polkadot/types/codec/Raw.js"));

var _utils = __webpack_require__(/*! ./utils */ "../../node_modules/@polkadot/types/codec/utils/index.js");

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name AbstractArray
 * @description
 * This manages codec arrays. It is an extension to Array, providing
 * specific encoding/decoding on top of the base type.
 * @noInheritDoc
 */
class AbstractArray extends Array {
  constructor(registry, ...values) {
    super(...values);
    this.registry = void 0;
    this.registry = registry;
  }
  /**
   * @description The length of the value when encoded as a Uint8Array
   */


  get encodedLength() {
    return this.reduce((total, raw) => {
      return total + raw.encodedLength;
    }, _Compact.default.encodeU8a(this.length).length);
  }
  /**
   * @description returns a hash of the contents
   */


  get hash() {
    return new _Raw.default(this.registry, this.registry.hash(this.toU8a()));
  }
  /**
   * @description Checks if the value is an empty value
   */


  get isEmpty() {
    return this.length === 0;
  }
  /**
   * @description The length of the value
   */


  get length() {
    // only included here since we ignore inherited docs
    return super.length;
  }
  /**
   * @description Compares the value of the input to see if there is a match
   */


  eq(other) {
    return (0, _utils.compareArray)(this, other);
  }
  /**
   * @description Converts the Object to an standard JavaScript Array
   */


  toArray() {
    return Array.from(this);
  }
  /**
   * @description Returns a hex string representation of the value
   */


  toHex() {
    return (0, _util.u8aToHex)(this.toU8a());
  }
  /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */


  toHuman(isExtended) {
    return this.map(entry => entry.toHuman(isExtended));
  }
  /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */


  toJSON() {
    return this.map(entry => entry.toJSON());
  }
  /**
   * @description Returns the base runtime type name for this instance
   */


  /**
   * @description Returns the string representation of the value
   */
  toString() {
    // Overwrite the default toString representation of Array.
    const data = this.map(entry => entry.toString());
    return `[${data.join(', ')}]`;
  }
  /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */


  toU8a(isBare) {
    const encoded = this.map(entry => entry.toU8a(isBare));
    return isBare ? (0, _util.u8aConcat)(...encoded) : (0, _util.u8aConcat)(_Compact.default.encodeU8a(this.length), ...encoded);
  } // Below are methods that we override. When we do a `new Vec(...).map()`,
  // we want it to return an Array. We only override the methods that return a
  // new instance.

  /**
   * @description Concatenates two arrays
   */


  concat(other) {
    return this.toArray().concat(other instanceof AbstractArray ? other.toArray() : other);
  }
  /**
   * @description Filters the array with the callback
   */


  filter(callbackfn, thisArg) {
    return this.toArray().filter(callbackfn, thisArg);
  }
  /**
   * @description Maps the array with the callback
   */


  map(callbackfn, thisArg) {
    return this.toArray().map(callbackfn, thisArg);
  }
  /**
   * @description Checks if the array includes a specific value
   */


  includes(check) {
    return this.some(value => value.eq(check));
  }

}

exports.default = AbstractArray;

/***/ }),

/***/ "../../node_modules/@polkadot/types/codec/AbstractInt.js":
/*!********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/codec/AbstractInt.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.DEFAULT_UINT_BITS = void 0;

var _classPrivateFieldLooseBase2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classPrivateFieldLooseBase */ "../../node_modules/@babel/runtime/helpers/classPrivateFieldLooseBase.js"));

var _classPrivateFieldLooseKey2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classPrivateFieldLooseKey */ "../../node_modules/@babel/runtime/helpers/classPrivateFieldLooseKey.js"));

var _bn = _interopRequireDefault(__webpack_require__(/*! bn.js */ "../../node_modules/bn.js/lib/bn.js"));

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _Raw = _interopRequireDefault(__webpack_require__(/*! ./Raw */ "../../node_modules/@polkadot/types/codec/Raw.js"));

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
const DEFAULT_UINT_BITS = 64;
exports.DEFAULT_UINT_BITS = DEFAULT_UINT_BITS;
const MUL_P = new _bn.default(10000);
const FORMATTERS = [['Perquintill', new _bn.default(1000000000000)], ['Perbill', new _bn.default(1000000000)], ['Permill', new _bn.default(1000000)], ['Percent', new _bn.default(100)]];

function toPercentage(value, divisor) {
  return `${(value.mul(MUL_P).div(divisor).toNumber() / 100).toFixed(2)}%`;
}
/** @internal */


function decodeAbstracIntU8a(value, bitLength, isNegative) {
  if (!value.length) {
    return '0';
  }

  try {
    // NOTE When passing u8a in (typically from decoded data), it is always Little Endian
    return (0, _util.u8aToBn)(value.subarray(0, bitLength / 8), {
      isLe: true,
      isNegative
    }).toString();
  } catch (error) {
    throw new Error(`AbstractInt: failed on ${JSON.stringify(value)}:: ${error.message}`);
  }
}
/** @internal */


function decodeAbstracInt(value, bitLength, isNegative) {
  // This function returns a string, which will be passed in the BN
  // constructor. It would be ideal to actually return a BN, but there's a
  // bug: https://github.com/indutny/bn.js/issues/206.
  if ((0, _util.isHex)(value, -1, true)) {
    return (0, _util.hexToBn)(value, {
      isLe: false,
      isNegative
    }).toString();
  } else if ((0, _util.isU8a)(value)) {
    return decodeAbstracIntU8a(value, bitLength, isNegative);
  } else if ((0, _util.isString)(value)) {
    return new _bn.default(value.toString(), 10).toString();
  }

  return (0, _util.bnToBn)(value).toString();
}
/**
 * @name AbstractInt
 * @ignore
 * @noInheritDoc
 */
// TODO:
//   - Apart from encoding/decoding we don't actually keep check on the sizes, is this good enough?


var _bitLength = (0, _classPrivateFieldLooseKey2.default)("bitLength");

var _isHexJson = (0, _classPrivateFieldLooseKey2.default)("isHexJson");

var _isSigned = (0, _classPrivateFieldLooseKey2.default)("isSigned");

class AbstractInt extends _bn.default {
  constructor(registry, isSigned, value = 0, bitLength = DEFAULT_UINT_BITS, isHexJson = true) {
    super(decodeAbstracInt(value, bitLength, isSigned));
    this.registry = void 0;
    Object.defineProperty(this, _bitLength, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _isHexJson, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _isSigned, {
      writable: true,
      value: void 0
    });
    this.registry = registry;
    (0, _classPrivateFieldLooseBase2.default)(this, _bitLength)[_bitLength] = bitLength;
    (0, _classPrivateFieldLooseBase2.default)(this, _isHexJson)[_isHexJson] = isHexJson;
    (0, _classPrivateFieldLooseBase2.default)(this, _isSigned)[_isSigned] = isSigned;
    (0, _util.assert)(isSigned || this.gte(_util.BN_ZERO), `${this.toRawType()}: Negative number passed to unsigned type`);
    (0, _util.assert)(super.bitLength() <= bitLength, `${this.toRawType()}: Input too large. Found input with ${super.bitLength()} bits, expected ${bitLength}`);
  }
  /**
   * @description The length of the value when encoded as a Uint8Array
   */


  get encodedLength() {
    return (0, _classPrivateFieldLooseBase2.default)(this, _bitLength)[_bitLength] / 8;
  }
  /**
   * @description returns a hash of the contents
   */


  get hash() {
    return new _Raw.default(this.registry, this.registry.hash(this.toU8a()));
  }
  /**
   * @description Checks if the value is a zero value (align elsewhere)
   */


  get isEmpty() {
    return this.isZero();
  }
  /**
   * @description Checks if the value is an unsigned type
   */


  get isUnsigned() {
    return !(0, _classPrivateFieldLooseBase2.default)(this, _isSigned)[_isSigned];
  }
  /**
   * @description Returns the number of bits in the value
   */


  bitLength() {
    return (0, _classPrivateFieldLooseBase2.default)(this, _bitLength)[_bitLength];
  }
  /**
   * @description Compares the value of the input to see if there is a match
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any


  eq(other) {
    // Here we are actually overriding the built-in .eq to take care of both
    // number and BN inputs (no `.eqn` needed) - numbers will be converted
    return super.eq((0, _util.isHex)(other) ? (0, _util.hexToBn)(other.toString(), {
      isLe: false,
      isNegative: (0, _classPrivateFieldLooseBase2.default)(this, _isSigned)[_isSigned]
    }) : (0, _util.bnToBn)(other));
  }
  /**
   * @description True if this value is the max of the type
   */


  isMax() {
    const u8a = this.toU8a().filter(byte => byte === 0xff);
    return u8a.length === (0, _classPrivateFieldLooseBase2.default)(this, _bitLength)[_bitLength] / 8;
  }
  /**
   * @description Returns a BigInt representation of the number
   */


  toBigInt() {
    return BigInt(this.toString());
  }
  /**
   * @description Returns the BN representation of the number. (Compatibility)
   */


  toBn() {
    return this;
  }
  /**
   * @description Returns a hex string representation of the value
   */


  toHex(isLe = false) {
    // For display/JSON, this is BE, for compare, use isLe
    return (0, _util.bnToHex)(this, {
      bitLength: this.bitLength(),
      isLe,
      isNegative: !this.isUnsigned
    });
  }
  /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars


  toHuman(isExpanded) {
    const rawType = this.toRawType();

    if (rawType === 'Balance') {
      return this.isMax() ? 'everything' : (0, _util.formatBalance)(this, {
        decimals: this.registry.chainDecimals,
        withSi: true,
        withUnit: this.registry.chainToken
      });
    }

    const [, divisor] = FORMATTERS.find(([type]) => type === rawType) || [];
    return divisor ? toPercentage(this, divisor) : (0, _util.formatNumber)(this);
  }
  /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */


  toJSON() {
    // FIXME this return type should by string | number, but BN's return type
    // is string.
    // Maximum allowed integer for JS is 2^53 - 1, set limit at 52
    return (0, _classPrivateFieldLooseBase2.default)(this, _isHexJson)[_isHexJson] || super.bitLength() > 52 ? this.toHex() : this.toNumber();
  }
  /**
   * @description Returns the base runtime type name for this instance
   */


  toRawType() {
    // NOTE In the case of balances, which have a special meaning on the UI
    // and can be interpreted differently, return a specific value for it so
    // underlying it always matches (no matter which length it actually is)
    return this instanceof this.registry.createClass('Balance') ? 'Balance' : `${this.isUnsigned ? 'u' : 'i'}${this.bitLength()}`;
  }
  /**
   * @description Returns the string representation of the value
   * @param base The base to use for the conversion
   */


  toString(base) {
    // only included here since we do not inherit docs
    return super.toString(base);
  }
  /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars


  toU8a(isBare) {
    return (0, _util.bnToU8a)(this, {
      bitLength: this.bitLength(),
      isLe: true,
      isNegative: !this.isUnsigned
    });
  }

}

exports.default = AbstractInt;

/***/ }),

/***/ "../../node_modules/@polkadot/types/codec/BTreeMap.js":
/*!*****************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/codec/BTreeMap.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Map = _interopRequireDefault(__webpack_require__(/*! ./Map */ "../../node_modules/@polkadot/types/codec/Map.js"));

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
class BTreeMap extends _Map.default {
  static with(keyType, valType) {
    return class extends BTreeMap {
      constructor(registry, value) {
        super(registry, 'BTreeMap', keyType, valType, value);
      }

    };
  }

}

exports.default = BTreeMap;

/***/ }),

/***/ "../../node_modules/@polkadot/types/codec/BTreeSet.js":
/*!*****************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/codec/BTreeSet.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classPrivateFieldLooseBase2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classPrivateFieldLooseBase */ "../../node_modules/@babel/runtime/helpers/classPrivateFieldLooseBase.js"));

var _classPrivateFieldLooseKey2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classPrivateFieldLooseKey */ "../../node_modules/@babel/runtime/helpers/classPrivateFieldLooseKey.js"));

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _Compact = _interopRequireDefault(__webpack_require__(/*! ./Compact */ "../../node_modules/@polkadot/types/codec/Compact.js"));

var _Raw = _interopRequireDefault(__webpack_require__(/*! ./Raw */ "../../node_modules/@polkadot/types/codec/Raw.js"));

var _utils = __webpack_require__(/*! ./utils */ "../../node_modules/@polkadot/types/codec/utils/index.js");

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0

/** @internal */
function decodeSetFromU8a(registry, ValClass, u8a) {
  const output = new Set();

  const [offset, length] = _Compact.default.decodeU8a(u8a);

  const types = [];

  for (let i = 0; i < length.toNumber(); i++) {
    types.push(ValClass);
  }

  const values = (0, _utils.decodeU8a)(registry, u8a.subarray(offset), types);

  for (let i = 0; i < values.length; i++) {
    output.add(values[i]);
  }

  return output;
}
/** @internal */


function decodeSetFromSet(registry, ValClass, value) {
  const output = new Set();
  value.forEach(val => {
    try {
      output.add(val instanceof ValClass ? val : new ValClass(registry, val));
    } catch (error) {
      console.error('Failed to decode BTreeSet key or value:', error.message);
      throw error;
    }
  });
  return output;
}
/**
 * Decode input to pass into constructor.
 *
 * @param ValClass - Type of the map value
 * @param value - Value to decode, one of:
 * - null
 * - undefined
 * - hex
 * - Uint8Array
 * - Set<any>, where both key and value types are either
 *   constructors or decodeable values for their types.
 * @param jsonSet
 * @internal
 */


function decodeSet(registry, valType, value) {
  if (!value) {
    return new Set();
  }

  const ValClass = (0, _utils.typeToConstructor)(registry, valType);

  if ((0, _util.isHex)(value)) {
    return decodeSet(registry, ValClass, (0, _util.hexToU8a)(value));
  } else if ((0, _util.isU8a)(value)) {
    return decodeSetFromU8a(registry, ValClass, (0, _util.u8aToU8a)(value));
  } else if (Array.isArray(value) || value instanceof Set) {
    return decodeSetFromSet(registry, ValClass, value);
  }

  throw new Error('BTreeSet: cannot decode type');
}

var _ValClass = (0, _classPrivateFieldLooseKey2.default)("ValClass");

class BTreeSet extends Set {
  constructor(registry, valType, rawValue) {
    super(decodeSet(registry, valType, rawValue));
    this.registry = void 0;
    Object.defineProperty(this, _ValClass, {
      writable: true,
      value: void 0
    });
    this.registry = registry;
    (0, _classPrivateFieldLooseBase2.default)(this, _ValClass)[_ValClass] = (0, _utils.typeToConstructor)(registry, valType);
  }

  static with(valType) {
    return class extends BTreeSet {
      constructor(registry, value) {
        super(registry, valType, value);
      }

    };
  }
  /**
   * @description The length of the value when encoded as a Uint8Array
   */


  get encodedLength() {
    let len = _Compact.default.encodeU8a(this.size).length;

    this.forEach(v => {
      len += v.encodedLength;
    });
    return len;
  }
  /**
   * @description Returns a hash of the value
   */


  get hash() {
    return new _Raw.default(this.registry, this.registry.hash(this.toU8a()));
  }
  /**
   * @description Checks if the value is an empty value
   */


  get isEmpty() {
    return this.size === 0;
  }
  /**
   * @description Compares the value of the input to see if there is a match
   */


  eq(other) {
    return (0, _utils.compareSet)(this, other);
  }
  /**
   * @description Returns a hex string representation of the value. isLe returns a LE (number-only) representation
   */


  toHex() {
    return (0, _util.u8aToHex)(this.toU8a());
  }
  /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */


  toHuman(isExtended) {
    const json = [];
    this.forEach(v => {
      json.push(v.toHuman(isExtended));
    });
    return json;
  }
  /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */


  toJSON() {
    const json = [];
    this.forEach(v => {
      json.push(v.toJSON());
    });
    return json;
  }
  /**
   * @description Returns the base runtime type name for this instance
   */


  toRawType() {
    return `BTreeSet<${this.registry.getClassName((0, _classPrivateFieldLooseBase2.default)(this, _ValClass)[_ValClass]) || new ((0, _classPrivateFieldLooseBase2.default)(this, _ValClass)[_ValClass])(this.registry).toRawType()}>`;
  }
  /**
   * @description Returns the string representation of the value
   */


  toString() {
    return JSON.stringify(this.toJSON());
  }
  /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */


  toU8a(isBare) {
    const encoded = new Array();

    if (!isBare) {
      encoded.push(_Compact.default.encodeU8a(this.size));
    }

    this.forEach(v => {
      encoded.push(v.toU8a(isBare));
    });
    return (0, _util.u8aConcat)(...encoded);
  }

}

exports.default = BTreeSet;

/***/ }),

/***/ "../../node_modules/@polkadot/types/codec/Base.js":
/*!*************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/codec/Base.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Raw = _interopRequireDefault(__webpack_require__(/*! ./Raw */ "../../node_modules/@polkadot/types/codec/Raw.js"));

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name Base
 * @description A type extends the Base class, when it holds a value
 */
class Base {
  constructor(registry, value) {
    this.registry = void 0;
    this._raw = void 0;
    this.registry = registry;
    this._raw = value;
  }
  /**
   * @description The length of the value when encoded as a Uint8Array
   */


  get encodedLength() {
    return this.toU8a().length;
  }
  /**
   * @description returns a hash of the contents
   */


  get hash() {
    return new _Raw.default(this.registry, this.registry.hash(this.toU8a()));
  }
  /**
   * @description Checks if the value is an empty value
   */


  get isEmpty() {
    return this._raw.isEmpty;
  }
  /**
   * @description Compares the value of the input to see if there is a match
   */


  eq(other) {
    return this._raw.eq(other);
  }
  /**
   * @description Returns a hex string representation of the value. isLe returns a LE (number-only) representation
   */


  toHex(isLe) {
    return this._raw.toHex(isLe);
  }
  /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */


  toHuman(isExtended) {
    return this._raw.toHuman(isExtended);
  }
  /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */


  toJSON() {
    return this._raw.toJSON();
  }
  /**
   * @description Returns the string representation of the value
   */


  toString() {
    return this._raw.toString();
  }
  /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */


  toU8a(isBare) {
    return this._raw.toU8a(isBare);
  }
  /**
   * @description Returns the base runtime type name for this instance
   */


  toRawType() {
    return 'Base';
  }

}

exports.default = Base;

/***/ }),

/***/ "../../node_modules/@polkadot/types/codec/Compact.js":
/*!****************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/codec/Compact.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classPrivateFieldLooseBase2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classPrivateFieldLooseBase */ "../../node_modules/@babel/runtime/helpers/classPrivateFieldLooseBase.js"));

var _classPrivateFieldLooseKey2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classPrivateFieldLooseKey */ "../../node_modules/@babel/runtime/helpers/classPrivateFieldLooseKey.js"));

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _defaults = __webpack_require__(/*! @polkadot/util/compact/defaults */ "../../node_modules/@polkadot/util/compact/defaults.js");

var _typeToConstructor = _interopRequireDefault(__webpack_require__(/*! ./utils/typeToConstructor */ "../../node_modules/@polkadot/types/codec/utils/typeToConstructor.js"));

var _Raw = _interopRequireDefault(__webpack_require__(/*! ./Raw */ "../../node_modules/@polkadot/types/codec/Raw.js"));

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _Type = (0, _classPrivateFieldLooseKey2.default)("Type");

var _raw = (0, _classPrivateFieldLooseKey2.default)("raw");

/**
 * @name Compact
 * @description
 * A compact length-encoding codec wrapper. It performs the same function as Length, however
 * differs in that it uses a variable number of bytes to do the actual encoding. This is mostly
 * used by other types to add length-prefixed encoding, or in the case of wrapped types, taking
 * a number and making the compact representation thereof
 */
class Compact {
  constructor(registry, Type, value = 0) {
    this.registry = void 0;
    Object.defineProperty(this, _Type, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _raw, {
      writable: true,
      value: void 0
    });
    this.registry = registry;
    (0, _classPrivateFieldLooseBase2.default)(this, _Type)[_Type] = (0, _typeToConstructor.default)(registry, Type);
    (0, _classPrivateFieldLooseBase2.default)(this, _raw)[_raw] = Compact.decodeCompact(registry, (0, _classPrivateFieldLooseBase2.default)(this, _Type)[_Type], value);
  }

  static with(Type) {
    return class extends Compact {
      constructor(registry, value) {
        super(registry, Type, value);
      }

    };
  }
  /**
   * Prepend a Uint8Array with its compact length.
   *
   * @param u8a - The Uint8Array to be prefixed
   */


  static stripLengthPrefix(u8a, bitLength = _defaults.DEFAULT_BITLENGTH) {
    const [, value] = (0, _util.compactStripLength)(u8a, bitLength);
    return value;
  }
  /** @internal */


  static decodeCompact(registry, Type, value) {
    if (value instanceof Compact) {
      return new Type(registry, (0, _classPrivateFieldLooseBase2.default)(value, _raw)[_raw]);
    } else if ((0, _util.isString)(value) || (0, _util.isNumber)(value) || (0, _util.isBn)(value) || (0, _util.isBigInt)(value)) {
      return new Type(registry, value);
    }

    const [, _value] = Compact.decodeU8a(value, new Type(registry, 0).bitLength());
    return new Type(registry, _value);
  }
  /**
   * @description The length of the value when encoded as a Uint8Array
   */


  get encodedLength() {
    return this.toU8a().length;
  }
  /**
   * @description returns a hash of the contents
   */


  get hash() {
    return new _Raw.default(this.registry, this.registry.hash(this.toU8a()));
  }
  /**
   * @description Checks if the value is an empty value
   */


  get isEmpty() {
    return (0, _classPrivateFieldLooseBase2.default)(this, _raw)[_raw].isEmpty;
  }
  /**
   * @description Returns the number of bits in the value
   */


  bitLength() {
    return (0, _classPrivateFieldLooseBase2.default)(this, _raw)[_raw].bitLength();
  }
  /**
   * @description Compares the value of the input to see if there is a match
   */


  eq(other) {
    return (0, _classPrivateFieldLooseBase2.default)(this, _raw)[_raw].eq(other instanceof Compact ? (0, _classPrivateFieldLooseBase2.default)(other, _raw)[_raw] : other);
  }
  /**
   * @description Returns a BigInt representation of the number
   */


  toBigInt() {
    return BigInt(this.toString());
  }
  /**
   * @description Returns the BN representation of the number
   */


  toBn() {
    return (0, _classPrivateFieldLooseBase2.default)(this, _raw)[_raw].toBn();
  }
  /**
   * @description Returns a hex string representation of the value. isLe returns a LE (number-only) representation
   */


  toHex(isLe) {
    return (0, _classPrivateFieldLooseBase2.default)(this, _raw)[_raw].toHex(isLe);
  }
  /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */


  toHuman(isExtended) {
    return (0, _classPrivateFieldLooseBase2.default)(this, _raw)[_raw].toHuman(isExtended);
  }
  /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */


  toJSON() {
    return (0, _classPrivateFieldLooseBase2.default)(this, _raw)[_raw].toJSON();
  }
  /**
   * @description Returns the number representation for the value
   */


  toNumber() {
    return (0, _classPrivateFieldLooseBase2.default)(this, _raw)[_raw].toNumber();
  }
  /**
   * @description Returns the base runtime type name for this instance
   */


  toRawType() {
    return `Compact<${this.registry.getClassName((0, _classPrivateFieldLooseBase2.default)(this, _Type)[_Type]) || (0, _classPrivateFieldLooseBase2.default)(this, _raw)[_raw].toRawType()}>`;
  }
  /**
   * @description Returns the string representation of the value
   */


  toString() {
    return (0, _classPrivateFieldLooseBase2.default)(this, _raw)[_raw].toString();
  }
  /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars


  toU8a(isBare) {
    return Compact.encodeU8a((0, _classPrivateFieldLooseBase2.default)(this, _raw)[_raw].toBn());
  }
  /**
   * @description Returns the embedded [[UInt]] or [[Moment]] value
   */


  unwrap() {
    return (0, _classPrivateFieldLooseBase2.default)(this, _raw)[_raw];
  }

}

exports.default = Compact;
Compact.addLengthPrefix = _util.compactAddLength;
Compact.decodeU8a = _util.compactFromU8a;
Compact.encodeU8a = _util.compactToU8a;

/***/ }),

/***/ "../../node_modules/@polkadot/types/codec/Enum.js":
/*!*************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/codec/Enum.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classPrivateFieldLooseBase2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classPrivateFieldLooseBase */ "../../node_modules/@babel/runtime/helpers/classPrivateFieldLooseBase.js"));

var _classPrivateFieldLooseKey2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classPrivateFieldLooseKey */ "../../node_modules/@babel/runtime/helpers/classPrivateFieldLooseKey.js"));

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _Null = _interopRequireDefault(__webpack_require__(/*! ../primitive/Null */ "../../node_modules/@polkadot/types/primitive/Null.js"));

var _utils = __webpack_require__(/*! ./utils */ "../../node_modules/@polkadot/types/codec/utils/index.js");

var _Raw = _interopRequireDefault(__webpack_require__(/*! ./Raw */ "../../node_modules/@polkadot/types/codec/Raw.js"));

var _Struct = _interopRequireDefault(__webpack_require__(/*! ./Struct */ "../../node_modules/@polkadot/types/codec/Struct.js"));

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
function extractDef(registry, _def) {
  if (!Array.isArray(_def)) {
    const def = (0, _utils.mapToTypeMap)(registry, _def);
    const isBasic = !Object.values(def).some(type => type !== _Null.default);
    return {
      def,
      isBasic
    };
  }

  return {
    def: _def.reduce((def, key) => {
      def[key] = _Null.default;
      return def;
    }, {}),
    isBasic: true
  };
}

function createFromValue(registry, def, index = 0, value) {
  const Clazz = Object.values(def)[index];
  (0, _util.assert)(!(0, _util.isUndefined)(Clazz), `Unable to create Enum via index ${index}, in ${Object.keys(def).join(', ')}`);
  return {
    index,
    value: value instanceof Clazz ? value : new Clazz(registry, value)
  };
}

function decodeFromJSON(registry, def, key, value) {
  // JSON comes in the form of { "<type (lowercased)>": "<value for type>" }, here we
  // additionally force to lower to ensure forward compat
  const keys = Object.keys(def).map(k => k.toLowerCase());
  const keyLower = key.toLowerCase();
  const index = keys.indexOf(keyLower);
  (0, _util.assert)(index !== -1, `Cannot map Enum JSON, unable to find '${key}' in ${keys.join(', ')}`);

  try {
    return createFromValue(registry, def, index, value);
  } catch (error) {
    throw new Error(`Enum(${key}):: ${error.message}`);
  }
}

function decodeFromString(registry, def, value) {
  return (0, _util.isHex)(value) // eslint-disable-next-line @typescript-eslint/no-use-before-define
  ? decodeFromValue(registry, def, (0, _util.hexToU8a)(value)) : decodeFromJSON(registry, def, value);
}

function decodeFromValue(registry, def, value) {
  if ((0, _util.isU8a)(value)) {
    return createFromValue(registry, def, value[0], value.subarray(1));
  } else if ((0, _util.isNumber)(value)) {
    return createFromValue(registry, def, value);
  } else if ((0, _util.isString)(value)) {
    return decodeFromString(registry, def, value.toString());
  } else if ((0, _util.isObject)(value)) {
    const key = Object.keys(value)[0];
    return decodeFromJSON(registry, def, key, value[key]);
  } // Worst-case scenario, return the first with default


  return createFromValue(registry, def, 0);
}

function decodeEnum(registry, def, value, index) {
  // NOTE We check the index path first, before looking at values - this allows treating
  // the optional indexes before anything else, more-specific > less-specific
  if ((0, _util.isNumber)(index)) {
    return createFromValue(registry, def, index, value); // eslint-disable-next-line @typescript-eslint/no-use-before-define
  } else if (value instanceof Enum) {
    return createFromValue(registry, def, value.index, value.value);
  } // Or else, we just look at `value`


  return decodeFromValue(registry, def, value);
}
/**
 * @name Enum
 * @description
 * This implements an enum, that based on the value wraps a different type. It is effectively
 * an extension to enum where the value type is determined by the actual index.
 */
// TODO:
//   - As per Enum, actually use TS enum
//   - It should rather probably extend Enum instead of copying code


var _def2 = (0, _classPrivateFieldLooseKey2.default)("def");

var _index = (0, _classPrivateFieldLooseKey2.default)("index");

var _indexes = (0, _classPrivateFieldLooseKey2.default)("indexes");

var _isBasic = (0, _classPrivateFieldLooseKey2.default)("isBasic");

var _raw = (0, _classPrivateFieldLooseKey2.default)("raw");

class Enum {
  constructor(registry, def, value, index) {
    this.registry = void 0;
    Object.defineProperty(this, _def2, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _index, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _indexes, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _isBasic, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _raw, {
      writable: true,
      value: void 0
    });
    const defInfo = extractDef(registry, def);
    const decoded = decodeEnum(registry, defInfo.def, value, index);
    this.registry = registry;
    (0, _classPrivateFieldLooseBase2.default)(this, _def2)[_def2] = defInfo.def;
    (0, _classPrivateFieldLooseBase2.default)(this, _isBasic)[_isBasic] = defInfo.isBasic;
    (0, _classPrivateFieldLooseBase2.default)(this, _indexes)[_indexes] = Object.keys(defInfo.def).map((_, index) => index);
    (0, _classPrivateFieldLooseBase2.default)(this, _index)[_index] = (0, _classPrivateFieldLooseBase2.default)(this, _indexes)[_indexes].indexOf(decoded.index) || 0;
    (0, _classPrivateFieldLooseBase2.default)(this, _raw)[_raw] = decoded.value;
  }

  static with(Types) {
    return class extends Enum {
      constructor(registry, value, index) {
        super(registry, Types, value, index);
        Object.keys((0, _classPrivateFieldLooseBase2.default)(this, _def2)[_def2]).forEach(_key => {
          const name = (0, _util.stringUpperFirst)((0, _util.stringCamelCase)(_key.replace(' ', '_')));
          const askey = `as${name}`;
          const iskey = `is${name}`; // do not clobber existing properties on the object
          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access

          if ((0, _util.isUndefined)(this[iskey])) {
            Object.defineProperty(this, iskey, {
              enumerable: true,
              get: () => this.type === _key
            });
          } // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access


          if ((0, _util.isUndefined)(this[askey])) {
            Object.defineProperty(this, askey, {
              enumerable: true,
              get: () => {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                (0, _util.assert)(this[iskey], `Cannot convert '${this.type}' via ${askey}`);
                return this.value;
              }
            });
          }
        });
      }

    };
  }
  /**
   * @description The length of the value when encoded as a Uint8Array
   */


  get encodedLength() {
    return 1 + (0, _classPrivateFieldLooseBase2.default)(this, _raw)[_raw].encodedLength;
  }
  /**
   * @description returns a hash of the contents
   */


  get hash() {
    return new _Raw.default(this.registry, this.registry.hash(this.toU8a()));
  }
  /**
   * @description The index of the metadata value
   */


  get index() {
    return (0, _classPrivateFieldLooseBase2.default)(this, _index)[_index];
  }
  /**
   * @description true if this is a basic enum (no values)
   */


  get isBasic() {
    return (0, _classPrivateFieldLooseBase2.default)(this, _isBasic)[_isBasic];
  }
  /**
   * @description Checks if the value is an empty value
   */


  get isEmpty() {
    return (0, _classPrivateFieldLooseBase2.default)(this, _raw)[_raw].isEmpty;
  }
  /**
   * @description Checks if the Enum points to a [[Null]] type
   */


  get isNone() {
    return this.isNull;
  }
  /**
   * @description Checks if the Enum points to a [[Null]] type (deprecated, use isNone)
   */


  get isNull() {
    return (0, _classPrivateFieldLooseBase2.default)(this, _raw)[_raw] instanceof _Null.default;
  }
  /**
   * @description The available keys for this enum
   */


  get defEntries() {
    return Object.keys((0, _classPrivateFieldLooseBase2.default)(this, _def2)[_def2]);
  }
  /**
   * @description The available keys for this enum
   */


  get defKeys() {
    return Object.keys((0, _classPrivateFieldLooseBase2.default)(this, _def2)[_def2]);
  }
  /**
   * @description The name of the type this enum value represents
   */


  get type() {
    return this.defKeys[(0, _classPrivateFieldLooseBase2.default)(this, _index)[_index]];
  }
  /**
   * @description The value of the enum
   */


  get value() {
    return (0, _classPrivateFieldLooseBase2.default)(this, _raw)[_raw];
  }
  /**
   * @description Compares the value of the input to see if there is a match
   */


  eq(other) {
    // cater for the case where we only pass the enum index
    if ((0, _util.isNumber)(other)) {
      return this.toNumber() === other;
    } else if ((0, _classPrivateFieldLooseBase2.default)(this, _isBasic)[_isBasic] && (0, _util.isString)(other)) {
      return this.type === other;
    } else if ((0, _util.isU8a)(other)) {
      return !this.toU8a().some((entry, index) => entry !== other[index]);
    } else if ((0, _util.isHex)(other)) {
      return this.toHex() === other;
    } else if (other instanceof Enum) {
      return this.index === other.index && this.value.eq(other.value);
    } else if ((0, _util.isObject)(other)) {
      return this.value.eq(other[this.type]);
    } // compare the actual wrapper value


    return this.value.eq(other);
  }
  /**
   * @description Returns a hex string representation of the value
   */


  toHex() {
    return (0, _util.u8aToHex)(this.toU8a());
  }
  /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */


  toHuman(isExtended) {
    return (0, _classPrivateFieldLooseBase2.default)(this, _isBasic)[_isBasic] ? this.type : {
      [this.type]: (0, _classPrivateFieldLooseBase2.default)(this, _raw)[_raw].toHuman(isExtended)
    };
  }
  /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */


  toJSON() {
    return (0, _classPrivateFieldLooseBase2.default)(this, _isBasic)[_isBasic] ? this.type : {
      [this.type]: (0, _classPrivateFieldLooseBase2.default)(this, _raw)[_raw].toJSON()
    };
  }
  /**
   * @description Returns the number representation for the value
   */


  toNumber() {
    return (0, _classPrivateFieldLooseBase2.default)(this, _index)[_index];
  }
  /**
   * @description Returns a raw struct representation of the enum types
   */


  _toRawStruct() {
    return (0, _classPrivateFieldLooseBase2.default)(this, _isBasic)[_isBasic] ? this.defKeys : _Struct.default.typesToMap(this.registry, (0, _classPrivateFieldLooseBase2.default)(this, _def2)[_def2]);
  }
  /**
   * @description Returns the base runtime type name for this instance
   */


  toRawType() {
    return JSON.stringify({
      _enum: this._toRawStruct()
    });
  }
  /**
   * @description Returns the string representation of the value
   */


  toString() {
    return this.isNull ? this.type : JSON.stringify(this.toJSON());
  }
  /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */


  toU8a(isBare) {
    return (0, _util.u8aConcat)(new Uint8Array(isBare ? [] : [(0, _classPrivateFieldLooseBase2.default)(this, _indexes)[_indexes][(0, _classPrivateFieldLooseBase2.default)(this, _index)[_index]]]), (0, _classPrivateFieldLooseBase2.default)(this, _raw)[_raw].toU8a(isBare));
  }

}

exports.default = Enum;

/***/ }),

/***/ "../../node_modules/@polkadot/types/codec/HashMap.js":
/*!****************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/codec/HashMap.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Map = _interopRequireDefault(__webpack_require__(/*! ./Map */ "../../node_modules/@polkadot/types/codec/Map.js"));

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
class HashMap extends _Map.default {
  static with(keyType, valType) {
    return class extends HashMap {
      constructor(registry, value) {
        super(registry, 'HashMap', keyType, valType, value);
      }

    };
  }

}

exports.default = HashMap;

/***/ }),

/***/ "../../node_modules/@polkadot/types/codec/Int.js":
/*!************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/codec/Int.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "../../node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _AbstractInt = _interopRequireWildcard(__webpack_require__(/*! ./AbstractInt */ "../../node_modules/@polkadot/types/codec/AbstractInt.js"));

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name Int
 * @description
 * A generic signed integer codec. For Substrate all numbers are Little Endian encoded,
 * this handles the encoding and decoding of those numbers. Upon construction
 * the bitLength is provided and any additional use keeps the number to this
 * length. This extends `BN`, so all methods available on a normal `BN` object
 * is available here.
 * @noInheritDoc
 */
class Int extends _AbstractInt.default {
  constructor(registry, value = 0, bitLength = _AbstractInt.DEFAULT_UINT_BITS, isHexJson = true) {
    super(registry, true, value, bitLength, isHexJson);
  }

  static with(bitLength, typeName) {
    return class extends Int {
      constructor(registry, value) {
        super(registry, value, bitLength);
      }

      toRawType() {
        return typeName || super.toRawType();
      }

    };
  }

}

exports.default = Int;

/***/ }),

/***/ "../../node_modules/@polkadot/types/codec/Linkage.js":
/*!****************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/codec/Linkage.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LinkageResult = exports.default = void 0;

var _Option = _interopRequireDefault(__webpack_require__(/*! ./Option */ "../../node_modules/@polkadot/types/codec/Option.js"));

var _Struct = _interopRequireDefault(__webpack_require__(/*! ./Struct */ "../../node_modules/@polkadot/types/codec/Struct.js"));

var _Tuple = _interopRequireDefault(__webpack_require__(/*! ./Tuple */ "../../node_modules/@polkadot/types/codec/Tuple.js"));

var _Vec = _interopRequireDefault(__webpack_require__(/*! ./Vec */ "../../node_modules/@polkadot/types/codec/Vec.js"));

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
const EMPTY = new Uint8Array();
/**
 * @name Linkage
 * @description The wrapper for the result from a LinkedMap
 */

class Linkage extends _Struct.default {
  constructor(registry, Type, value) {
    super(registry, {
      previous: _Option.default.with(Type),
      // eslint-disable-next-line sort-keys
      next: _Option.default.with(Type)
    }, value);
    console.error([...this.entries()]);
  }

  static withKey(Type) {
    return class extends Linkage {
      constructor(registry, value) {
        super(registry, Type, value);
      }

    };
  }

  get previous() {
    return this.get('previous');
  }

  get next() {
    return this.get('next');
  }
  /**
   * @description Returns the base runtime type name for this instance
   */


  toRawType() {
    return `Linkage<${this.next.toRawType(true)}>`;
  }
  /**
   * @description Custom toU8a which with bare mode does not return the linkage if empty
   */


  toU8a() {
    // As part of a storage query (where these appear), in the case of empty, the values
    // are NOT populated by the node - follow the same logic, leaving it empty
    return this.isEmpty ? EMPTY : super.toU8a();
  }

}
/**
 * @name LinkageResult
 * @description A Linkage keys/Values tuple
 */


exports.default = Linkage;

class LinkageResult extends _Tuple.default {
  constructor(registry, [TypeKey, keys], [TypeValue, values]) {
    super(registry, {
      Keys: _Vec.default.with(TypeKey),
      Values: _Vec.default.with(TypeValue)
    }, [keys, values]);
  }

}

exports.LinkageResult = LinkageResult;

/***/ }),

/***/ "../../node_modules/@polkadot/types/codec/Map.js":
/*!************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/codec/Map.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classPrivateFieldLooseBase2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classPrivateFieldLooseBase */ "../../node_modules/@babel/runtime/helpers/classPrivateFieldLooseBase.js"));

var _classPrivateFieldLooseKey2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classPrivateFieldLooseKey */ "../../node_modules/@babel/runtime/helpers/classPrivateFieldLooseKey.js"));

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _Compact = _interopRequireDefault(__webpack_require__(/*! ./Compact */ "../../node_modules/@polkadot/types/codec/Compact.js"));

var _Raw = _interopRequireDefault(__webpack_require__(/*! ./Raw */ "../../node_modules/@polkadot/types/codec/Raw.js"));

var _compareMap = _interopRequireDefault(__webpack_require__(/*! ./utils/compareMap */ "../../node_modules/@polkadot/types/codec/utils/compareMap.js"));

var _decodeU8a = _interopRequireDefault(__webpack_require__(/*! ./utils/decodeU8a */ "../../node_modules/@polkadot/types/codec/utils/decodeU8a.js"));

var _typeToConstructor = _interopRequireDefault(__webpack_require__(/*! ./utils/typeToConstructor */ "../../node_modules/@polkadot/types/codec/utils/typeToConstructor.js"));

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0

/** @internal */
function decodeMapFromU8a(registry, KeyClass, ValClass, u8a) {
  const output = new Map();

  const [offset, length] = _Compact.default.decodeU8a(u8a);

  const types = [];

  for (let i = 0; i < length.toNumber(); i++) {
    types.push(KeyClass, ValClass);
  }

  const values = (0, _decodeU8a.default)(registry, u8a.subarray(offset), types);

  for (let i = 0; i < values.length; i += 2) {
    output.set(values[i], values[i + 1]);
  }

  return output;
}
/** @internal */


function decodeMapFromMap(registry, KeyClass, ValClass, value) {
  const output = new Map();
  value.forEach((val, key) => {
    try {
      output.set(key instanceof KeyClass ? key : new KeyClass(registry, key), val instanceof ValClass ? val : new ValClass(registry, val));
    } catch (error) {
      console.error('Failed to decode Map key or value:', error.message);
      throw error;
    }
  });
  return output;
}
/**
 * Decode input to pass into constructor.
 *
 * @param KeyClass - Type of the map key
 * @param ValClass - Type of the map value
 * @param value - Value to decode, one of:
 * - null
 * - undefined
 * - hex
 * - Uint8Array
 * - Map<any, any>, where both key and value types are either
 *   constructors or decodeable values for their types.
 * @param jsonMap
 * @internal
 */


function decodeMap(registry, keyType, valType, value) {
  const KeyClass = (0, _typeToConstructor.default)(registry, keyType);
  const ValClass = (0, _typeToConstructor.default)(registry, valType);

  if (!value) {
    return new Map();
  } else if ((0, _util.isHex)(value)) {
    return decodeMap(registry, KeyClass, ValClass, (0, _util.hexToU8a)(value));
  } else if ((0, _util.isU8a)(value)) {
    return decodeMapFromU8a(registry, KeyClass, ValClass, (0, _util.u8aToU8a)(value));
  } else if (value instanceof Map) {
    return decodeMapFromMap(registry, KeyClass, ValClass, value);
  } else if ((0, _util.isObject)(value)) {
    return decodeMapFromMap(registry, KeyClass, ValClass, new Map(Object.entries(value)));
  }

  throw new Error('Map: cannot decode type');
}

var _KeyClass = (0, _classPrivateFieldLooseKey2.default)("KeyClass");

var _ValClass = (0, _classPrivateFieldLooseKey2.default)("ValClass");

var _type = (0, _classPrivateFieldLooseKey2.default)("type");

class CodecMap extends Map {
  constructor(registry, type, keyType, valType, rawValue) {
    super(decodeMap(registry, keyType, valType, rawValue));
    this.registry = void 0;
    Object.defineProperty(this, _KeyClass, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _ValClass, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _type, {
      writable: true,
      value: void 0
    });
    this.registry = registry;
    (0, _classPrivateFieldLooseBase2.default)(this, _KeyClass)[_KeyClass] = (0, _typeToConstructor.default)(registry, keyType);
    (0, _classPrivateFieldLooseBase2.default)(this, _ValClass)[_ValClass] = (0, _typeToConstructor.default)(registry, valType);
    (0, _classPrivateFieldLooseBase2.default)(this, _type)[_type] = type;
  }
  /**
   * @description The length of the value when encoded as a Uint8Array
   */


  get encodedLength() {
    let len = _Compact.default.encodeU8a(this.size).length;

    this.forEach((v, k) => {
      len += v.encodedLength + k.encodedLength;
    });
    return len;
  }
  /**
   * @description Returns a hash of the value
   */


  get hash() {
    return new _Raw.default(this.registry, this.registry.hash(this.toU8a()));
  }
  /**
   * @description Checks if the value is an empty value
   */


  get isEmpty() {
    return this.size === 0;
  }
  /**
   * @description Compares the value of the input to see if there is a match
   */


  eq(other) {
    return (0, _compareMap.default)(this, other);
  }
  /**
   * @description Returns a hex string representation of the value. isLe returns a LE (number-only) representation
   */


  toHex() {
    return (0, _util.u8aToHex)(this.toU8a());
  }
  /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */


  toHuman(isExtended) {
    const json = {};
    this.forEach((v, k) => {
      json[k.toString()] = v.toHuman(isExtended);
    });
    return json;
  }
  /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */


  toJSON() {
    const json = {};
    this.forEach((v, k) => {
      json[k.toString()] = v.toJSON();
    });
    return json;
  }
  /**
   * @description Returns the base runtime type name for this instance
   */


  toRawType() {
    return `${(0, _classPrivateFieldLooseBase2.default)(this, _type)[_type]}<${this.registry.getClassName((0, _classPrivateFieldLooseBase2.default)(this, _KeyClass)[_KeyClass]) || new ((0, _classPrivateFieldLooseBase2.default)(this, _KeyClass)[_KeyClass])(this.registry).toRawType()},${this.registry.getClassName((0, _classPrivateFieldLooseBase2.default)(this, _ValClass)[_ValClass]) || new ((0, _classPrivateFieldLooseBase2.default)(this, _ValClass)[_ValClass])(this.registry).toRawType()}>`;
  }
  /**
   * @description Returns the string representation of the value
   */


  toString() {
    return JSON.stringify(this.toJSON());
  }
  /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */


  toU8a(isBare) {
    const encoded = new Array();

    if (!isBare) {
      encoded.push(_Compact.default.encodeU8a(this.size));
    }

    this.forEach((v, k) => {
      encoded.push(k.toU8a(isBare), v.toU8a(isBare));
    });
    return (0, _util.u8aConcat)(...encoded);
  }

}

exports.default = CodecMap;

/***/ }),

/***/ "../../node_modules/@polkadot/types/codec/Option.js":
/*!***************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/codec/Option.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classPrivateFieldLooseBase2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classPrivateFieldLooseBase */ "../../node_modules/@babel/runtime/helpers/classPrivateFieldLooseBase.js"));

var _classPrivateFieldLooseKey2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classPrivateFieldLooseKey */ "../../node_modules/@babel/runtime/helpers/classPrivateFieldLooseKey.js"));

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _Null = _interopRequireDefault(__webpack_require__(/*! ../primitive/Null */ "../../node_modules/@polkadot/types/primitive/Null.js"));

var _utils = __webpack_require__(/*! ./utils */ "../../node_modules/@polkadot/types/codec/utils/index.js");

var _Raw = _interopRequireDefault(__webpack_require__(/*! ./Raw */ "../../node_modules/@polkadot/types/codec/Raw.js"));

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0

/** @internal */
function decodeOptionU8a(registry, Type, value) {
  return !value.length || value[0] === 0 ? new _Null.default(registry) : new Type(registry, value.subarray(1));
}
/** @internal */


function decodeOption(registry, typeName, value) {
  if ((0, _util.isNull)(value) || (0, _util.isUndefined)(value) || value instanceof _Null.default) {
    return new _Null.default(registry);
  }

  const Type = (0, _utils.typeToConstructor)(registry, typeName); // eslint-disable-next-line @typescript-eslint/no-use-before-define

  if (value instanceof Option) {
    return decodeOption(registry, Type, value.value);
  } else if (value instanceof Type) {
    // don't re-create, use as it (which also caters for derived types)
    return value;
  } else if ((0, _util.isU8a)(value)) {
    // the isU8a check happens last in the if-tree - since the wrapped value
    // may be an instance of it, so Type and Option checks go in first
    return decodeOptionU8a(registry, Type, value);
  }

  return new Type(registry, value);
}
/**
 * @name Option
 * @description
 * An Option is an optional field. Basically the first byte indicates that there is
 * is value to follow. If the byte is `1` there is an actual value. So the Option
 * implements that - decodes, checks for optionality and wraps the required structure
 * with a value if/as required/found.
 */


var _Type = (0, _classPrivateFieldLooseKey2.default)("Type");

var _raw = (0, _classPrivateFieldLooseKey2.default)("raw");

class Option {
  constructor(registry, typeName, value) {
    this.registry = void 0;
    Object.defineProperty(this, _Type, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _raw, {
      writable: true,
      value: void 0
    });
    this.registry = registry;
    (0, _classPrivateFieldLooseBase2.default)(this, _Type)[_Type] = (0, _utils.typeToConstructor)(registry, typeName);
    (0, _classPrivateFieldLooseBase2.default)(this, _raw)[_raw] = decodeOption(registry, typeName, value);
  }

  static with(Type) {
    return class extends Option {
      constructor(registry, value) {
        super(registry, Type, value);
      }

    };
  }
  /**
   * @description The length of the value when encoded as a Uint8Array
   */


  get encodedLength() {
    // boolean byte (has value, doesn't have) along with wrapped length
    return 1 + (0, _classPrivateFieldLooseBase2.default)(this, _raw)[_raw].encodedLength;
  }
  /**
   * @description returns a hash of the contents
   */


  get hash() {
    return new _Raw.default(this.registry, this.registry.hash(this.toU8a()));
  }
  /**
   * @description Checks if the Option has no value
   */


  get isEmpty() {
    return this.isNone;
  }
  /**
   * @description Checks if the Option has no value
   */


  get isNone() {
    return (0, _classPrivateFieldLooseBase2.default)(this, _raw)[_raw] instanceof _Null.default;
  }
  /**
   * @description Checks if the Option has a value
   */


  get isSome() {
    return !this.isNone;
  }
  /**
   * @description The actual value for the Option
   */


  get value() {
    return (0, _classPrivateFieldLooseBase2.default)(this, _raw)[_raw];
  }
  /**
   * @description Compares the value of the input to see if there is a match
   */


  eq(other) {
    if (other instanceof Option) {
      return this.isSome === other.isSome && this.value.eq(other.value);
    }

    return this.value.eq(other);
  }
  /**
   * @description Returns a hex string representation of the value
   */


  toHex() {
    // This attempts to align with the JSON encoding - actually in this case
    // the isSome value is correct, however the `isNone` may be problematic
    return this.isNone ? '0x' : (0, _util.u8aToHex)(this.toU8a().subarray(1));
  }
  /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */


  toHuman(isExtended) {
    return (0, _classPrivateFieldLooseBase2.default)(this, _raw)[_raw].toHuman(isExtended);
  }
  /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */


  toJSON() {
    return (0, _classPrivateFieldLooseBase2.default)(this, _raw)[_raw].toJSON();
  }
  /**
   * @description Returns the base runtime type name for this instance
   */


  toRawType(isBare) {
    const wrapped = this.registry.getClassName((0, _classPrivateFieldLooseBase2.default)(this, _Type)[_Type]) || new ((0, _classPrivateFieldLooseBase2.default)(this, _Type)[_Type])(this.registry).toRawType();
    return isBare ? wrapped : `Option<${wrapped}>`;
  }
  /**
   * @description Returns the string representation of the value
   */


  toString() {
    return (0, _classPrivateFieldLooseBase2.default)(this, _raw)[_raw].toString();
  }
  /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */


  toU8a(isBare) {
    if (isBare) {
      return (0, _classPrivateFieldLooseBase2.default)(this, _raw)[_raw].toU8a(true);
    }

    const u8a = new Uint8Array(this.encodedLength);

    if (this.isSome) {
      u8a.set([1]);
      u8a.set((0, _classPrivateFieldLooseBase2.default)(this, _raw)[_raw].toU8a(), 1);
    }

    return u8a;
  }
  /**
   * @description Returns the value that the Option represents (if available), throws if null
   */


  unwrap() {
    if (this.isNone) {
      throw new Error('Option: unwrapping a None value');
    }

    return (0, _classPrivateFieldLooseBase2.default)(this, _raw)[_raw];
  }
  /**
   * @description Returns the value that the Option represents (if available) or defaultValue if none
   * @param defaultValue The value to return if the option isNone
   */


  unwrapOr(defaultValue) {
    return this.isSome ? this.unwrap() : defaultValue;
  }
  /**
   * @description Returns the value that the Option represents (if available) or defaultValue if none
   * @param defaultValue The value to return if the option isNone
   */


  unwrapOrDefault() {
    return this.isSome ? this.unwrap() : new ((0, _classPrivateFieldLooseBase2.default)(this, _Type)[_Type])(this.registry);
  }

}

exports.default = Option;

/***/ }),

/***/ "../../node_modules/@polkadot/types/codec/Raw.js":
/*!************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/codec/Raw.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0

/** @internal */
function decodeU8a(value) {
  if ((0, _util.isU8a)(value)) {
    return value;
  }

  return (0, _util.u8aToU8a)(value);
}
/**
 * @name Raw
 * @description
 * A basic wrapper around Uint8Array, with no frills and no fuss. It does differ
 * from other implementations where it will consume the full Uint8Array as passed to it.
 * As such it is meant to be subclassed where the wrapper takes care of the
 * actual lengths instead of used directly.
 * @noInheritDoc
 */


class Raw extends Uint8Array {
  constructor(registry, value) {
    super(decodeU8a(value));
    this.registry = void 0;
    this.registry = registry;
  }
  /**
   * @description The length of the value when encoded as a Uint8Array
   */


  get encodedLength() {
    return this.length;
  }
  /**
   * @description returns a hash of the contents
   */


  get hash() {
    return new Raw(this.registry, this.registry.hash(this.toU8a()));
  }
  /**
   * @description Returns true if the wrapped value contains only ASCII printable characters
   */


  get isAscii() {
    return (0, _util.isAscii)(this);
  }
  /**
   * @description Returns true if the type wraps an empty/default all-0 value
   */


  get isEmpty() {
    return !this.length || (0, _util.isUndefined)(this.find(value => !!value));
  }
  /**
   * @description Returns true if the wrapped value contains only utf8 characters
   */


  get isUtf8() {
    return (0, _util.isUtf8)(this);
  }
  /**
   * @description The length of the value
   */


  get length() {
    // only included here since we ignore inherited docs
    return super.length;
  }
  /**
   * @description Returns the number of bits in the value
   */


  bitLength() {
    return this.length * 8;
  }
  /**
   * @description Compares the value of the input to see if there is a match
   */


  eq(other) {
    if (other instanceof Uint8Array) {
      return this.length === other.length && !this.some((value, index) => value !== other[index]);
    }

    return this.eq(decodeU8a(other));
  }
  /**
   * @description Create a new subarray from the actual buffer. This is needed for compat reasons since a new Uint8Array gets returned here
   * @param begin The position to start at
   * @param end The position to end at
   */


  subarray(begin, end) {
    return Uint8Array.from(this).subarray(begin, end);
  }
  /**
   * @description Returns a hex string representation of the value
   */


  toHex() {
    return (0, _util.u8aToHex)(this);
  }
  /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */


  toHuman() {
    return this.isAscii ? this.toUtf8() : this.toJSON();
  }
  /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */


  toJSON() {
    return this.toHex();
  }
  /**
   * @description Returns the base runtime type name for this instance
   */


  toRawType() {
    return 'Raw';
  }
  /**
   * @description Returns the string representation of the value
   */


  toString() {
    return this.toHex();
  }
  /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars


  toU8a(isBare) {
    return Uint8Array.from(this);
  }
  /**
   * @description Returns the wrapped data as a UTF-8 string
   */


  toUtf8() {
    (0, _util.assert)(this.isUtf8, 'The character sequence is not a valid Utf8 string');
    return (0, _util.u8aToString)(this);
  }

}

exports.default = Raw;

/***/ }),

/***/ "../../node_modules/@polkadot/types/codec/Result.js":
/*!***************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/codec/Result.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _Enum = _interopRequireDefault(__webpack_require__(/*! ./Enum */ "../../node_modules/@polkadot/types/codec/Enum.js"));

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name Result
 * @description
 * A Result maps to the Rust Result type, that can either wrap a success or error value
 */
class Result extends _Enum.default {
  constructor(registry, Ok, Error, value) {
    // NOTE This is order-dependent, Ok (with index 0) needs to be first
    // eslint-disable-next-line sort-keys
    super(registry, {
      Ok,
      Error
    }, value);
  }

  static with(Types) {
    return class extends Result {
      constructor(registry, value) {
        super(registry, Types.Ok, Types.Error, value);
      }

    };
  }
  /**
   * @description Returns the wrapper Error value (if isError)
   */


  get asError() {
    (0, _util.assert)(this.isError, 'Cannot extract Error value from Ok result, check isError first');
    return this.value;
  }
  /**
   * @description Returns the wrapper Ok value (if isOk)
   */


  get asOk() {
    (0, _util.assert)(this.isOk, 'Cannot extract Ok value from Error result, check isOk first');
    return this.value;
  }
  /**
   * @description Checks if the Result has no value
   */


  get isEmpty() {
    return this.isOk && this.value.isEmpty;
  }
  /**
   * @description Checks if the Result wraps an Error value
   */


  get isError() {
    return !this.isOk;
  }
  /**
   * @description Checks if the Result wraps an Ok value
   */


  get isOk() {
    return this.index === 0;
  }
  /**
   * @description Returns the base runtime type name for this instance
   */


  toRawType() {
    const Types = this._toRawStruct();

    return `Result<${Types.Ok},${Types.Error}>`;
  }

}

exports.default = Result;

/***/ }),

/***/ "../../node_modules/@polkadot/types/codec/Set.js":
/*!************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/codec/Set.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classPrivateFieldLooseBase2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classPrivateFieldLooseBase */ "../../node_modules/@babel/runtime/helpers/classPrivateFieldLooseBase.js"));

var _classPrivateFieldLooseKey2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classPrivateFieldLooseKey */ "../../node_modules/@babel/runtime/helpers/classPrivateFieldLooseKey.js"));

var _bn = _interopRequireDefault(__webpack_require__(/*! bn.js */ "../../node_modules/bn.js/lib/bn.js"));

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _Raw = _interopRequireDefault(__webpack_require__(/*! ./Raw */ "../../node_modules/@polkadot/types/codec/Raw.js"));

var _utils = __webpack_require__(/*! ./utils */ "../../node_modules/@polkadot/types/codec/utils/index.js");

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
function encodeSet(setValues, value) {
  return value.reduce((result, value) => {
    return result.or((0, _util.bnToBn)(setValues[value] || 0));
  }, new _bn.default(0));
}
/** @internal */


function decodeSetArray(setValues, value) {
  return value.reduce((result, key) => {
    (0, _util.assert)(!(0, _util.isUndefined)(setValues[key]), `Set: Invalid key '${key}' passed to Set, allowed ${Object.keys(setValues).join(', ')}`);
    result.push(key);
    return result;
  }, []);
}
/** @internal */


function decodeSetNumber(setValues, _value) {
  const bn = (0, _util.bnToBn)(_value);
  const result = Object.keys(setValues).reduce((result, key) => {
    if (bn.and((0, _util.bnToBn)(setValues[key])).eq((0, _util.bnToBn)(setValues[key]))) {
      result.push(key);
    }

    return result;
  }, []);
  const computed = encodeSet(setValues, result);
  (0, _util.assert)(bn.eq(computed), `Set: Mismatch decoding '${bn.toString()}', computed as '${computed.toString()}' with ${result.join(', ')}`);
  return result;
}
/** @internal */


function decodeSet(setValues, value = 0, bitLength) {
  (0, _util.assert)(bitLength % 8 === 0, `Expected valid bitLength, power of 8, found ${bitLength}`);
  const byteLength = bitLength / 8;

  if ((0, _util.isString)(value)) {
    return decodeSet(setValues, (0, _util.u8aToU8a)(value), byteLength);
  } else if ((0, _util.isU8a)(value)) {
    return value.length === 0 ? [] : decodeSetNumber(setValues, (0, _util.u8aToBn)(value.subarray(0, byteLength), {
      isLe: true
    }));
  } else if (value instanceof Set || Array.isArray(value)) {
    const input = Array.isArray(value) ? value : [...value.values()];
    return decodeSetArray(setValues, input);
  }

  return decodeSetNumber(setValues, value);
}
/**
 * @name Set
 * @description
 * An Set is an array of string values, represented an an encoded type by
 * a bitwise representation of the values.
 */
// FIXME This is a prime candidate to extend the JavaScript built-in Set


var _allowed = (0, _classPrivateFieldLooseKey2.default)("allowed");

var _byteLength = (0, _classPrivateFieldLooseKey2.default)("byteLength");

class CodecSet extends Set {
  constructor(registry, setValues, value, bitLength = 8) {
    super(decodeSet(setValues, value, bitLength));
    this.registry = void 0;
    Object.defineProperty(this, _allowed, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _byteLength, {
      writable: true,
      value: void 0
    });

    this.add = key => {
      // ^^^ add = () property done to assign this instance's this, otherwise Set.add creates "some" chaos
      // we have the isUndefined(this._setValues) in here as well, add is used internally
      // in the Set constructor (so it is undefined at this point, and should allow)
      (0, _util.assert)((0, _util.isUndefined)((0, _classPrivateFieldLooseBase2.default)(this, _allowed)[_allowed]) || !(0, _util.isUndefined)((0, _classPrivateFieldLooseBase2.default)(this, _allowed)[_allowed][key]), `Set: Invalid key '${key}' on add`);
      super.add(key);
      return this;
    };

    this.registry = registry;
    (0, _classPrivateFieldLooseBase2.default)(this, _allowed)[_allowed] = setValues;
    (0, _classPrivateFieldLooseBase2.default)(this, _byteLength)[_byteLength] = bitLength / 8;
  }

  static with(values, bitLength) {
    return class extends CodecSet {
      constructor(registry, value) {
        super(registry, values, value, bitLength);
        Object.keys(values).forEach(_key => {
          const name = (0, _util.stringUpperFirst)((0, _util.stringCamelCase)(_key));
          const iskey = `is${name}`; // do not clobber existing properties on the object
          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access

          if ((0, _util.isUndefined)(this[iskey])) {
            Object.defineProperty(this, iskey, {
              enumerable: true,
              get: () => this.strings.includes(_key)
            });
          }
        });
      }

    };
  }
  /**
   * @description The length of the value when encoded as a Uint8Array
   */


  get encodedLength() {
    return (0, _classPrivateFieldLooseBase2.default)(this, _byteLength)[_byteLength];
  }
  /**
   * @description returns a hash of the contents
   */


  get hash() {
    return new _Raw.default(this.registry, this.registry.hash(this.toU8a()));
  }
  /**
   * @description true is the Set contains no values
   */


  get isEmpty() {
    return this.size === 0;
  }
  /**
   * @description The actual set values as a string[]
   */


  get strings() {
    return [...super.values()];
  }
  /**
   * @description The encoded value for the set members
   */


  get valueEncoded() {
    return encodeSet((0, _classPrivateFieldLooseBase2.default)(this, _allowed)[_allowed], this.strings);
  }
  /**
   * @description adds a value to the Set (extended to allow for validity checking)
   */


  /**
   * @description Compares the value of the input to see if there is a match
   */
  eq(other) {
    if (Array.isArray(other)) {
      // we don't actually care about the order, sort the values
      return (0, _utils.compareArray)(this.strings.sort(), other.sort());
    } else if (other instanceof Set) {
      return this.eq([...other.values()]);
    } else if ((0, _util.isNumber)(other) || (0, _util.isBn)(other)) {
      return this.valueEncoded.eq((0, _util.bnToBn)(other));
    }

    return false;
  }
  /**
   * @description Returns a hex string representation of the value
   */


  toHex() {
    return (0, _util.u8aToHex)(this.toU8a());
  }
  /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */


  toHuman() {
    return this.toJSON();
  }
  /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */


  toJSON() {
    return this.strings;
  }
  /**
   * @description The encoded value for the set members
   */


  toNumber() {
    return this.valueEncoded.toNumber();
  }
  /**
   * @description Returns the base runtime type name for this instance
   */


  toRawType() {
    return JSON.stringify({
      _set: (0, _classPrivateFieldLooseBase2.default)(this, _allowed)[_allowed]
    });
  }
  /**
   * @description Returns the string representation of the value
   */


  toString() {
    return `[${this.strings.join(', ')}]`;
  }
  /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars


  toU8a(isBare) {
    return (0, _util.bnToU8a)(this.valueEncoded, {
      bitLength: (0, _classPrivateFieldLooseBase2.default)(this, _byteLength)[_byteLength] * 8,
      isLe: true
    });
  }

}

exports.default = CodecSet;

/***/ }),

/***/ "../../node_modules/@polkadot/types/codec/Struct.js":
/*!***************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/codec/Struct.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classPrivateFieldLooseBase2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classPrivateFieldLooseBase */ "../../node_modules/@babel/runtime/helpers/classPrivateFieldLooseBase.js"));

var _classPrivateFieldLooseKey2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classPrivateFieldLooseKey */ "../../node_modules/@babel/runtime/helpers/classPrivateFieldLooseKey.js"));

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _Raw = _interopRequireDefault(__webpack_require__(/*! ./Raw */ "../../node_modules/@polkadot/types/codec/Raw.js"));

var _utils = __webpack_require__(/*! ./utils */ "../../node_modules/@polkadot/types/codec/utils/index.js");

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0

/** @internal */
function decodeStructFromObject(registry, Types, value, jsonMap) {
  let jsonObj;
  return Object.keys(Types).reduce((raw, key, index) => {
    // The key in the JSON can be snake_case (or other cases), but in our
    // Types, result or any other maps, it's camelCase
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
    const jsonKey = jsonMap.get(key) && !value[key] ? jsonMap.get(key) : key;

    try {
      if (Array.isArray(value)) {
        // TS2322: Type 'Codec' is not assignable to type 'T[keyof S]'.
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access
        raw[key] = value[index] instanceof Types[key] ? value[index] : new Types[key](registry, value[index]);
      } else if (value instanceof Map) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        const mapped = value.get(jsonKey); // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access

        raw[key] = mapped instanceof Types[key] ? mapped : new Types[key](registry, mapped);
      } else if ((0, _util.isObject)(value)) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        let assign = value[jsonKey];

        if ((0, _util.isUndefined)(assign)) {
          if ((0, _util.isUndefined)(jsonObj)) {
            jsonObj = Object.entries(value).reduce((all, [key, value]) => {
              // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
              all[(0, _util.stringCamelCase)(key)] = value;
              return all;
            }, {});
          } // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment


          assign = jsonObj[jsonKey];
        } // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access


        raw[key] = assign instanceof Types[key] ? assign : new Types[key](registry, assign);
      } else {
        throw new Error(`Struct: cannot decode type ${Types[key].name} with value ${JSON.stringify(value)}`);
      }
    } catch (error) {
      throw new Error(`Struct: failed on '${jsonKey}':: ${error.message}`);
    }

    return raw;
  }, {});
}
/**
 * Decode input to pass into constructor.
 *
 * @param Types - Types definition.
 * @param value - Value to decode, one of:
 * - null
 * - undefined
 * - hex
 * - Uint8Array
 * - object with `{ key1: value1, key2: value2 }`, assuming `key1` and `key2`
 * are also keys in `Types`
 * - array with `[value1, value2]` assuming the array has the same length as
 * `Object.keys(Types)`
 * @param jsonMap
 * @internal
 */


function decodeStruct(registry, Types, value, jsonMap) {
  if ((0, _util.isHex)(value)) {
    return decodeStruct(registry, Types, (0, _util.hexToU8a)(value), jsonMap);
  } else if ((0, _util.isU8a)(value)) {
    const values = (0, _utils.decodeU8a)(registry, value, Object.values(Types)); // Transform array of values to {key: value} mapping

    return Object.keys(Types).reduce((raw, key, index) => {
      // TS2322: Type 'Codec' is not assignable to type 'T[keyof S]'.
      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
      raw[key] = values[index];
      return raw;
    }, {});
  } else if (!value) {
    return {};
  } // We assume from here that value is a JS object (Array, Map, Object)


  return decodeStructFromObject(registry, Types, value, jsonMap);
}
/**
 * @name Struct
 * @description
 * A Struct defines an Object with key-value pairs - where the values are Codec values. It removes
 * a lot of repetition from the actual coding, define a structure type, pass it the key/Codec
 * values in the constructor and it manages the decoding. It is important that the constructor
 * values matches 100% to the order in th Rust code, i.e. don't go crazy and make it alphabetical,
 * it needs to decoded in the specific defined order.
 * @noInheritDoc
 */


var _jsonMap = (0, _classPrivateFieldLooseKey2.default)("jsonMap");

var _Types = (0, _classPrivateFieldLooseKey2.default)("Types");

class Struct extends Map {
  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
  constructor(registry, Types, value = {}, jsonMap = new Map()) {
    super(Object.entries(decodeStruct(registry, (0, _utils.mapToTypeMap)(registry, Types), value, jsonMap)));
    this.registry = void 0;
    Object.defineProperty(this, _jsonMap, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _Types, {
      writable: true,
      value: void 0
    });
    this.registry = registry;
    (0, _classPrivateFieldLooseBase2.default)(this, _jsonMap)[_jsonMap] = jsonMap;
    (0, _classPrivateFieldLooseBase2.default)(this, _Types)[_Types] = (0, _utils.mapToTypeMap)(registry, Types);
  }

  static with(Types, jsonMap) {
    return class extends Struct {
      constructor(registry, value) {
        super(registry, Types, value, jsonMap);
        Object.keys(Types).forEach(key => {
          // do not clobber existing properties on the object
          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
          if (!(0, _util.isUndefined)(this[key])) {
            return;
          }

          Object.defineProperty(this, key, {
            enumerable: true,
            get: () => this.get(key)
          });
        });
      }

    };
  }
  /**
   * @description The available keys for this enum
   */


  get defKeys() {
    return Object.keys((0, _classPrivateFieldLooseBase2.default)(this, _Types)[_Types]);
  }
  /**
   * @description Checks if the value is an empty value
   */


  get isEmpty() {
    const items = this.toArray();

    for (let i = 0; i < items.length; i++) {
      if (!items[i].isEmpty) {
        return false;
      }
    }

    return true;
  }
  /**
   * @description Returns the Type description to sthe structure
   */


  get Type() {
    return Object.entries((0, _classPrivateFieldLooseBase2.default)(this, _Types)[_Types]).reduce((result, [key, Type]) => {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
      result[key] = new Type(this.registry).toRawType();
      return result;
    }, {});
  }
  /**
   * @description The length of the value when encoded as a Uint8Array
   */


  get encodedLength() {
    return this.toArray().reduce((length, entry) => {
      length += entry.encodedLength;
      return length;
    }, 0);
  }
  /**
   * @description returns a hash of the contents
   */


  get hash() {
    return new _Raw.default(this.registry, this.registry.hash(this.toU8a()));
  }
  /**
   * @description Compares the value of the input to see if there is a match
   */


  eq(other) {
    return (0, _utils.compareMap)(this, other);
  }
  /**
   * @description Returns a specific names entry in the structure
   * @param name The name of the entry to retrieve
   */


  get(name) {
    return super.get(name);
  }
  /**
   * @description Returns the values of a member at a specific index (Rather use get(name) for performance)
   */


  getAtIndex(index) {
    return this.toArray()[index];
  }
  /**
   * @description Converts the Object to an standard JavaScript Array
   */


  toArray() {
    return [...this.values()];
  }
  /**
   * @description Returns a hex string representation of the value
   */


  toHex() {
    return (0, _util.u8aToHex)(this.toU8a());
  }
  /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */


  toHuman(isExtended) {
    return [...this.keys()].reduce((json, key) => {
      const value = this.get(key);
      json[key] = value && value.toHuman(isExtended);
      return json;
    }, {});
  }
  /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */


  toJSON() {
    // FIXME the return type string is only used by Extrinsic (extends Struct),
    // but its toJSON is the hex value
    return [...this.keys()].reduce((json, key) => {
      const jsonKey = (0, _classPrivateFieldLooseBase2.default)(this, _jsonMap)[_jsonMap].get(key) || key;
      const value = this.get(key);
      json[jsonKey] = value && value.toJSON();
      return json;
    }, {});
  }

  static typesToMap(registry, Types) {
    return Object.entries(Types).reduce((result, [key, Type]) => {
      result[key] = registry.getClassName(Type) || new Type(registry).toRawType();
      return result;
    }, {});
  }
  /**
   * @description Returns the base runtime type name for this instance
   */


  toRawType() {
    return JSON.stringify(Struct.typesToMap(this.registry, (0, _classPrivateFieldLooseBase2.default)(this, _Types)[_Types]));
  }
  /**
   * @description Returns the string representation of the value
   */


  toString() {
    return JSON.stringify(this.toJSON());
  }
  /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */


  toU8a(isBare) {
    // we have keyof S here, cast to string to make it compatible with isBare
    const entries = [...this.entries()];
    return (0, _util.u8aConcat)(...entries // eslint-disable-next-line @typescript-eslint/unbound-method
    .filter(([, value]) => (0, _util.isFunction)(value === null || value === void 0 ? void 0 : value.toU8a)).map(([key, value]) => value.toU8a(!isBare || (0, _util.isBoolean)(isBare) ? isBare : isBare[key])));
  }

}

exports.default = Struct;

/***/ }),

/***/ "../../node_modules/@polkadot/types/codec/Tuple.js":
/*!**************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/codec/Tuple.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _utils = __webpack_require__(/*! ./utils */ "../../node_modules/@polkadot/types/codec/utils/index.js");

var _AbstractArray = _interopRequireDefault(__webpack_require__(/*! ./AbstractArray */ "../../node_modules/@polkadot/types/codec/AbstractArray.js"));

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0

/** @internal */
function decodeTuple(registry, _Types, value) {
  if ((0, _util.isU8a)(value)) {
    return (0, _utils.decodeU8a)(registry, value, _Types);
  } else if ((0, _util.isHex)(value)) {
    return decodeTuple(registry, _Types, (0, _util.hexToU8a)(value));
  }

  const Types = Array.isArray(_Types) ? _Types : Object.values(_Types);
  return Types.map((Type, index) => {
    try {
      const entry = value === null || value === void 0 ? void 0 : value[index];

      if (entry instanceof Type) {
        return entry;
      }

      return new Type(registry, entry);
    } catch (error) {
      throw new Error(`Tuple: failed on ${index}:: ${error.message}`);
    }
  });
}
/**
 * @name Tuple
 * @description
 * A Tuple defines an anonymous fixed-length array, where each element has its
 * own type. It extends the base JS `Array` object.
 */


class Tuple extends _AbstractArray.default {
  constructor(registry, Types, value) {
    const Clazzes = Array.isArray(Types) ? Types.map(type => (0, _utils.typeToConstructor)(registry, type)) : (0, _utils.mapToTypeMap)(registry, Types);
    super(registry, ...decodeTuple(registry, Clazzes, value));
    this._Types = void 0;
    this._Types = Clazzes;
  }

  static with(Types) {
    return class extends Tuple {
      constructor(registry, value) {
        super(registry, Types, value);
      }

    };
  }
  /**
   * @description The length of the value when encoded as a Uint8Array
   */


  get encodedLength() {
    return this.reduce((length, entry) => {
      length += entry.encodedLength;
      return length;
    }, 0);
  }
  /**
   * @description The types definition of the tuple
   */


  get Types() {
    return Array.isArray(this._Types) ? this._Types.map(Type => new Type(this.registry).toRawType()) : Object.keys(this._Types);
  }
  /**
   * @description Returns the base runtime type name for this instance
   */


  toRawType() {
    const types = (Array.isArray(this._Types) ? this._Types : Object.values(this._Types)).map(Type => this.registry.getClassName(Type) || new Type(this.registry).toRawType());
    return `(${types.join(',')})`;
  }
  /**
   * @description Returns the string representation of the value
   */


  toString() {
    // Overwrite the default toString representation of Array.
    return JSON.stringify(this.toJSON());
  }
  /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */


  toU8a(isBare) {
    return (0, _util.u8aConcat)(...this.map(entry => entry.toU8a(isBare)));
  }

}

exports.default = Tuple;

/***/ }),

/***/ "../../node_modules/@polkadot/types/codec/U8aFixed.js":
/*!*****************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/codec/U8aFixed.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _Raw = _interopRequireDefault(__webpack_require__(/*! ./Raw */ "../../node_modules/@polkadot/types/codec/Raw.js"));

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0

/** @internal */
function decodeU8aFixed(value, bitLength) {
  if (Array.isArray(value) || (0, _util.isString)(value)) {
    return decodeU8aFixed((0, _util.u8aToU8a)(value), bitLength);
  } // ensure that we have an actual u8a with the full length as specified by
  // the bitLength input (padded with zeros as required)


  const byteLength = bitLength / 8;
  const sub = value.subarray(0, byteLength);

  if (sub.length === byteLength) {
    return sub;
  }

  const u8a = new Uint8Array(byteLength);
  u8a.set(sub, 0);
  return u8a;
}
/**
 * @name U8aFixed
 * @description
 * A U8a that manages a a sequence of bytes up to the specified bitLength. Not meant
 * to be used directly, rather is should be subclassed with the specific lengths.
 */


class U8aFixed extends _Raw.default {
  constructor(registry, value = new Uint8Array(), bitLength = 256) {
    super(registry, decodeU8aFixed(value, bitLength));
  }

  static with(bitLength, typeName) {
    return class extends U8aFixed {
      constructor(registry, value) {
        super(registry, value, bitLength);
      }

      toRawType() {
        return typeName || super.toRawType();
      }

    };
  }
  /**
   * @description Returns the base runtime type name for this instance
   */


  toRawType() {
    return `[u8;${this.length}]`;
  }

}

exports.default = U8aFixed;

/***/ }),

/***/ "../../node_modules/@polkadot/types/codec/UInt.js":
/*!*************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/codec/UInt.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "../../node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _AbstractInt = _interopRequireWildcard(__webpack_require__(/*! ./AbstractInt */ "../../node_modules/@polkadot/types/codec/AbstractInt.js"));

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name UInt
 * @description
 * A generic unsigned integer codec. For Substrate all numbers are Little Endian encoded,
 * this handles the encoding and decoding of those numbers. Upon construction
 * the bitLength is provided and any additional use keeps the number to this
 * length. This extends `BN`, so all methods available on a normal `BN` object
 * is available here.
 * @noInheritDoc
 */
class UInt extends _AbstractInt.default {
  constructor(registry, value = 0, bitLength = _AbstractInt.DEFAULT_UINT_BITS, isHexJson = false) {
    super(registry, false, value, bitLength, isHexJson);
  }

  static with(bitLength, typeName) {
    return class extends UInt {
      constructor(registry, value) {
        super(registry, value, bitLength);
      }

      toRawType() {
        return typeName || super.toRawType();
      }

    };
  }

}

exports.default = UInt;

/***/ }),

/***/ "../../node_modules/@polkadot/types/codec/Vec.js":
/*!************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/codec/Vec.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _Compact = _interopRequireDefault(__webpack_require__(/*! ./Compact */ "../../node_modules/@polkadot/types/codec/Compact.js"));

var _utils = __webpack_require__(/*! ./utils */ "../../node_modules/@polkadot/types/codec/utils/index.js");

var _AbstractArray = _interopRequireDefault(__webpack_require__(/*! ./AbstractArray */ "../../node_modules/@polkadot/types/codec/AbstractArray.js"));

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
const MAX_LENGTH = 64 * 1024;
/**
 * @name Vec
 * @description
 * This manages codec arrays. Internally it keeps track of the length (as decoded) and allows
 * construction with the passed `Type` in the constructor. It is an extension to Array, providing
 * specific encoding/decoding on top of the base type.
 */

class Vec extends _AbstractArray.default {
  constructor(registry, Type, value = []) {
    const Clazz = (0, _utils.typeToConstructor)(registry, Type);
    super(registry, ...Vec.decodeVec(registry, Clazz, value));
    this._Type = void 0;
    this._Type = Clazz;
  }
  /** @internal */


  static decodeVec(registry, Type, value) {
    if (Array.isArray(value)) {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-return
      return value.map((entry, index) => {
        try {
          return entry instanceof Type ? entry : new Type(registry, entry);
        } catch (error) {
          console.error(`Unable to decode Vec on index ${index}`, error.message);
          throw error;
        }
      });
    }

    const u8a = (0, _util.u8aToU8a)(value);

    const [offset, length] = _Compact.default.decodeU8a(u8a);

    (0, _util.assert)(length.lten(MAX_LENGTH), `Vec length ${length.toString()} exceeds ${MAX_LENGTH}`);
    return (0, _utils.decodeU8a)(registry, u8a.subarray(offset), new Array(length.toNumber()).fill(Type));
  }

  static with(Type) {
    return class extends Vec {
      constructor(registry, value) {
        super(registry, Type, value);
      }

    };
  }
  /**
   * @description The type for the items
   */


  get Type() {
    return this._Type.name;
  }
  /**
   * @description Finds the index of the value in the array
   */


  indexOf(_other) {
    // convert type first, this removes overhead from the eq
    const other = _other instanceof this._Type ? _other : new this._Type(this.registry, _other);

    for (let i = 0; i < this.length; i++) {
      if (other.eq(this[i])) {
        return i;
      }
    }

    return -1;
  }
  /**
   * @description Returns the base runtime type name for this instance
   */


  toRawType() {
    return `Vec<${this.registry.getClassName(this._Type) || new this._Type(this.registry).toRawType()}>`;
  }

}

exports.default = Vec;

/***/ }),

/***/ "../../node_modules/@polkadot/types/codec/VecFixed.js":
/*!*****************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/codec/VecFixed.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _AbstractArray = _interopRequireDefault(__webpack_require__(/*! ./AbstractArray */ "../../node_modules/@polkadot/types/codec/AbstractArray.js"));

var _utils = __webpack_require__(/*! ./utils */ "../../node_modules/@polkadot/types/codec/utils/index.js");

var _Vec = _interopRequireDefault(__webpack_require__(/*! ./Vec */ "../../node_modules/@polkadot/types/codec/Vec.js"));

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name VecFixed
 * @description
 * This manages codec arrays of a fixed length
 */
class VecFixed extends _AbstractArray.default {
  constructor(registry, Type, length, value = []) {
    const Clazz = (0, _utils.typeToConstructor)(registry, Type);
    super(registry, ...VecFixed.decodeVecFixed(registry, Clazz, length, value));
    this._Type = void 0;
    this._Type = Clazz;
  }
  /** @internal */


  static decodeVecFixed(registry, Type, allocLength, value) {
    const values = _Vec.default.decodeVec(registry, Type, (0, _util.isU8a)(value) ? (0, _util.u8aConcat)((0, _util.compactToU8a)(allocLength), value) : value);

    while (values.length < allocLength) {
      values.push(new Type(registry));
    }

    (0, _util.assert)(values.length === allocLength, `Expected a length of exactly ${allocLength} entries`);
    return values;
  }

  static with(Type, length) {
    return class extends VecFixed {
      constructor(registry, value) {
        super(registry, Type, length, value);
      }

    };
  }
  /**
   * @description The type for the items
   */


  get Type() {
    return new this._Type(this.registry).toRawType();
  }
  /**
   * @description The length of the value when encoded as a Uint8Array
   */


  get encodedLength() {
    return this.toU8a().length;
  }

  toU8a() {
    // we override, we don't add the length prefix for ourselves, and at the same time we
    // ignore isBare on entries, since they should be properly encoded at all times
    const encoded = this.map(entry => entry.toU8a());
    return encoded.length ? (0, _util.u8aConcat)(...encoded) : new Uint8Array([]);
  }
  /**
   * @description Returns the base runtime type name for this instance
   */


  toRawType() {
    return `[${this.Type};${this.length}]`;
  }

}

exports.default = VecFixed;

/***/ }),

/***/ "../../node_modules/@polkadot/types/codec/index.js":
/*!**************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/codec/index.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  BTreeMap: true,
  BTreeSet: true,
  Compact: true,
  Enum: true,
  HashMap: true,
  Linkage: true,
  Option: true,
  Result: true,
  Set: true,
  Struct: true,
  Tuple: true,
  Vec: true,
  Int: true,
  Raw: true,
  UInt: true,
  U8aFixed: true
};
Object.defineProperty(exports, "BTreeMap", {
  enumerable: true,
  get: function () {
    return _BTreeMap.default;
  }
});
Object.defineProperty(exports, "BTreeSet", {
  enumerable: true,
  get: function () {
    return _BTreeSet.default;
  }
});
Object.defineProperty(exports, "Compact", {
  enumerable: true,
  get: function () {
    return _Compact.default;
  }
});
Object.defineProperty(exports, "Enum", {
  enumerable: true,
  get: function () {
    return _Enum.default;
  }
});
Object.defineProperty(exports, "HashMap", {
  enumerable: true,
  get: function () {
    return _HashMap.default;
  }
});
Object.defineProperty(exports, "Linkage", {
  enumerable: true,
  get: function () {
    return _Linkage.default;
  }
});
Object.defineProperty(exports, "Option", {
  enumerable: true,
  get: function () {
    return _Option.default;
  }
});
Object.defineProperty(exports, "Result", {
  enumerable: true,
  get: function () {
    return _Result.default;
  }
});
Object.defineProperty(exports, "Set", {
  enumerable: true,
  get: function () {
    return _Set.default;
  }
});
Object.defineProperty(exports, "Struct", {
  enumerable: true,
  get: function () {
    return _Struct.default;
  }
});
Object.defineProperty(exports, "Tuple", {
  enumerable: true,
  get: function () {
    return _Tuple.default;
  }
});
Object.defineProperty(exports, "Vec", {
  enumerable: true,
  get: function () {
    return _Vec.default;
  }
});
Object.defineProperty(exports, "Int", {
  enumerable: true,
  get: function () {
    return _Int.default;
  }
});
Object.defineProperty(exports, "Raw", {
  enumerable: true,
  get: function () {
    return _Raw.default;
  }
});
Object.defineProperty(exports, "UInt", {
  enumerable: true,
  get: function () {
    return _UInt.default;
  }
});
Object.defineProperty(exports, "U8aFixed", {
  enumerable: true,
  get: function () {
    return _U8aFixed.default;
  }
});

var _BTreeMap = _interopRequireDefault(__webpack_require__(/*! ./BTreeMap */ "../../node_modules/@polkadot/types/codec/BTreeMap.js"));

var _BTreeSet = _interopRequireDefault(__webpack_require__(/*! ./BTreeSet */ "../../node_modules/@polkadot/types/codec/BTreeSet.js"));

var _Compact = _interopRequireDefault(__webpack_require__(/*! ./Compact */ "../../node_modules/@polkadot/types/codec/Compact.js"));

var _Enum = _interopRequireDefault(__webpack_require__(/*! ./Enum */ "../../node_modules/@polkadot/types/codec/Enum.js"));

var _HashMap = _interopRequireDefault(__webpack_require__(/*! ./HashMap */ "../../node_modules/@polkadot/types/codec/HashMap.js"));

var _Linkage = _interopRequireDefault(__webpack_require__(/*! ./Linkage */ "../../node_modules/@polkadot/types/codec/Linkage.js"));

var _Option = _interopRequireDefault(__webpack_require__(/*! ./Option */ "../../node_modules/@polkadot/types/codec/Option.js"));

var _Result = _interopRequireDefault(__webpack_require__(/*! ./Result */ "../../node_modules/@polkadot/types/codec/Result.js"));

var _Set = _interopRequireDefault(__webpack_require__(/*! ./Set */ "../../node_modules/@polkadot/types/codec/Set.js"));

var _Struct = _interopRequireDefault(__webpack_require__(/*! ./Struct */ "../../node_modules/@polkadot/types/codec/Struct.js"));

var _Tuple = _interopRequireDefault(__webpack_require__(/*! ./Tuple */ "../../node_modules/@polkadot/types/codec/Tuple.js"));

var _Vec = _interopRequireDefault(__webpack_require__(/*! ./Vec */ "../../node_modules/@polkadot/types/codec/Vec.js"));

var _Int = _interopRequireDefault(__webpack_require__(/*! ./Int */ "../../node_modules/@polkadot/types/codec/Int.js"));

var _Raw = _interopRequireDefault(__webpack_require__(/*! ./Raw */ "../../node_modules/@polkadot/types/codec/Raw.js"));

var _UInt = _interopRequireDefault(__webpack_require__(/*! ./UInt */ "../../node_modules/@polkadot/types/codec/UInt.js"));

var _U8aFixed = _interopRequireDefault(__webpack_require__(/*! ./U8aFixed */ "../../node_modules/@polkadot/types/codec/U8aFixed.js"));

var _encodeTypes = __webpack_require__(/*! ./utils/encodeTypes */ "../../node_modules/@polkadot/types/codec/utils/encodeTypes.js");

Object.keys(_encodeTypes).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _encodeTypes[key];
    }
  });
});

/***/ }),

/***/ "../../node_modules/@polkadot/types/codec/utils/compareArray.js":
/*!***************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/codec/utils/compareArray.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = compareArray;

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _util2 = __webpack_require__(/*! ./util */ "../../node_modules/@polkadot/types/codec/utils/util.js");

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// NOTE These are used internally and when comparing objects, expects that
// when the second is an Codec[] that the first has to be as well
function compareArray(a, b) {
  if (Array.isArray(b)) {
    return a.length === b.length && (0, _util.isUndefined)(a.find((value, index) => (0, _util2.hasEq)(value) ? !value.eq(b[index]) : value !== b[index]));
  }

  return false;
}

/***/ }),

/***/ "../../node_modules/@polkadot/types/codec/utils/compareMap.js":
/*!*************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/codec/utils/compareMap.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = compareMap;

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _util2 = __webpack_require__(/*! ./util */ "../../node_modules/@polkadot/types/codec/utils/util.js");

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
function hasMismatch(a, b) {
  return (0, _util.isUndefined)(a) || ((0, _util2.hasEq)(a) ? !a.eq(b) : a !== b);
}

function notEntry(value) {
  return !Array.isArray(value) || value.length !== 2;
}

function compareMapArray(a, b) {
  // equal number of entries and each entry in the array should match
  return a.size === b.length && !b.some(entry => notEntry(entry) || hasMismatch(a.get(entry[0]), entry[1]));
} // NOTE These are used internally and when comparing objects, expects that
// when the second is an Map<string, Codec> that the first has to be as well


function compareMap(a, b) {
  if (Array.isArray(b)) {
    return compareMapArray(a, b);
  } else if (b instanceof Map) {
    return compareMapArray(a, [...b.entries()]);
  } else if ((0, _util.isObject)(b)) {
    return compareMapArray(a, Object.entries(b));
  }

  return false;
}

/***/ }),

/***/ "../../node_modules/@polkadot/types/codec/utils/compareSet.js":
/*!*************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/codec/utils/compareSet.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = compareSet;

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
function compareSetArray(a, b) {
  // equal number of entries and each entry in the array should match
  return a.size === b.length && !b.some(entry => !a.has(entry));
} // NOTE These are used internally and when comparing objects, expects that
// when the second is an Set<string, Codec> that the first has to be as well


function compareSet(a, b) {
  if (Array.isArray(b)) {
    return compareSetArray(a, b);
  } else if (b instanceof Set) {
    return compareSetArray(a, [...b.values()]);
  } else if ((0, _util.isObject)(b)) {
    return compareSetArray(a, Object.values(b));
  }

  return false;
}

/***/ }),

/***/ "../../node_modules/@polkadot/types/codec/utils/decodeU8a.js":
/*!************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/codec/utils/decodeU8a.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = decodeU8a;

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * Given an u8a, and an array of Type constructors, decode the u8a against the
 * types, and return an array of decoded values.
 *
 * @param u8a - The u8a to decode.
 * @param types - The array of Constructor to decode the U8a against.
 */
function decodeU8a(registry, u8a, _types) {
  const types = Array.isArray(_types) ? _types : Object.values(_types);

  if (!types.length) {
    return [];
  }

  const Type = types[0];
  const value = new Type(registry, u8a);
  return [value].concat(decodeU8a(registry, u8a.subarray(value.encodedLength), types.slice(1)));
}

/***/ }),

/***/ "../../node_modules/@polkadot/types/codec/utils/encodeTypes.js":
/*!**************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/codec/utils/encodeTypes.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.paramsNotation = paramsNotation;
exports.encodeTypeDef = encodeTypeDef;
exports.withTypeString = withTypeString;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js"));

var _types = __webpack_require__(/*! ../../create/types */ "../../node_modules/@polkadot/types/create/types.js");

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const stringIdentity = value => value.toString();

function paramsNotation(outer, inner, transform = stringIdentity) {
  return `${outer}${inner ? `<${(Array.isArray(inner) ? inner : [inner]).map(transform).join(', ')}>` : ''}`;
} // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment


function encodeWithParams(typeDef, outer = typeDef.displayName || typeDef.type) {
  const {
    info,
    params,
    sub
  } = typeDef;

  switch (info) {
    case _types.TypeDefInfo.BTreeMap:
    case _types.TypeDefInfo.BTreeSet:
    case _types.TypeDefInfo.Compact:
    case _types.TypeDefInfo.HashMap:
    case _types.TypeDefInfo.Linkage:
    case _types.TypeDefInfo.Option:
    case _types.TypeDefInfo.Result:
    case _types.TypeDefInfo.Vec:
      // eslint-disable-next-line @typescript-eslint/no-use-before-define
      return paramsNotation(outer, params || sub, param => encodeTypeDef(param));

    default:
      return outer;
  }
}

function encodeDoNotConstruct({
  displayName
}) {
  return `DoNotEncode<${displayName || 'Unknown'}>`;
}

function encodeSubTypes(sub, asEnum) {
  const inner = sub.reduce((result, type) => _objectSpread(_objectSpread({}, result), {}, {
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    [type.name]: encodeTypeDef(type)
  }), {});
  return JSON.stringify(asEnum ? {
    _enum: inner
  } : inner);
}

function encodeEnum(typeDef) {
  (0, _util.assert)(typeDef.sub && Array.isArray(typeDef.sub), 'Unable to encode Enum type');
  const sub = typeDef.sub; // c-like enums have all Null entries
  // TODO We need to take the disciminant into account and auto-add empty entries

  return sub.every(({
    type
  }) => type === 'Null') ? `{ _enum: [${sub.map(({
    name
  }, index) => `"${name || `Empty${index}`}"`).join(', ')}] }` : encodeSubTypes(sub, true);
}

function encodeStruct(typeDef) {
  (0, _util.assert)(typeDef.sub && Array.isArray(typeDef.sub), 'Unable to encode Struct type');
  return encodeSubTypes(typeDef.sub);
}

function encodeTuple(typeDef) {
  (0, _util.assert)(typeDef.sub && Array.isArray(typeDef.sub), 'Unable to encode Tuple type'); // eslint-disable-next-line @typescript-eslint/no-use-before-define

  return `(${typeDef.sub.map(type => encodeTypeDef(type)).join(', ')})`;
}

function encodeUInt({
  length
}, type) {
  (0, _util.assert)((0, _util.isNumber)(length), 'Unable to encode VecFixed type');
  return `${type}<${length}>`;
}

function encodeVecFixed({
  length,
  sub
}) {
  (0, _util.assert)((0, _util.isNumber)(length) && !(0, _util.isUndefined)(sub) && !Array.isArray(sub), 'Unable to encode VecFixed type');
  return `[${sub.type};${length}]`;
} // We setup a record here to ensure we have comprehensive coverage (any item not covered will result
// in a compile-time error with the missing index)


const encoders = {
  [_types.TypeDefInfo.BTreeMap]: typeDef => encodeWithParams(typeDef, 'BTreeMap'),
  [_types.TypeDefInfo.BTreeSet]: typeDef => encodeWithParams(typeDef, 'BTreeSet'),
  [_types.TypeDefInfo.Compact]: typeDef => encodeWithParams(typeDef, 'Compact'),
  [_types.TypeDefInfo.DoNotConstruct]: typeDef => encodeDoNotConstruct(typeDef),
  [_types.TypeDefInfo.Enum]: typeDef => encodeEnum(typeDef),
  [_types.TypeDefInfo.HashMap]: typeDef => encodeWithParams(typeDef, 'HashMap'),
  [_types.TypeDefInfo.Int]: typeDef => encodeUInt(typeDef, 'Int'),
  [_types.TypeDefInfo.Linkage]: typeDef => encodeWithParams(typeDef, 'Linkage'),
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  [_types.TypeDefInfo.Null]: typeDef => 'Null',
  [_types.TypeDefInfo.Option]: typeDef => encodeWithParams(typeDef, 'Option'),
  [_types.TypeDefInfo.Plain]: typeDef => typeDef.displayName || typeDef.type,
  [_types.TypeDefInfo.Result]: typeDef => encodeWithParams(typeDef, 'Result'),
  [_types.TypeDefInfo.Set]: typeDef => typeDef.type,
  [_types.TypeDefInfo.Struct]: typeDef => encodeStruct(typeDef),
  [_types.TypeDefInfo.Tuple]: typeDef => encodeTuple(typeDef),
  [_types.TypeDefInfo.UInt]: typeDef => encodeUInt(typeDef, 'UInt'),
  [_types.TypeDefInfo.Vec]: typeDef => encodeWithParams(typeDef, 'Vec'),
  [_types.TypeDefInfo.VecFixed]: typeDef => encodeVecFixed(typeDef)
};

function encodeType(typeDef) {
  const encoder = encoders[typeDef.info];
  (0, _util.assert)(encoder, `Cannot encode type: ${JSON.stringify(typeDef)}`);
  return encoder(typeDef);
}

function encodeTypeDef(typeDef) {
  (0, _util.assert)(!(0, _util.isUndefined)(typeDef.info), `Invalid type definition with no instance info, ${JSON.stringify(typeDef)}`);
  return typeDef.displayName || [_types.TypeDefInfo.Enum, _types.TypeDefInfo.Struct].includes(typeDef.info) ? encodeWithParams(typeDef) : encodeType(typeDef);
}

function withTypeString(typeDef) {
  return _objectSpread(_objectSpread({}, typeDef), {}, {
    type: encodeType(typeDef)
  });
}

/***/ }),

/***/ "../../node_modules/@polkadot/types/codec/utils/index.js":
/*!********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/codec/utils/index.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  compareArray: true,
  compareMap: true,
  compareSet: true,
  decodeU8a: true,
  mapToTypeMap: true,
  typeToConstructor: true
};
Object.defineProperty(exports, "compareArray", {
  enumerable: true,
  get: function () {
    return _compareArray.default;
  }
});
Object.defineProperty(exports, "compareMap", {
  enumerable: true,
  get: function () {
    return _compareMap.default;
  }
});
Object.defineProperty(exports, "compareSet", {
  enumerable: true,
  get: function () {
    return _compareSet.default;
  }
});
Object.defineProperty(exports, "decodeU8a", {
  enumerable: true,
  get: function () {
    return _decodeU8a.default;
  }
});
Object.defineProperty(exports, "mapToTypeMap", {
  enumerable: true,
  get: function () {
    return _mapToTypeMap.default;
  }
});
Object.defineProperty(exports, "typeToConstructor", {
  enumerable: true,
  get: function () {
    return _typeToConstructor.default;
  }
});

var _compareArray = _interopRequireDefault(__webpack_require__(/*! ./compareArray */ "../../node_modules/@polkadot/types/codec/utils/compareArray.js"));

var _compareMap = _interopRequireDefault(__webpack_require__(/*! ./compareMap */ "../../node_modules/@polkadot/types/codec/utils/compareMap.js"));

var _compareSet = _interopRequireDefault(__webpack_require__(/*! ./compareSet */ "../../node_modules/@polkadot/types/codec/utils/compareSet.js"));

var _decodeU8a = _interopRequireDefault(__webpack_require__(/*! ./decodeU8a */ "../../node_modules/@polkadot/types/codec/utils/decodeU8a.js"));

var _mapToTypeMap = _interopRequireDefault(__webpack_require__(/*! ./mapToTypeMap */ "../../node_modules/@polkadot/types/codec/utils/mapToTypeMap.js"));

var _typeToConstructor = _interopRequireDefault(__webpack_require__(/*! ./typeToConstructor */ "../../node_modules/@polkadot/types/codec/utils/typeToConstructor.js"));

var _encodeTypes = __webpack_require__(/*! ./encodeTypes */ "../../node_modules/@polkadot/types/codec/utils/encodeTypes.js");

Object.keys(_encodeTypes).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _encodeTypes[key];
    }
  });
});

/***/ }),

/***/ "../../node_modules/@polkadot/types/codec/utils/mapToTypeMap.js":
/*!***************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/codec/utils/mapToTypeMap.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = mapToTypeMap;

var _typeToConstructor = _interopRequireDefault(__webpack_require__(/*! ./typeToConstructor */ "../../node_modules/@polkadot/types/codec/utils/typeToConstructor.js"));

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @description takes an input map of the form `{ [string]: string | Constructor }` and returns a map of `{ [string]: Constructor }`
 */
function mapToTypeMap(registry, input) {
  return Object.entries(input).reduce((output, [key, type]) => {
    output[key] = (0, _typeToConstructor.default)(registry, type);
    return output;
  }, {});
}

/***/ }),

/***/ "../../node_modules/@polkadot/types/codec/utils/typeToConstructor.js":
/*!********************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/codec/utils/typeToConstructor.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = typeToConstructor;

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
function typeToConstructor(registry, type) {
  return (0, _util.isString)(type) ? registry.createClass(type) : type;
}

/***/ }),

/***/ "../../node_modules/@polkadot/types/codec/utils/util.js":
/*!*******************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/codec/utils/util.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hasEq = hasEq;

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
function hasEq(o) {
  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
  return (0, _util.isFunction)(o.eq);
}

/***/ }),

/***/ "../../node_modules/@polkadot/types/create/createClass.js":
/*!*********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/create/createClass.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createClass = createClass;
exports.ClassOfUnsafe = ClassOfUnsafe;
exports.ClassOf = ClassOf;
exports.getTypeClass = getTypeClass;

var _types = __webpack_require__(/*! ./types */ "../../node_modules/@polkadot/types/create/types.js");

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _BTreeMap = _interopRequireDefault(__webpack_require__(/*! ../codec/BTreeMap */ "../../node_modules/@polkadot/types/codec/BTreeMap.js"));

var _BTreeSet = _interopRequireDefault(__webpack_require__(/*! ../codec/BTreeSet */ "../../node_modules/@polkadot/types/codec/BTreeSet.js"));

var _Compact = _interopRequireDefault(__webpack_require__(/*! ../codec/Compact */ "../../node_modules/@polkadot/types/codec/Compact.js"));

var _Enum = _interopRequireDefault(__webpack_require__(/*! ../codec/Enum */ "../../node_modules/@polkadot/types/codec/Enum.js"));

var _HashMap = _interopRequireDefault(__webpack_require__(/*! ../codec/HashMap */ "../../node_modules/@polkadot/types/codec/HashMap.js"));

var _Int = _interopRequireDefault(__webpack_require__(/*! ../codec/Int */ "../../node_modules/@polkadot/types/codec/Int.js"));

var _Option = _interopRequireDefault(__webpack_require__(/*! ../codec/Option */ "../../node_modules/@polkadot/types/codec/Option.js"));

var _Result = _interopRequireDefault(__webpack_require__(/*! ../codec/Result */ "../../node_modules/@polkadot/types/codec/Result.js"));

var _Set = _interopRequireDefault(__webpack_require__(/*! ../codec/Set */ "../../node_modules/@polkadot/types/codec/Set.js"));

var _Struct = _interopRequireDefault(__webpack_require__(/*! ../codec/Struct */ "../../node_modules/@polkadot/types/codec/Struct.js"));

var _Tuple = _interopRequireDefault(__webpack_require__(/*! ../codec/Tuple */ "../../node_modules/@polkadot/types/codec/Tuple.js"));

var _U8aFixed = _interopRequireDefault(__webpack_require__(/*! ../codec/U8aFixed */ "../../node_modules/@polkadot/types/codec/U8aFixed.js"));

var _UInt = _interopRequireDefault(__webpack_require__(/*! ../codec/UInt */ "../../node_modules/@polkadot/types/codec/UInt.js"));

var _Vec = _interopRequireDefault(__webpack_require__(/*! ../codec/Vec */ "../../node_modules/@polkadot/types/codec/Vec.js"));

var _VecFixed = _interopRequireDefault(__webpack_require__(/*! ../codec/VecFixed */ "../../node_modules/@polkadot/types/codec/VecFixed.js"));

var _DoNotConstruct = _interopRequireDefault(__webpack_require__(/*! ../primitive/DoNotConstruct */ "../../node_modules/@polkadot/types/primitive/DoNotConstruct.js"));

var _getTypeDef = __webpack_require__(/*! ./getTypeDef */ "../../node_modules/@polkadot/types/create/getTypeDef.js");

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
function createClass(registry, type) {
  // eslint-disable-next-line @typescript-eslint/no-use-before-define
  return getTypeClass(registry, (0, _getTypeDef.getTypeDef)(type));
} // An unsafe version of the `createType` below. It's unsafe because the `type`
// argument here can be any string, which, if it cannot be parsed, it will yield
// a runtime error.


function ClassOfUnsafe(registry, name) {
  return createClass(registry, name);
} // alias for createClass


function ClassOf(registry, name) {
  // TS2589: Type instantiation is excessively deep and possibly infinite.
  // The above happens with as Constructor<InterfaceTypes[K]>;
  // eslint-disable-next-line @typescript-eslint/no-unsafe-return
  return ClassOfUnsafe(registry, name);
}

function getSubDefArray(value) {
  (0, _util.assert)(value.sub && Array.isArray(value.sub), `Expected subtype as TypeDef[] in ${JSON.stringify(value)}`);
  return value.sub;
}

function getSubDef(value) {
  (0, _util.assert)(value.sub && !Array.isArray(value.sub), `Expected subtype as TypeDef in ${JSON.stringify(value)}`);
  return value.sub;
}

function getSubType(value) {
  return getSubDef(value).type;
} // create a maps of type string constructors from the input


function getTypeClassMap(value) {
  const result = {};
  return getSubDefArray(value).reduce((result, sub) => {
    result[sub.name] = sub.type;
    return result;
  }, result);
} // create an array of type string constructors from the input


function getTypeClassArray(value) {
  return getSubDefArray(value).map(({
    type
  }) => type);
}

function createInt({
  displayName,
  length
}, Clazz) {
  (0, _util.assert)((0, _util.isNumber)(length), `Expected bitLength information for ${displayName || Clazz.constructor.name}<bitLength>`);
  return Clazz.with(length, displayName);
}

function createHashMap(value, Clazz) {
  const [keyType, valueType] = getTypeClassArray(value);
  return Clazz.with(keyType, valueType);
}

const infoMapping = {
  [_types.TypeDefInfo.BTreeMap]: (registry, value) => createHashMap(value, _BTreeMap.default),
  [_types.TypeDefInfo.BTreeSet]: (registry, value) => _BTreeSet.default.with(getSubType(value)),
  [_types.TypeDefInfo.Compact]: (registry, value) => _Compact.default.with(getSubType(value)),
  [_types.TypeDefInfo.DoNotConstruct]: (registry, value) => _DoNotConstruct.default.with(value.displayName),
  [_types.TypeDefInfo.Enum]: (registry, value) => _Enum.default.with(getTypeClassMap(value)),
  [_types.TypeDefInfo.HashMap]: (registry, value) => createHashMap(value, _HashMap.default),
  [_types.TypeDefInfo.Int]: (registry, value) => createInt(value, _Int.default),
  // We have circular deps between Linkage & Struct
  [_types.TypeDefInfo.Linkage]: (registry, value) => {
    const type = `Option<${getSubType(value)}>`; // eslint-disable-next-line sort-keys

    const Clazz = _Struct.default.with({
      previous: type,
      next: type
    }); // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access


    Clazz.prototype.toRawType = function () {
      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-call
      return `Linkage<${this.next.toRawType(true)}>`;
    };

    return Clazz;
  },
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  [_types.TypeDefInfo.Null]: (registry, _) => createClass(registry, 'Null'),
  [_types.TypeDefInfo.Option]: (registry, value) => _Option.default.with(getSubType(value)),
  [_types.TypeDefInfo.Plain]: (registry, value) => registry.getOrUnknown(value.type),
  [_types.TypeDefInfo.Result]: (registry, value) => {
    const [Ok, Error] = getTypeClassArray(value); // eslint-disable-next-line @typescript-eslint/no-use-before-define

    return _Result.default.with({
      Error,
      Ok
    });
  },
  [_types.TypeDefInfo.Set]: (registry, value) => {
    const result = {};
    return _Set.default.with(getSubDefArray(value).reduce((result, {
      index,
      name
    }) => {
      result[name] = index;
      return result;
    }, result), value.length);
  },
  [_types.TypeDefInfo.Struct]: (registry, value) => _Struct.default.with(getTypeClassMap(value), value.alias),
  [_types.TypeDefInfo.Tuple]: (registry, value) => _Tuple.default.with(getTypeClassArray(value)),
  [_types.TypeDefInfo.UInt]: (registry, value) => createInt(value, _UInt.default),
  [_types.TypeDefInfo.Vec]: (registry, value) => {
    const subType = getSubType(value);
    return subType === 'u8' ? createClass(registry, 'Bytes') : _Vec.default.with(subType);
  },
  [_types.TypeDefInfo.VecFixed]: (registry, {
    displayName,
    length,
    sub
  }) => {
    (0, _util.assert)((0, _util.isNumber)(length) && !(0, _util.isUndefined)(sub), 'Expected length & type information for fixed vector');
    return sub.type === 'u8' ? _U8aFixed.default.with(length * 8, displayName) : _VecFixed.default.with(sub.type, length);
  }
}; // Returns the type Class for construction

function getTypeClass(registry, value) {
  const Type = registry.get(value.type);

  if (Type) {
    return Type;
  }

  const getFn = infoMapping[value.info];

  if (!getFn) {
    throw new Error(`Unable to construct class from ${JSON.stringify(value)}`);
  }

  return getFn(registry, value);
}

/***/ }),

/***/ "../../node_modules/@polkadot/types/create/createType.js":
/*!********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/create/createType.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createTypeUnsafe = createTypeUnsafe;
exports.createType = createType;

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _createClass = __webpack_require__(/*! ./createClass */ "../../node_modules/@polkadot/types/create/createClass.js");

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
function u8aHasValue(value) {
  return value.some(v => !!v);
} // With isPedantic, actually check that the encoding matches that supplied. This
// is much slower, but verifies that we have the correct types defined


function checkInstance(value, created) {
  // the underlying type created.toRawType()
  const rawType = created.toRawType(); // ignore bytes completely - this is probably a FIXME, since these are somewhat
  // breaking for at least online queries - not quite sure wtf is going wrong here

  if (rawType === 'Bytes') {
    return;
  } // the hex values for what we have


  const inHex = (0, _util.u8aToHex)(value);
  const crHex = created.toHex(); // Check equality, based on some different approaches (as decoded)

  const isEqual = inHex === crHex || // raw hex values, quick path
  inHex === created.toHex(true) || // wrapped options
  (0, _util.u8aToHex)(value.reverse()) === crHex; // reverse (for numbers, which are BE)
  // if the hex doesn't match and the value for both is non-empty, complain... bitterly

  if (!isEqual && (u8aHasValue(value) || u8aHasValue(created.toU8a(true)))) {
    console.warn(`${rawType}:: Input doesn't match output, received ${(0, _util.u8aToHex)(value)}, created ${crHex}`);
  }
} // Initializes a type with a value. This also checks for fallbacks and in the cases
// where isPedantic is specified (storage decoding), also check the format/structure


function initType(registry, Type, params = [], isPedantic) {
  const created = new Type(registry, ...params); // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment

  const [value] = params;

  if (isPedantic && (0, _util.isU8a)(value)) {
    checkInstance(value, created);
  }

  return created;
} // An unsafe version of the `createType` below. It's unsafe because the `type`
// argument here can be any string, which, when it cannot parse, will yield a
// runtime error.
// eslint-disable-next-line @typescript-eslint/no-unused-vars


function createTypeUnsafe(registry, type, params = [], isPedantic) {
  try {
    // Circle back to isPedantic when it handles all cases 100% - as of now,
    // it provides false warning which is more hinderance than help
    return initType(registry, (0, _createClass.createClass)(registry, type), params); // , isPedantic);
  } catch (error) {
    throw new Error(`createType(${type}):: ${error.message}`);
  }
}
/**
 * Create an instance of a `type` with a given `params`.
 * @param type - A recognizable string representing the type to create an
 * instance from
 * @param params - The value to instantiate the type with
 */


function createType(registry, type, ...params) {
  return createTypeUnsafe(registry, type, params);
}

/***/ }),

/***/ "../../node_modules/@polkadot/types/create/getTypeDef.js":
/*!********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/create/getTypeDef.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTypeDef = getTypeDef;

var _types = __webpack_require__(/*! ./types */ "../../node_modules/@polkadot/types/create/types.js");

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _sanitize = _interopRequireDefault(__webpack_require__(/*! ./sanitize */ "../../node_modules/@polkadot/types/create/sanitize.js"));

var _typeSplit = __webpack_require__(/*! ./typeSplit */ "../../node_modules/@polkadot/types/create/typeSplit.js");

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
const MAX_NESTED = 64; // decode an enum of either of the following forms
//  { _enum: ['A', 'B', 'C'] }
//  { _enum: { A: AccountId, B: Balance, C: u32 } }

function _decodeEnum(value, details, count) {
  value.info = _types.TypeDefInfo.Enum; // not as pretty, but remain compatible with oo7 for both struct and Array types

  value.sub = Array.isArray(details) ? details.map(name => ({
    info: _types.TypeDefInfo.Plain,
    name,
    type: 'Null'
  })) : Object.entries(details).map(([name, type]) => // eslint-disable-next-line @typescript-eslint/no-use-before-define
  getTypeDef(type || 'Null', {
    name
  }, count));
  return value;
} // decode a set of the form
//   { _set: { A: 0b0001, B: 0b0010, C: 0b0100 } }


function _decodeSet(value, details) {
  value.info = _types.TypeDefInfo.Set;
  value.length = details._bitLength;
  value.sub = Object.entries(details).filter(([name]) => !name.startsWith('_')).map(([name, index]) => ({
    index,
    info: _types.TypeDefInfo.Plain,
    name,
    type: name
  }));
  return value;
} // decode a struct, set or enum
// eslint-disable-next-line @typescript-eslint/no-unused-vars


function _decodeStruct(value, type, _, count) {
  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
  const parsed = JSON.parse(type);
  const keys = Object.keys(parsed);

  if (keys.length === 1 && keys[0] === '_enum') {
    return _decodeEnum(value, parsed[keys[0]], count);
  } else if (keys.length === 1 && keys[0] === '_set') {
    return _decodeSet(value, parsed[keys[0]]);
  }

  value.alias = parsed._alias ? new Map(Object.entries(parsed._alias)) : undefined;
  value.sub = keys.filter(name => !['_alias'].includes(name)).map(name => // eslint-disable-next-line @typescript-eslint/no-use-before-define
  getTypeDef(parsed[name], {
    name
  }, count));
  return value;
} // decode a fixed vector, e.g. [u8;32]
// eslint-disable-next-line @typescript-eslint/no-unused-vars


function _decodeFixedVec(value, type, _, count) {
  const [vecType, strLength, displayName] = type.substr(1, type.length - 2).split(';');
  const length = parseInt(strLength.trim(), 10); // as a first round, only u8 via u8aFixed, we can add more support

  (0, _util.assert)(length <= 256, `${type}: Only support for [Type; <length>], where length <= 256`);
  value.displayName = displayName;
  value.length = length; // eslint-disable-next-line @typescript-eslint/no-use-before-define

  value.sub = getTypeDef(vecType, {}, count);
  return value;
} // decode a tuple


function _decodeTuple(value, _, subType, count) {
  value.sub = subType.length === 0 ? [] : (0, _typeSplit.typeSplit)(subType).map(inner => // eslint-disable-next-line @typescript-eslint/no-use-before-define
  getTypeDef(inner, {}, count));
  return value;
} // decode a Int/UInt<bitLength[, name]>
// eslint-disable-next-line @typescript-eslint/no-unused-vars


function _decodeAnyInt(value, type, _, clazz) {
  const [strLength, displayName] = type.substr(clazz.length + 1, type.length - clazz.length - 1 - 1).split(',');
  const length = parseInt(strLength.trim(), 10); // as a first round, only u8 via u8aFixed, we can add more support

  (0, _util.assert)(length <= 8192 && length % 8 === 0, `${type}: Only support for ${clazz}<bitLength>, where length <= 8192 and a power of 8, found ${length}`);
  value.displayName = displayName;
  value.length = length;
  return value;
}

function _decodeInt(value, type, subType) {
  return _decodeAnyInt(value, type, subType, 'Int');
}

function _decodeUInt(value, type, subType) {
  return _decodeAnyInt(value, type, subType, 'UInt');
} // eslint-disable-next-line @typescript-eslint/no-unused-vars


function _decodeDoNotConstruct(value, type, _) {
  const NAME_LENGTH = 'DoNotConstruct'.length;
  value.displayName = type.substr(NAME_LENGTH + 1, type.length - NAME_LENGTH - 1 - 1);
  return value;
}

function hasWrapper(type, [start, end]) {
  if (type.substr(0, start.length) !== start) {
    return false;
  }

  (0, _util.assert)(type.endsWith(end), `Expected '${start}' closing with '${end}' on ${type}`);
  return true;
}

const nestedExtraction = [['[', ']', _types.TypeDefInfo.VecFixed, _decodeFixedVec], ['{', '}', _types.TypeDefInfo.Struct, _decodeStruct], ['(', ')', _types.TypeDefInfo.Tuple, _decodeTuple], // the inner for these are the same as tuple, multiple values
['BTreeMap<', '>', _types.TypeDefInfo.BTreeMap, _decodeTuple], ['HashMap<', '>', _types.TypeDefInfo.HashMap, _decodeTuple], ['Int<', '>', _types.TypeDefInfo.Int, _decodeInt], ['Result<', '>', _types.TypeDefInfo.Result, _decodeTuple], ['UInt<', '>', _types.TypeDefInfo.UInt, _decodeUInt], ['DoNotConstruct<', '>', _types.TypeDefInfo.DoNotConstruct, _decodeDoNotConstruct]];
const wrappedExtraction = [['BTreeSet<', '>', _types.TypeDefInfo.BTreeSet], ['Compact<', '>', _types.TypeDefInfo.Compact], ['Linkage<', '>', _types.TypeDefInfo.Linkage], ['Option<', '>', _types.TypeDefInfo.Option], ['Vec<', '>', _types.TypeDefInfo.Vec]];

function extractSubType(type, [start, end]) {
  return type.substr(start.length, type.length - start.length - end.length);
}

function getTypeDef(_type, {
  displayName,
  name
} = {}, count = 0) {
  // create the type via Type, allowing types to be sanitized
  const type = (0, _sanitize.default)(_type);
  const value = {
    displayName,
    info: _types.TypeDefInfo.Plain,
    name,
    type
  };

  if (++count === MAX_NESTED) {
    console.warn('getTypeDef: Maximum nested limit reached');
    return value;
  }

  const nested = nestedExtraction.find(nested => hasWrapper(type, nested));

  if (nested) {
    value.info = nested[2];
    return nested[3](value, type, extractSubType(type, nested), count);
  }

  const wrapped = wrappedExtraction.find(wrapped => hasWrapper(type, wrapped));

  if (wrapped) {
    value.info = wrapped[2];
    value.sub = getTypeDef(extractSubType(type, wrapped), {}, count);
  }

  return value;
}

/***/ }),

/***/ "../../node_modules/@polkadot/types/create/index.js":
/*!***************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/create/index.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {};
exports.default = void 0;

var _createType = __webpack_require__(/*! ./createType */ "../../node_modules/@polkadot/types/create/createType.js");

Object.keys(_createType).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _createType[key];
    }
  });
});

var _createClass = __webpack_require__(/*! ./createClass */ "../../node_modules/@polkadot/types/create/createClass.js");

Object.keys(_createClass).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _createClass[key];
    }
  });
});

var _getTypeDef = __webpack_require__(/*! ./getTypeDef */ "../../node_modules/@polkadot/types/create/getTypeDef.js");

Object.keys(_getTypeDef).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _getTypeDef[key];
    }
  });
});

var _registry = __webpack_require__(/*! ./registry */ "../../node_modules/@polkadot/types/create/registry.js");

Object.keys(_registry).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _registry[key];
    }
  });
});

var _typeSplit = __webpack_require__(/*! ./typeSplit */ "../../node_modules/@polkadot/types/create/typeSplit.js");

Object.keys(_typeSplit).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _typeSplit[key];
    }
  });
});
// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _default = _createType.createType;
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types/create/registry.js":
/*!******************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/create/registry.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TypeRegistry = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js"));

var _classPrivateFieldLooseBase2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classPrivateFieldLooseBase */ "../../node_modules/@babel/runtime/helpers/classPrivateFieldLooseBase.js"));

var _classPrivateFieldLooseKey2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classPrivateFieldLooseKey */ "../../node_modules/@babel/runtime/helpers/classPrivateFieldLooseKey.js"));

var _fromMetadata = _interopRequireDefault(__webpack_require__(/*! @polkadot/metadata/Decorated/extrinsics/fromMetadata */ "../../node_modules/@polkadot/metadata/Decorated/extrinsics/fromMetadata/index.js"));

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _utilCrypto = __webpack_require__(/*! @polkadot/util-crypto */ "../../node_modules/@polkadot/util-crypto/index.js");

var _Raw = _interopRequireDefault(__webpack_require__(/*! ../codec/Raw */ "../../node_modules/@polkadot/types/codec/Raw.js"));

var _signedExtensions2 = __webpack_require__(/*! ../extrinsic/signedExtensions */ "../../node_modules/@polkadot/types/extrinsic/signedExtensions/index.js");

var _Event = __webpack_require__(/*! ../generic/Event */ "../../node_modules/@polkadot/types/generic/Event.js");

var _DoNotConstruct = _interopRequireDefault(__webpack_require__(/*! ../primitive/DoNotConstruct */ "../../node_modules/@polkadot/types/primitive/DoNotConstruct.js"));

var _createClass = __webpack_require__(/*! ./createClass */ "../../node_modules/@polkadot/types/create/createClass.js");

var _createType = __webpack_require__(/*! ./createType */ "../../node_modules/@polkadot/types/create/createType.js");

var _getTypeDef = __webpack_require__(/*! ./getTypeDef */ "../../node_modules/@polkadot/types/create/getTypeDef.js");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// create error mapping from metadata
function decorateErrors(_, metadata, metadataErrors) {
  const modules = metadata.asLatest.modules;
  const isIndexed = modules.some(({
    index
  }) => !index.eqn(255)); // decorate the errors

  modules.forEach((section, _sectionIndex) => {
    const sectionIndex = isIndexed ? section.index.toNumber() : _sectionIndex;
    const sectionName = (0, _util.stringCamelCase)(section.name.toString());
    section.errors.forEach(({
      documentation,
      name
    }, index) => {
      const eventIndex = new Uint8Array([sectionIndex, index]);
      metadataErrors[(0, _util.u8aToHex)(eventIndex)] = {
        documentation: documentation.map(d => d.toString()),
        index,
        name: name.toString(),
        section: sectionName
      };
    });
  });
} // create event classes from metadata


function decorateEvents(registry, metadata, metadataEvents) {
  const modules = metadata.asLatest.modules;
  const isIndexed = modules.some(({
    index
  }) => !index.eqn(255)); // decorate the events

  modules.filter(({
    events
  }) => events.isSome).forEach((section, _sectionIndex) => {
    const sectionIndex = isIndexed ? section.index.toNumber() : _sectionIndex;
    const sectionName = (0, _util.stringCamelCase)(section.name.toString());
    section.events.unwrap().forEach((meta, methodIndex) => {
      const methodName = meta.name.toString();
      const eventIndex = new Uint8Array([sectionIndex, methodIndex]); // eslint-disable-next-line @typescript-eslint/no-unsafe-call,@typescript-eslint/no-unsafe-member-access

      const typeDef = meta.args.map(arg => (0, _getTypeDef.getTypeDef)(arg.toString()));
      let Types = [];

      try {
        Types = typeDef.map(typeDef => (0, _createClass.getTypeClass)(registry, typeDef));
      } catch (error) {
        console.error(error);
      }

      metadataEvents[(0, _util.u8aToHex)(eventIndex)] = class extends _Event.EventData {
        constructor(registry, value) {
          super(registry, Types, value, typeDef, meta, sectionName, methodName);
        }

      };
    });
  });
} // create extrinsic mapping from metadata


function decorateExtrinsics(registry, metadata, metadataCalls) {
  const extrinsics = (0, _fromMetadata.default)(registry, metadata); // decorate the extrinsics

  Object.values(extrinsics).forEach(methods => Object.values(methods).forEach(method => {
    metadataCalls[(0, _util.u8aToHex)(method.callIndex)] = method;
  }));
}

var _classes = (0, _classPrivateFieldLooseKey2.default)("classes");

var _definitions = (0, _classPrivateFieldLooseKey2.default)("definitions");

var _metadataCalls = (0, _classPrivateFieldLooseKey2.default)("metadataCalls");

var _metadataErrors = (0, _classPrivateFieldLooseKey2.default)("metadataErrors");

var _metadataEvents = (0, _classPrivateFieldLooseKey2.default)("metadataEvents");

var _unknownTypes = (0, _classPrivateFieldLooseKey2.default)("unknownTypes");

var _chainProperties = (0, _classPrivateFieldLooseKey2.default)("chainProperties");

var _hasher = (0, _classPrivateFieldLooseKey2.default)("hasher");

var _knownDefaults = (0, _classPrivateFieldLooseKey2.default)("knownDefaults");

var _knownDefinitions = (0, _classPrivateFieldLooseKey2.default)("knownDefinitions");

var _knownTypes = (0, _classPrivateFieldLooseKey2.default)("knownTypes");

var _signedExtensions = (0, _classPrivateFieldLooseKey2.default)("signedExtensions");

class TypeRegistry {
  constructor() {
    Object.defineProperty(this, _classes, {
      writable: true,
      value: new Map()
    });
    Object.defineProperty(this, _definitions, {
      writable: true,
      value: new Map()
    });
    Object.defineProperty(this, _metadataCalls, {
      writable: true,
      value: {}
    });
    Object.defineProperty(this, _metadataErrors, {
      writable: true,
      value: {}
    });
    Object.defineProperty(this, _metadataEvents, {
      writable: true,
      value: {}
    });
    Object.defineProperty(this, _unknownTypes, {
      writable: true,
      value: new Map()
    });
    Object.defineProperty(this, _chainProperties, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _hasher, {
      writable: true,
      value: _utilCrypto.blake2AsU8a
    });
    Object.defineProperty(this, _knownDefaults, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _knownDefinitions, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _knownTypes, {
      writable: true,
      value: {}
    });
    Object.defineProperty(this, _signedExtensions, {
      writable: true,
      value: _signedExtensions2.defaultExtensions
    });

    // we only want to import these on creation, i.e. we want to avoid weird
    // side-effects from circular references. (Since registry is injected
    // into types, this can be a real concern now)
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    const baseTypes = __webpack_require__(/*! ../index.types */ "../../node_modules/@polkadot/types/index.types.js"); // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment


    const definitions = __webpack_require__(/*! ../interfaces/definitions */ "../../node_modules/@polkadot/types/interfaces/definitions.js");

    (0, _classPrivateFieldLooseBase2.default)(this, _knownDefaults)[_knownDefaults] = _objectSpread({
      Raw: _Raw.default
    }, baseTypes);
    (0, _classPrivateFieldLooseBase2.default)(this, _knownDefinitions)[_knownDefinitions] = definitions;
    this.init();
  }

  init() {
    // start clean
    (0, _classPrivateFieldLooseBase2.default)(this, _classes)[_classes] = new Map();
    (0, _classPrivateFieldLooseBase2.default)(this, _definitions)[_definitions] = new Map();
    (0, _classPrivateFieldLooseBase2.default)(this, _unknownTypes)[_unknownTypes] = new Map();
    (0, _classPrivateFieldLooseBase2.default)(this, _knownTypes)[_knownTypes] = {}; // register know, first classes then on-demand-created definitions

    this.register((0, _classPrivateFieldLooseBase2.default)(this, _knownDefaults)[_knownDefaults]);
    Object.values((0, _classPrivateFieldLooseBase2.default)(this, _knownDefinitions)[_knownDefinitions]).forEach(({
      types
    }) => this.register(types));
    return this;
  }

  get chainDecimals() {
    var _classPrivateFieldLoo;

    return ((_classPrivateFieldLoo = (0, _classPrivateFieldLooseBase2.default)(this, _chainProperties)[_chainProperties]) === null || _classPrivateFieldLoo === void 0 ? void 0 : _classPrivateFieldLoo.tokenDecimals.isSome) ? (0, _classPrivateFieldLooseBase2.default)(this, _chainProperties)[_chainProperties].tokenDecimals.unwrap().toNumber() : 12;
  }

  get chainSS58() {
    var _classPrivateFieldLoo2;

    return ((_classPrivateFieldLoo2 = (0, _classPrivateFieldLooseBase2.default)(this, _chainProperties)[_chainProperties]) === null || _classPrivateFieldLoo2 === void 0 ? void 0 : _classPrivateFieldLoo2.ss58Format.isSome) ? (0, _classPrivateFieldLooseBase2.default)(this, _chainProperties)[_chainProperties].ss58Format.unwrap().toNumber() : undefined;
  }

  get chainToken() {
    var _classPrivateFieldLoo3;

    return ((_classPrivateFieldLoo3 = (0, _classPrivateFieldLooseBase2.default)(this, _chainProperties)[_chainProperties]) === null || _classPrivateFieldLoo3 === void 0 ? void 0 : _classPrivateFieldLoo3.tokenSymbol.isSome) ? (0, _classPrivateFieldLooseBase2.default)(this, _chainProperties)[_chainProperties].tokenSymbol.unwrap().toString() : _util.formatBalance.getDefaults().unit;
  }

  get knownTypes() {
    return (0, _classPrivateFieldLooseBase2.default)(this, _knownTypes)[_knownTypes];
  }

  get signedExtensions() {
    return (0, _classPrivateFieldLooseBase2.default)(this, _signedExtensions)[_signedExtensions];
  }
  /**
   * @describe Creates an instance of the class
   */


  createClass(type) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return (0, _createClass.createClass)(this, type);
  }
  /**
   * @description Creates an instance of a type as registered
   */


  createType(type, ...params) {
    return (0, _createType.createType)(this, type, ...params);
  } // find a specific call


  findMetaCall(callIndex) {
    const hexIndex = (0, _util.u8aToHex)(callIndex);

    const fn = (0, _classPrivateFieldLooseBase2.default)(this, _metadataCalls)[_metadataCalls][hexIndex];

    (0, _util.assert)(!(0, _util.isUndefined)(fn), `findMetaCall: Unable to find Call with index ${hexIndex}/[${callIndex.toString()}]`);
    return fn;
  } // finds an error


  findMetaError(errorIndex) {
    const hexIndex = (0, _util.u8aToHex)((0, _util.isU8a)(errorIndex) ? errorIndex : new Uint8Array([errorIndex.index.toNumber(), errorIndex.error.toNumber()]));

    const error = (0, _classPrivateFieldLooseBase2.default)(this, _metadataErrors)[_metadataErrors][hexIndex];

    (0, _util.assert)(!(0, _util.isUndefined)(error), `findMetaError: Unable to find Error with index ${hexIndex}/[${errorIndex.toString()}]`);
    return error;
  }

  findMetaEvent(eventIndex) {
    const hexIndex = (0, _util.u8aToHex)(eventIndex);

    const Event = (0, _classPrivateFieldLooseBase2.default)(this, _metadataEvents)[_metadataEvents][hexIndex];

    (0, _util.assert)(!(0, _util.isUndefined)(Event), `findMetaEvent: Unable to find Event with index ${hexIndex}/[${eventIndex.toString()}]`);
    return Event;
  }

  get(name, withUnknown) {
    let Type = (0, _classPrivateFieldLooseBase2.default)(this, _classes)[_classes].get(name); // we have not already created the type, attempt it


    if (!Type) {
      const definition = (0, _classPrivateFieldLooseBase2.default)(this, _definitions)[_definitions].get(name);

      let BaseType; // we have a definition, so create the class now (lazily)

      if (definition) {
        BaseType = (0, _createClass.createClass)(this, definition);
      } else if (withUnknown) {
        console.warn(`Unable to resolve type ${name}, it will fail on construction`);

        (0, _classPrivateFieldLooseBase2.default)(this, _unknownTypes)[_unknownTypes].set(name, true);

        BaseType = _DoNotConstruct.default.with(name);
      }

      if (BaseType) {
        // NOTE If we didn't extend here, we would have strange artifacts. An example is
        // Balance, with this, new Balance() instanceof u128 is true, but Balance !== u128
        // Additionally, we now pass through the registry, which is a link to ourselves
        Type = class extends BaseType {};

        (0, _classPrivateFieldLooseBase2.default)(this, _classes)[_classes].set(name, Type);
      }
    }

    return Type;
  }

  getChainProperties() {
    return (0, _classPrivateFieldLooseBase2.default)(this, _chainProperties)[_chainProperties];
  }

  getClassName(clazz) {
    const entry = [...(0, _classPrivateFieldLooseBase2.default)(this, _classes)[_classes].entries()].find(([, test]) => test === clazz);
    return entry ? entry[0] : undefined;
  }

  getDefinition(name) {
    return (0, _classPrivateFieldLooseBase2.default)(this, _definitions)[_definitions].get(name);
  }

  getOrThrow(name, msg) {
    const Type = this.get(name);

    if ((0, _util.isUndefined)(Type)) {
      throw new Error(msg || `type ${name} not found`);
    }

    return Type;
  }

  getOrUnknown(name) {
    return this.get(name, true);
  }

  getSignedExtensionExtra() {
    return (0, _signedExtensions2.expandExtensionTypes)((0, _classPrivateFieldLooseBase2.default)(this, _signedExtensions)[_signedExtensions], 'extra');
  }

  getSignedExtensionTypes() {
    return (0, _signedExtensions2.expandExtensionTypes)((0, _classPrivateFieldLooseBase2.default)(this, _signedExtensions)[_signedExtensions], 'types');
  }

  hasClass(name) {
    return (0, _classPrivateFieldLooseBase2.default)(this, _classes)[_classes].has(name);
  }

  hasDef(name) {
    return (0, _classPrivateFieldLooseBase2.default)(this, _definitions)[_definitions].has(name);
  }

  hasType(name) {
    return !(0, _classPrivateFieldLooseBase2.default)(this, _unknownTypes)[_unknownTypes].get(name) && (this.hasClass(name) || this.hasDef(name));
  }

  hash(data) {
    return (0, _classPrivateFieldLooseBase2.default)(this, _hasher)[_hasher](data);
  }

  // eslint-disable-next-line no-dupe-class-members
  register(arg1, arg2) {
    // NOTE Constructors appear as functions here
    if ((0, _util.isFunction)(arg1)) {
      (0, _classPrivateFieldLooseBase2.default)(this, _classes)[_classes].set(arg1.name, arg1);
    } else if ((0, _util.isString)(arg1)) {
      (0, _util.assert)((0, _util.isFunction)(arg2), `Expected class definition passed to '${arg1}' registration`);

      (0, _classPrivateFieldLooseBase2.default)(this, _classes)[_classes].set(arg1, arg2);
    } else {
      this._registerObject(arg1);
    }
  }

  _registerObject(obj) {
    Object.entries(obj).forEach(([name, type]) => {
      if ((0, _util.isFunction)(type)) {
        // This _looks_ a bit funny, but `typeof Clazz === 'function'
        (0, _classPrivateFieldLooseBase2.default)(this, _classes)[_classes].set(name, type);
      } else {
        const def = (0, _util.isString)(type) ? type : JSON.stringify(type); // we already have this type, remove the classes registered for it

        if ((0, _classPrivateFieldLooseBase2.default)(this, _classes)[_classes].has(name)) {
          (0, _classPrivateFieldLooseBase2.default)(this, _classes)[_classes].delete(name);
        }

        (0, _classPrivateFieldLooseBase2.default)(this, _definitions)[_definitions].set(name, def);
      }
    });
  } // sets the chain properties


  setChainProperties(properties) {
    if (properties) {
      (0, _classPrivateFieldLooseBase2.default)(this, _chainProperties)[_chainProperties] = properties;
    }
  }

  setHasher(hasher = _utilCrypto.blake2AsU8a) {
    (0, _classPrivateFieldLooseBase2.default)(this, _hasher)[_hasher] = hasher;
  }

  setKnownTypes(knownTypes) {
    (0, _classPrivateFieldLooseBase2.default)(this, _knownTypes)[_knownTypes] = knownTypes;
  } // sets the metadata


  setMetadata(metadata, signedExtensions) {
    decorateExtrinsics(this, metadata, (0, _classPrivateFieldLooseBase2.default)(this, _metadataCalls)[_metadataCalls]);
    decorateErrors(this, metadata, (0, _classPrivateFieldLooseBase2.default)(this, _metadataErrors)[_metadataErrors]);
    decorateEvents(this, metadata, (0, _classPrivateFieldLooseBase2.default)(this, _metadataEvents)[_metadataEvents]); // setup the available extensions

    this.setSignedExtensions(signedExtensions || (metadata.asLatest.extrinsic.version.gt(_util.BN_ZERO) ? metadata.asLatest.extrinsic.signedExtensions.map(key => key.toString()) : _signedExtensions2.defaultExtensions));
  } // sets the available signed extensions


  setSignedExtensions(signedExtensions = _signedExtensions2.defaultExtensions) {
    (0, _classPrivateFieldLooseBase2.default)(this, _signedExtensions)[_signedExtensions] = signedExtensions;
    const unknown = (0, _signedExtensions2.findUnknownExtensions)((0, _classPrivateFieldLooseBase2.default)(this, _signedExtensions)[_signedExtensions]);

    if (unknown.length) {
      console.warn(`Unknown signed extensions ${unknown.join(', ')} found, treating them as no-effect`);
    }
  }

}

exports.TypeRegistry = TypeRegistry;

/***/ }),

/***/ "../../node_modules/@polkadot/types/create/sanitize.js":
/*!******************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/create/sanitize.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findClosing = findClosing;
exports.alias = alias;
exports.cleanupCompact = cleanupCompact;
exports.flattenSingleTuple = flattenSingleTuple;
exports.removeColons = removeColons;
exports.removeGenerics = removeGenerics;
exports.removePairOf = removePairOf;
exports.removeTraits = removeTraits;
exports.removeWrap = removeWrap;
exports.default = sanitize;
// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
const ALLOWED_BOXES = ['BTreeMap', 'BTreeSet', 'Compact', 'DoNotConstruct', 'HashMap', 'Int', 'Linkage', 'Result', 'Option', 'UInt', 'Vec'];
const BOX_PRECEDING = ['<', '(', '[', '"', ',', ' ']; // start of vec, tuple, fixed array, part of struct def or in tuple

const mappings = [// alias <T::InherentOfflineReport as InherentOfflineReport>::Inherent -> InherentOfflineReport
alias(['<T::InherentOfflineReport as InherentOfflineReport>::Inherent'], 'InherentOfflineReport', false), // <T::Balance as HasCompact>
cleanupCompact(), // Remove all the trait prefixes
removeTraits(), // remove PairOf<T> -> (T, T)
removePairOf(), // remove boxing, `Box<Proposal>` -> `Proposal`
removeWrap('Box'), // remove generics, `MisbehaviorReport<Hash, BlockNumber>` -> `MisbehaviorReport`
removeGenerics(), // alias String -> Text (compat with jsonrpc methods)
alias(['String'], 'Text'), // alias Vec<u8> -> Bytes
alias(['Vec<u8>', '&\\[u8\\]'], 'Bytes'), // alias RawAddress -> Address
alias(['RawAddress'], 'Address'), // lookups, mapped to Address/AccountId as appropriate in runtime
alias(['Lookup::Source'], 'LookupSource'), alias(['Lookup::Target'], 'LookupTarget'), // HACK duplication between contracts & primitives, however contracts prefixed with exec
alias(['exec::StorageKey'], 'ContractStorageKey'), // flattens tuples with one value, `(AccountId)` -> `AccountId`
flattenSingleTuple(), // converts ::Type to Type, <T as Trait<I>>::Proposal -> Proposal
removeColons()]; // given a starting index, find the closing >

function findClosing(value, start) {
  let depth = 0;

  for (let index = start; index < value.length; index++) {
    if (value[index] === '>') {
      if (!depth) {
        return index;
      }

      depth--;
    } else if (value[index] === '<') {
      depth++;
    }
  }

  throw new Error(`Unable to find closing matching <> on '${value}' (start ${start})`);
}

function alias(src, dest, withChecks = true) {
  return value => {
    return src.reduce((value, src) => {
      return value.replace(new RegExp(`(^${src}|${BOX_PRECEDING.map(box => `\\${box}${src}`).join('|')})`, 'g'), src => withChecks && BOX_PRECEDING.includes(src[0]) ? `${src[0]}${dest}` : dest);
    }, value);
  };
}

function cleanupCompact() {
  return value => {
    for (let index = 0; index < value.length; index++) {
      if (value[index] !== '<') {
        continue;
      }

      const end = findClosing(value, index + 1) - 14;

      if (value.substr(end, 14) === ' as HasCompact') {
        value = `Compact<${value.substr(index + 1, end - index - 1)}>`;
      }
    }

    return value;
  };
}

function flattenSingleTuple() {
  return value => {
    return value.replace(/\(([^,]+)\)/, '$1');
  };
}

function removeColons() {
  return (value, {
    allowNamespaces
  } = {}) => {
    let index = 0;

    while (index !== -1) {
      index = value.indexOf('::');

      if (index === 0) {
        value = value.substr(2);
      } else if (index !== -1) {
        if (allowNamespaces) {
          return value;
        }

        let start = index;

        while (start !== -1 && !BOX_PRECEDING.includes(value[start])) {
          start--;
        }

        value = `${value.substr(0, start + 1)}${value.substr(index + 2)}`;
      }
    }

    return value;
  };
}

function removeGenerics() {
  return value => {
    for (let index = 0; index < value.length; index++) {
      if (value[index] === '<') {
        // check against the allowed wrappers, be it Vec<..>, Option<...> ...
        const box = ALLOWED_BOXES.find(box => {
          const start = index - box.length;
          return start >= 0 && value.substr(start, box.length) === box && ( // make sure it is stand-alone, i.e. don't catch ElectionResult<...> as Result<...>
          start === 0 || BOX_PRECEDING.includes(value[start - 1]));
        }); // we have not found anything, unwrap generic innards

        if (!box) {
          const end = findClosing(value, index + 1);
          value = `${value.substr(0, index)}${value.substr(end + 1)}`;
        }
      }
    }

    return value;
  };
} // remove the PairOf wrappers


function removePairOf() {
  return value => {
    for (let index = 0; index < value.length; index++) {
      if (value.substr(index, 7) === 'PairOf<') {
        const start = index + 7;
        const end = findClosing(value, start);
        const type = value.substr(start, end - start);
        value = `${value.substr(0, index)}(${type},${type})${value.substr(end + 1)}`;
      }
    }

    return value;
  };
} // remove the type traits


function removeTraits() {
  return value => {
    return value // remove all whitespaces
    .replace(/\s/g, '') // anything `T::<type>` to end up as `<type>`
    .replace(/(T|Self)::/g, '') // replace `<T as Trait>::` (whitespaces were removed above)
    .replace(/<(T|Self)asTrait>::/g, '') // replace `<T as something::Trait>::` (whitespaces were removed above)
    .replace(/<Tas[a-z]+::Trait>::/g, '') // replace <Lookup as StaticLookup>
    .replace(/<LookupasStaticLookup>/g, 'Lookup') // replace `<...>::Type`
    .replace(/::Type/g, '');
  };
} // remove wrapping values, i.e. Box<Proposal> -> Proposal


function removeWrap(_check) {
  const check = `${_check}<`;
  return value => {
    let index = 0;

    while (index !== -1) {
      index = value.indexOf(check);

      if (index !== -1) {
        const start = index + check.length;
        const end = findClosing(value, start);
        value = `${value.substr(0, index)}${value.substr(start, end - start)}${value.substr(end + 1)}`;
      }
    }

    return value;
  };
}

function sanitize(value, options) {
  return mappings.reduce((result, fn) => {
    return fn(result, options);
  }, value).trim();
}

/***/ }),

/***/ "../../node_modules/@polkadot/types/create/typeSplit.js":
/*!*******************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/create/typeSplit.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.typeSplit = typeSplit;

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
function isNotNested(...counters) {
  return !counters.some(counter => counter !== 0);
} // safely split a string on ', ' while taking care of any nested occurences


function typeSplit(type) {
  let [cDepth, fDepth, sDepth, tDepth, start] = [0, 0, 0, 0, 0];
  const result = [];

  const extract = index => {
    if (isNotNested(cDepth, fDepth, sDepth, tDepth)) {
      result.push(type.substr(start, index - start).trim());
      start = index + 1;
    }
  };

  for (let index = 0; index < type.length; index++) {
    switch (type[index]) {
      // if we are not nested, add the type
      case ',':
        extract(index);
        break;
      // adjust compact/vec (and friends) depth

      case '<':
        cDepth++;
        break;

      case '>':
        cDepth--;
        break;
      // adjust fixed vec depths

      case '[':
        fDepth++;
        break;

      case ']':
        fDepth--;
        break;
      // adjust struct depth

      case '{':
        sDepth++;
        break;

      case '}':
        sDepth--;
        break;
      // adjust tuple depth

      case '(':
        tDepth++;
        break;

      case ')':
        tDepth--;
        break;
    }
  }

  (0, _util.assert)(isNotNested(cDepth, fDepth, sDepth, tDepth), `Invalid defintion (missing terminators) found in ${type}`); // the final leg of the journey

  result.push(type.substr(start, type.length - start).trim());
  return result;
}

/***/ }),

/***/ "../../node_modules/@polkadot/types/create/types.js":
/*!***************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/create/types.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MetaRegistryItem = exports.MetaTypeInfo = exports.TypeDefInfo = void 0;
// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Type which says: if `K` is in the InterfaceTypes, then return InterfaceTypes[K], else fallback to T
let TypeDefInfo;
exports.TypeDefInfo = TypeDefInfo;

(function (TypeDefInfo) {
  TypeDefInfo[TypeDefInfo["BTreeMap"] = 0] = "BTreeMap";
  TypeDefInfo[TypeDefInfo["BTreeSet"] = 1] = "BTreeSet";
  TypeDefInfo[TypeDefInfo["Compact"] = 2] = "Compact";
  TypeDefInfo[TypeDefInfo["Enum"] = 3] = "Enum";
  TypeDefInfo[TypeDefInfo["Linkage"] = 4] = "Linkage";
  TypeDefInfo[TypeDefInfo["Option"] = 5] = "Option";
  TypeDefInfo[TypeDefInfo["Plain"] = 6] = "Plain";
  TypeDefInfo[TypeDefInfo["Result"] = 7] = "Result";
  TypeDefInfo[TypeDefInfo["Set"] = 8] = "Set";
  TypeDefInfo[TypeDefInfo["Struct"] = 9] = "Struct";
  TypeDefInfo[TypeDefInfo["Tuple"] = 10] = "Tuple";
  TypeDefInfo[TypeDefInfo["Vec"] = 11] = "Vec";
  TypeDefInfo[TypeDefInfo["VecFixed"] = 12] = "VecFixed";
  TypeDefInfo[TypeDefInfo["HashMap"] = 13] = "HashMap";
  TypeDefInfo[TypeDefInfo["Int"] = 14] = "Int";
  TypeDefInfo[TypeDefInfo["UInt"] = 15] = "UInt";
  TypeDefInfo[TypeDefInfo["DoNotConstruct"] = 16] = "DoNotConstruct";
  TypeDefInfo[TypeDefInfo["Null"] = 17] = "Null";
})(TypeDefInfo || (exports.TypeDefInfo = TypeDefInfo = {}));

let MetaTypeInfo;
exports.MetaTypeInfo = MetaTypeInfo;

(function (MetaTypeInfo) {
  MetaTypeInfo[MetaTypeInfo["BuiltinPlain"] = 0] = "BuiltinPlain";
  MetaTypeInfo[MetaTypeInfo["BuiltinTuple"] = 1] = "BuiltinTuple";
  MetaTypeInfo[MetaTypeInfo["BuiltinVec"] = 2] = "BuiltinVec";
  MetaTypeInfo[MetaTypeInfo["BuiltinVecFixed"] = 3] = "BuiltinVecFixed";
  MetaTypeInfo[MetaTypeInfo["Enum"] = 4] = "Enum";
  MetaTypeInfo[MetaTypeInfo["ClikeEnum"] = 5] = "ClikeEnum";
  MetaTypeInfo[MetaTypeInfo["Struct"] = 6] = "Struct";
  MetaTypeInfo[MetaTypeInfo["TupleStruct"] = 7] = "TupleStruct";
  MetaTypeInfo[MetaTypeInfo["Null"] = 8] = "Null";
})(MetaTypeInfo || (exports.MetaTypeInfo = MetaTypeInfo = {}));

let MetaRegistryItem;
exports.MetaRegistryItem = MetaRegistryItem;

(function (MetaRegistryItem) {
  MetaRegistryItem[MetaRegistryItem["String"] = 0] = "String";
  MetaRegistryItem[MetaRegistryItem["Type"] = 1] = "Type";
  MetaRegistryItem[MetaRegistryItem["TypeDef"] = 2] = "TypeDef";
})(MetaRegistryItem || (exports.MetaRegistryItem = MetaRegistryItem = {}));

/***/ }),

/***/ "../../node_modules/@polkadot/types/ethereum/AccountId.js":
/*!*********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/ethereum/AccountId.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _utilCrypto = __webpack_require__(/*! @polkadot/util-crypto */ "../../node_modules/@polkadot/util-crypto/index.js");

var _U8aFixed = _interopRequireDefault(__webpack_require__(/*! ../codec/U8aFixed */ "../../node_modules/@polkadot/types/codec/U8aFixed.js"));

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0

/** @internal */
function decodeAccountId(value) {
  if ((0, _util.isU8a)(value) || Array.isArray(value)) {
    return (0, _util.u8aToU8a)(value);
  } else if ((0, _util.isHex)(value) || (0, _utilCrypto.isEthereumAddress)(value)) {
    return (0, _util.hexToU8a)(value.toString());
  } else if ((0, _util.isString)(value)) {
    return (0, _util.u8aToU8a)(value.toString());
  }

  return value;
}
/**
 * @name EthereumAccountId
 * @description
 * A wrapper around an Ethereum-compatible AccountId. Since we are dealing with
 * underlying addresses (20 bytes in length), we extend from U8aFixed which is
 * just a Uint8Array wrapper with a fixed length.
 */


class AccountId extends _U8aFixed.default {
  constructor(registry, value = new Uint8Array()) {
    super(registry, decodeAccountId(value), 160);
  }

  static encode(value) {
    return (0, _utilCrypto.ethereumEncode)(value);
  }
  /**
   * @description Compares the value of the input to see if there is a match
   */


  eq(other) {
    return super.eq(decodeAccountId(other));
  }
  /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */


  toHuman() {
    return this.toJSON();
  }
  /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */


  toJSON() {
    return this.toString();
  }
  /**
   * @description Returns the string representation of the value
   */


  toString() {
    return AccountId.encode(this);
  }
  /**
   * @description Returns the base runtime type name for this instance
   */


  toRawType() {
    return 'AccountId';
  }

}

exports.default = AccountId;

/***/ }),

/***/ "../../node_modules/@polkadot/types/ethereum/LookupSource.js":
/*!************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/ethereum/LookupSource.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.ACCOUNT_ID_PREFIX = void 0;

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _utilCrypto = __webpack_require__(/*! @polkadot/util-crypto */ "../../node_modules/@polkadot/util-crypto/index.js");

var _Base = _interopRequireDefault(__webpack_require__(/*! ../codec/Base */ "../../node_modules/@polkadot/types/codec/Base.js"));

var _AccountIndex = _interopRequireDefault(__webpack_require__(/*! ../generic/AccountIndex */ "../../node_modules/@polkadot/types/generic/AccountIndex.js"));

var _AccountId = _interopRequireDefault(__webpack_require__(/*! ./AccountId */ "../../node_modules/@polkadot/types/ethereum/AccountId.js"));

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
const ACCOUNT_ID_PREFIX = new Uint8Array([0xff]);
/** @internal */

exports.ACCOUNT_ID_PREFIX = ACCOUNT_ID_PREFIX;

function decodeString(registry, value) {
  const decoded = (0, _utilCrypto.decodeAddress)(value);
  return decoded.length === 20 ? registry.createType('EthereumAccountId', decoded) : registry.createType('AccountIndex', (0, _util.u8aToBn)(decoded, true));
}
/** @internal */


function decodeU8a(registry, value) {
  // This allows us to instantiate an address with a raw publicKey. Do this first before
  // we checking the first byte, otherwise we may split an already-existent valid address
  if (value.length === 20) {
    return registry.createType('EthereumAccountId', value);
  } else if (value[0] === 0xff) {
    return registry.createType('EthereumAccountId', value.subarray(1));
  }

  const [offset, length] = _AccountIndex.default.readLength(value);

  return registry.createType('AccountIndex', (0, _util.u8aToBn)(value.subarray(offset, offset + length), true));
}
/**
 * @name LookupSource
 * @description
 * A wrapper around an EthereumAccountId and/or AccountIndex that is encoded with a prefix.
 * Since we are dealing with underlying publicKeys (or shorter encoded addresses),
 * we extend from Base with an AccountId/AccountIndex wrapper. Basically the Address
 * is encoded as `[ <prefix-byte>, ...publicKey/...bytes ]` as per spec
 */


class LookupSource extends _Base.default {
  constructor(registry, value = new Uint8Array()) {
    super(registry, LookupSource._decodeAddress(registry, value));
  }
  /** @internal */


  static _decodeAddress(registry, value) {
    if (value instanceof _AccountId.default || value instanceof _AccountIndex.default) {
      return value;
    } else if (value instanceof LookupSource) {
      return value._raw;
    } else if ((0, _util.isBn)(value) || (0, _util.isNumber)(value)) {
      return registry.createType('AccountIndex', value);
    } else if (Array.isArray(value) || (0, _util.isHex)(value) || (0, _util.isU8a)(value)) {
      return decodeU8a(registry, (0, _util.u8aToU8a)(value));
    }

    return decodeString(registry, value);
  }
  /**
   * @description The length of the value when encoded as a Uint8Array
   */


  get encodedLength() {
    const rawLength = this._rawLength;
    return rawLength + ( // for 1 byte AccountIndexes, we are not adding a specific prefix
    rawLength > 1 ? 1 : 0);
  }
  /**
   * @description The length of the raw value, either AccountIndex or AccountId
   */


  get _rawLength() {
    return this._raw instanceof _AccountIndex.default ? _AccountIndex.default.calcLength(this._raw) : this._raw.encodedLength;
  }
  /**
   * @description Returns a hex string representation of the value
   */


  toHex() {
    return (0, _util.u8aToHex)(this.toU8a());
  }
  /**
   * @description Returns the base runtime type name for this instance
   */


  toRawType() {
    return 'Address';
  }
  /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */


  toU8a(isBare) {
    const encoded = this._raw.toU8a().subarray(0, this._rawLength);

    return isBare ? encoded : (0, _util.u8aConcat)(this._raw instanceof _AccountIndex.default ? _AccountIndex.default.writeLength(encoded) : ACCOUNT_ID_PREFIX, encoded);
  }

}

exports.default = LookupSource;

/***/ }),

/***/ "../../node_modules/@polkadot/types/ethereum/index.js":
/*!*****************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/ethereum/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "GenericEthereumAccountId", {
  enumerable: true,
  get: function () {
    return _AccountId.default;
  }
});
Object.defineProperty(exports, "GenericEthereumLookupSource", {
  enumerable: true,
  get: function () {
    return _LookupSource.default;
  }
});

var _AccountId = _interopRequireDefault(__webpack_require__(/*! ./AccountId */ "../../node_modules/@polkadot/types/ethereum/AccountId.js"));

var _LookupSource = _interopRequireDefault(__webpack_require__(/*! ./LookupSource */ "../../node_modules/@polkadot/types/ethereum/LookupSource.js"));

/***/ }),

/***/ "../../node_modules/@polkadot/types/extrinsic/Extrinsic.js":
/*!**********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/extrinsic/Extrinsic.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "LATEST_EXTRINSIC_VERSION", {
  enumerable: true,
  get: function () {
    return _Extrinsic.EXTRINSIC_VERSION;
  }
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js"));

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _Base = _interopRequireDefault(__webpack_require__(/*! ../codec/Base */ "../../node_modules/@polkadot/types/codec/Base.js"));

var _Compact = _interopRequireDefault(__webpack_require__(/*! ../codec/Compact */ "../../node_modules/@polkadot/types/codec/Compact.js"));

var _constants = __webpack_require__(/*! ./constants */ "../../node_modules/@polkadot/types/extrinsic/constants.js");

var _Extrinsic = __webpack_require__(/*! ./v4/Extrinsic */ "../../node_modules/@polkadot/types/extrinsic/v4/Extrinsic.js");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const VERSIONS = ['ExtrinsicUnknown', // v0 is unknown
'ExtrinsicUnknown', 'ExtrinsicUnknown', 'ExtrinsicUnknown', 'ExtrinsicV4'];

class ExtrinsicBase extends _Base.default {
  /**
   * @description The arguments passed to for the call, exposes args so it is compatible with [[Call]]
   */
  get args() {
    return this.method.args;
  }
  /**
   * @description The argument definitions, compatible with [[Call]]
   */


  get argsDef() {
    return this.method.argsDef;
  }
  /**
   * @description The actual `[sectionIndex, methodIndex]` as used in the Call
   */


  get callIndex() {
    return this.method.callIndex;
  }
  /**
   * @description The actual data for the Call
   */


  get data() {
    return this.method.data;
  }
  /**
   * @description The era for this extrinsic
   */


  get era() {
    return this._raw.signature.era;
  }
  /**
   * @description The length of the value when encoded as a Uint8Array
   */


  get encodedLength() {
    return this.toU8a().length;
  }
  /**
   * @description `true` is method has `Origin` argument (compatibility with [Call])
   */


  get hasOrigin() {
    return this.method.hasOrigin;
  }
  /**
   * @description `true` id the extrinsic is signed
   */


  get isSigned() {
    return this._raw.signature.isSigned;
  }
  /**
   * @description The length of the actual data, excluding prefix
   */


  get length() {
    return this.toU8a(true).length;
  }
  /**
   * @description The [[FunctionMetadataLatest]] that describes the extrinsic
   */


  get meta() {
    return this.method.meta;
  }
  /**
   * @description The [[Call]] this extrinsic wraps
   */


  get method() {
    return this._raw.method;
  }
  /**
   * @description The nonce for this extrinsic
   */


  get nonce() {
    return this._raw.signature.nonce;
  }
  /**
   * @description The actual [[EcdsaSignature]], [[Ed25519Signature]] or [[Sr25519Signature]]
   */


  get signature() {
    return this._raw.signature.signature;
  }
  /**
   * @description The [[Address]] that signed
   */


  get signer() {
    return this._raw.signature.signer;
  }
  /**
   * @description Forwards compat
   */


  get tip() {
    return this._raw.signature.tip;
  }
  /**
   * @description Returns the raw transaction version (not flagged with signing information)
  */


  get type() {
    return this._raw.version;
  }
  /**
   * @description Returns the encoded version flag
  */


  get version() {
    return this.type | (this.isSigned ? _constants.BIT_SIGNED : _constants.BIT_UNSIGNED);
  }

}
/**
 * @name GenericExtrinsic
 * @description
 * Representation of an Extrinsic in the system. It contains the actual call,
 * (optional) signature and encodes with an actual length prefix
 *
 * {@link https://github.com/paritytech/wiki/blob/master/Extrinsic.md#the-extrinsic-format-for-node}.
 *
 * Can be:
 * - signed, to create a transaction
 * - left as is, to create an inherent
 */


class Extrinsic extends ExtrinsicBase {
  constructor(registry, value, {
    version
  } = {}) {
    super(registry, Extrinsic._decodeExtrinsic(registry, value, version));
  }
  /** @internal */


  static _newFromValue(registry, value, version) {
    if (value instanceof Extrinsic) {
      return value._raw;
    }

    const isSigned = (version & _constants.BIT_SIGNED) === _constants.BIT_SIGNED;
    const type = VERSIONS[version & _constants.UNMASK_VERSION] || VERSIONS[0]; // we cast here since the VERSION definition is incredibly broad - we don't have a
    // slice for "only add extrinsic types", and more string definitions become unwieldy

    return registry.createType(type, value, {
      isSigned,
      version
    });
  }
  /** @internal */


  static _decodeExtrinsic(registry, value, version = _constants.DEFAULT_VERSION) {
    if ((0, _util.isU8a)(value) || Array.isArray(value) || (0, _util.isHex)(value)) {
      return Extrinsic._decodeU8a(registry, (0, _util.u8aToU8a)(value), version);
    } else if (value instanceof registry.createClass('Call')) {
      return Extrinsic._newFromValue(registry, {
        method: value
      }, version);
    }

    return Extrinsic._newFromValue(registry, value, version);
  }
  /** @internal */


  static _decodeU8a(registry, value, version) {
    if (!value.length) {
      return Extrinsic._newFromValue(registry, new Uint8Array(), version);
    }

    const [offset, length] = _Compact.default.decodeU8a(value);

    const total = offset + length.toNumber();
    (0, _util.assert)(total <= value.length, `Extrinsic: length less than remainder, expected at least ${total}, found ${value.length}`);
    const data = value.subarray(offset, total);
    return Extrinsic._newFromValue(registry, data.subarray(1), data[0]);
  }
  /**
   * @description Injects an already-generated signature into the extrinsic
   */


  addSignature(signer, signature, payload) {
    this._raw.addSignature(signer, signature, payload);

    return this;
  }
  /**
   * @description Sign the extrinsic with a specific keypair
   */


  sign(account, options) {
    this._raw.sign(account, options);

    return this;
  }
  /**
   * @describe Adds a fake signature to the extrinsic
   */


  signFake(signer, options) {
    this._raw.signFake(signer, options);

    return this;
  }
  /**
   * @description Returns a hex string representation of the value
   */


  toHex(isBare) {
    return (0, _util.u8aToHex)(this.toU8a(isBare));
  }
  /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */


  toHuman(isExpanded) {
    return _objectSpread({
      isSigned: this.isSigned,
      method: this.method.toHuman(isExpanded)
    }, this.isSigned ? {
      era: this.era.toHuman(isExpanded),
      nonce: this.nonce.toHuman(isExpanded),
      signature: this.signature.toHex(),
      signer: this.signer.toHuman(isExpanded),
      tip: this.tip.toHuman(isExpanded)
    } : {});
  }
  /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */


  toJSON() {
    return this.toHex();
  }
  /**
   * @description Returns the base runtime type name for this instance
   */


  toRawType() {
    return 'Extrinsic';
  }
  /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value is not length-prefixed
   */


  toU8a(isBare) {
    // we do not apply bare to the internal values, rather this only determines out length addition,
    // where we strip all lengths this creates an extrinsic that cannot be decoded
    const encoded = (0, _util.u8aConcat)(new Uint8Array([this.version]), this._raw.toU8a());
    return isBare ? encoded : _Compact.default.addLengthPrefix(encoded);
  }

}

exports.default = Extrinsic;

/***/ }),

/***/ "../../node_modules/@polkadot/types/extrinsic/ExtrinsicEra.js":
/*!*************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/extrinsic/ExtrinsicEra.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.MortalEra = exports.ImmortalEra = void 0;

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _Enum = _interopRequireDefault(__webpack_require__(/*! ../codec/Enum */ "../../node_modules/@polkadot/types/codec/Enum.js"));

var _Tuple = _interopRequireDefault(__webpack_require__(/*! ../codec/Tuple */ "../../node_modules/@polkadot/types/codec/Tuple.js"));

var _Raw = _interopRequireDefault(__webpack_require__(/*! ../codec/Raw */ "../../node_modules/@polkadot/types/codec/Raw.js"));

var _U = _interopRequireDefault(__webpack_require__(/*! ../primitive/U64 */ "../../node_modules/@polkadot/types/primitive/U64.js"));

var _constants = __webpack_require__(/*! ./constants */ "../../node_modules/@polkadot/types/extrinsic/constants.js");

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
function getTrailingZeros(period) {
  const binary = period.toString(2);
  let index = 0;

  while (binary[binary.length - 1 - index] === '0') {
    index++;
  }

  return index;
}
/**
 * @name ImmortalEra
 * @description
 * The ImmortalEra for an extrinsic
 */


class ImmortalEra extends _Raw.default {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  constructor(registry, value) {
    // For immortals, we always provide the known value (i.e. treated as a
    // constant no matter how it is constructed - it is a fixed structure)
    super(registry, _constants.IMMORTAL_ERA);
  }

}
/**
 * @name MortalEra
 * @description
 * The MortalEra for an extrinsic, indicating period and phase
 */


exports.ImmortalEra = ImmortalEra;

class MortalEra extends _Tuple.default {
  constructor(registry, value) {
    super(registry, {
      period: _U.default,
      phase: _U.default
    }, MortalEra._decodeMortalEra(registry, value));
  }
  /** @internal */


  static _decodeMortalEra(registry, value) {
    if ((0, _util.isHex)(value)) {
      return MortalEra._decodeMortalU8a(registry, (0, _util.hexToU8a)(value));
    } else if (Array.isArray(value)) {
      return MortalEra._decodeMortalU8a(registry, new Uint8Array(value));
    } else if ((0, _util.isU8a)(value)) {
      return MortalEra._decodeMortalU8a(registry, value);
    } else if ((0, _util.isObject)(value)) {
      return MortalEra._decodeMortalObject(registry, value);
    } else if (!value) {
      return [new _U.default(registry), new _U.default(registry)];
    }

    throw new Error('Invalid data passed to Mortal era');
  }
  /** @internal */


  static _decodeMortalObject(registry, value) {
    const {
      current,
      period
    } = value;
    let calPeriod = Math.pow(2, Math.ceil(Math.log2(period)));
    calPeriod = Math.min(Math.max(calPeriod, 4), 1 << 16);
    const phase = current % calPeriod;
    const quantizeFactor = Math.max(calPeriod >> 12, 1);
    const quantizedPhase = phase / quantizeFactor * quantizeFactor;
    return [new _U.default(registry, calPeriod), new _U.default(registry, quantizedPhase)];
  }
  /** @internal */


  static _decodeMortalU8a(registry, value) {
    if (value.length === 0) {
      return [new _U.default(registry), new _U.default(registry)];
    }

    const first = (0, _util.u8aToBn)(value.subarray(0, 1)).toNumber();
    const second = (0, _util.u8aToBn)(value.subarray(1, 2)).toNumber();
    const encoded = first + (second << 8);
    const period = 2 << encoded % (1 << 4);
    const quantizeFactor = Math.max(period >> 12, 1);
    const phase = (encoded >> 4) * quantizeFactor;
    (0, _util.assert)(period >= 4 && phase < period, 'Invalid data passed to Mortal era');
    return [new _U.default(registry, period), new _U.default(registry, phase)];
  }
  /**
   * @description Encoded length for mortals occupy 2 bytes, different from the actual Tuple since it is encoded. This is a shortcut fro `toU8a().length`
   */


  get encodedLength() {
    return 2;
  }
  /**
   * @description The period of this Mortal wraps as a [[U64]]
   */


  get period() {
    return this[0];
  }
  /**
   * @description The phase of this Mortal wraps as a [[U64]]
   */


  get phase() {
    return this[1];
  }
  /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */


  toHuman() {
    return {
      period: (0, _util.formatNumber)(this.period),
      phase: (0, _util.formatNumber)(this.phase)
    };
  }
  /**
   * @description Returns a JSON representation of the actual value
   */


  toJSON() {
    return this.toHex();
  }
  /**
   * @description Encodes the value as a Uint8Array as per the parity-codec specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   * Period and phase are encoded:
   *   - The period of validity from the block hash found in the signing material.
   *   - The phase in the period that this transaction's lifetime begins (and, importantly,
   *     implies which block hash is included in the signature material). If the `period` is
   *     greater than 1 << 12, then it will be a factor of the times greater than 1<<12 that
   *     `period` is.
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars


  toU8a(isBare) {
    const period = this.period.toNumber();
    const phase = this.phase.toNumber();
    const quantizeFactor = Math.max(period >> 12, 1);
    const trailingZeros = getTrailingZeros(period);
    const encoded = Math.min(15, Math.max(1, trailingZeros - 1)) + (phase / quantizeFactor << 4);
    const first = encoded >> 8;
    const second = encoded & 0xff;
    return new Uint8Array([second, first]);
  }
  /**
   * @description Get the block number of the start of the era whose properties this object describes that `current` belongs to.
   */


  birth(current) {
    // FIXME No toNumber() here
    return Math.floor((Math.max((0, _util.bnToBn)(current).toNumber(), this.phase.toNumber()) - this.phase.toNumber()) / this.period.toNumber()) * this.period.toNumber() + this.phase.toNumber();
  }
  /**
   * @description Get the block number of the first block at which the era has ended.
   */


  death(current) {
    // FIXME No toNumber() here
    return this.birth(current) + this.period.toNumber();
  }

}
/**
 * @name GenericExtrinsicEra
 * @description
 * The era for an extrinsic, indicating either a mortal or immortal extrinsic
 */


exports.MortalEra = MortalEra;

class ExtrinsicEra extends _Enum.default {
  constructor(registry, value) {
    super(registry, {
      ImmortalEra,
      MortalEra
    }, ExtrinsicEra._decodeExtrinsicEra(value));
  }
  /** @internal */
  // eslint-disable-next-line @typescript-eslint/ban-types


  static _decodeExtrinsicEra(value = new Uint8Array()) {
    if (value instanceof ExtrinsicEra) {
      return ExtrinsicEra._decodeExtrinsicEra(value.toU8a());
    } else if ((0, _util.isHex)(value)) {
      return ExtrinsicEra._decodeExtrinsicEra((0, _util.hexToU8a)(value));
    } else if (!value || (0, _util.isU8a)(value)) {
      return !(value === null || value === void 0 ? void 0 : value.length) || value[0] === 0 ? new Uint8Array([0]) : new Uint8Array([1, value[0], value[1]]);
    } else if ((0, _util.isObject)(value)) {
      // this is to de-serialize from JSON
      return value.MortalEra ? {
        MortalEra: value.MortalEra
      } : value.ImmortalEra ? {
        ImmortalEra: value.ImmortalEra
      } : {
        MortalEra: value
      };
    }

    throw new Error('Invalid data passed to Era');
  }
  /**
   * @description Override the encoded length method
   */


  get encodedLength() {
    return this.isImmortalEra ? this.asImmortalEra.encodedLength : this.asMortalEra.encodedLength;
  }
  /**
   * @description Returns the item as a [[ImmortalEra]]
   */


  get asImmortalEra() {
    (0, _util.assert)(this.isImmortalEra, `Cannot convert '${this.type}' via asImmortalEra`);
    return this.value;
  }
  /**
   * @description Returns the item as a [[MortalEra]]
   */


  get asMortalEra() {
    (0, _util.assert)(this.isMortalEra, `Cannot convert '${this.type}' via asMortalEra`);
    return this.value;
  }
  /**
   * @description `true` if Immortal
   */


  get isImmortalEra() {
    return this.index === 0;
  }
  /**
   * @description `true` if Mortal
   */


  get isMortalEra() {
    return this.index > 0;
  }
  /**
   * @description Encodes the value as a Uint8Array as per the parity-codec specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */


  toU8a(isBare) {
    return this.isMortalEra ? this.asMortalEra.toU8a(isBare) : this.asImmortalEra.toU8a(isBare);
  }

}

exports.default = ExtrinsicEra;

/***/ }),

/***/ "../../node_modules/@polkadot/types/extrinsic/ExtrinsicPayload.js":
/*!*****************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/extrinsic/ExtrinsicPayload.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _Base = _interopRequireDefault(__webpack_require__(/*! ../codec/Base */ "../../node_modules/@polkadot/types/codec/Base.js"));

var _constants = __webpack_require__(/*! ./constants */ "../../node_modules/@polkadot/types/extrinsic/constants.js");

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
const VERSIONS = ['ExtrinsicPayloadUnknown', // v0 is unknown
'ExtrinsicPayloadUnknown', 'ExtrinsicPayloadUnknown', 'ExtrinsicPayloadUnknown', 'ExtrinsicPayloadV4'];
/**
 * @name GenericExtrinsicPayload
 * @description
 * A signing payload for an [[Extrinsic]]. For the final encoding, it is variable length based
 * on the contents included
 */

class ExtrinsicPayload extends _Base.default {
  constructor(registry, value, {
    version
  } = {}) {
    super(registry, ExtrinsicPayload.decodeExtrinsicPayload(registry, value, version));
  }
  /** @internal */


  static decodeExtrinsicPayload(registry, value, version = _constants.DEFAULT_VERSION) {
    if (value instanceof ExtrinsicPayload) {
      return value._raw;
    }

    return registry.createType(VERSIONS[version] || VERSIONS[0], value, {
      version
    });
  }
  /**
   * @description The block [[Hash]] the signature applies to (mortal/immortal)
   */


  get blockHash() {
    return this._raw.blockHash;
  }
  /**
   * @description The [[ExtrinsicEra]]
   */


  get era() {
    return this._raw.era;
  }
  /**
   * @description The genesis block [[Hash]] the signature applies to
   */


  get genesisHash() {
    // NOTE only v3+
    return this._raw.genesisHash || this.registry.createType('Hash');
  }
  /**
   * @description The [[Raw]] contained in the payload
   */


  get method() {
    return this._raw.method;
  }
  /**
   * @description The [[Index]]
   */


  get nonce() {
    return this._raw.nonce;
  }
  /**
   * @description The specVersion as a [[u32]] for this payload
   */


  get specVersion() {
    // NOTE only v3+
    return this._raw.specVersion || this.registry.createType('u32');
  }
  /**
   * @description The [[Balance]]
   */


  get tip() {
    // NOTE from v2+
    return this._raw.tip || this.registry.createType('Compact<Balance>');
  }
  /**
   * @description The transaction version as a [[u32]] for this payload
   */


  get transactionVersion() {
    // NOTE only v4+
    return this._raw.transactionVersion || this.registry.createType('u32');
  }
  /**
   * @description Compares the value of the input to see if there is a match
   */


  eq(other) {
    return this._raw.eq(other);
  }
  /**
   * @description Sign the payload with the keypair
   */


  sign(signerPair) {
    const signature = this._raw.sign(signerPair); // This is extensible, so we could quite readily extend to send back extra
    // information, such as for instance the payload, i.e. `payload: this.toHex()`
    // For the case here we sign via the extrinsic, we ignore the return, so generally
    // this is applicable for external signing


    return {
      signature: (0, _util.u8aToHex)(signature)
    };
  }
  /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */


  toHuman(isExtended) {
    return this._raw.toHuman(isExtended);
  }
  /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */


  toJSON() {
    return this.toHex();
  }
  /**
   * @description Returns the string representation of the value
   */


  toString() {
    return this.toHex();
  }
  /**
   * @description Returns a serialized u8a form
   */


  toU8a(isBare) {
    // call our parent, with only the method stripped
    return super.toU8a(isBare ? {
      method: true
    } : false);
  }

}

exports.default = ExtrinsicPayload;

/***/ }),

/***/ "../../node_modules/@polkadot/types/extrinsic/ExtrinsicPayloadUnknown.js":
/*!************************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/extrinsic/ExtrinsicPayloadUnknown.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Struct = _interopRequireDefault(__webpack_require__(/*! ../codec/Struct */ "../../node_modules/@polkadot/types/codec/Struct.js"));

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name GenericExtrinsicPayloadUnknown
 * @description
 * A default handler for payloads where the version is not known (default throw)
 */
class ExtrinsicPayloadUnknown extends _Struct.default {
  constructor(registry, value, {
    version = 0
  } = {}) {
    super(registry, {});
    throw new Error(`Unsupported extrinsic payload version ${version}`);
  }

}

exports.default = ExtrinsicPayloadUnknown;

/***/ }),

/***/ "../../node_modules/@polkadot/types/extrinsic/ExtrinsicUnknown.js":
/*!*****************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/extrinsic/ExtrinsicUnknown.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Struct = _interopRequireDefault(__webpack_require__(/*! ../codec/Struct */ "../../node_modules/@polkadot/types/codec/Struct.js"));

var _constants = __webpack_require__(/*! ./constants */ "../../node_modules/@polkadot/types/extrinsic/constants.js");

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name GenericExtrinsicUnknown
 * @description
 * A default handler for extrinsics where the version is not known (default throw)
 */
class ExtrinsicUnknown extends _Struct.default {
  constructor(registry, value, {
    isSigned = false,
    version = 0
  } = {}) {
    super(registry, {});
    throw new Error(`Unsupported ${isSigned ? '' : 'un'}signed extrinsic version ${version & _constants.UNMASK_VERSION}`);
  }

}

exports.default = ExtrinsicUnknown;

/***/ }),

/***/ "../../node_modules/@polkadot/types/extrinsic/SignerPayload.js":
/*!**************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/extrinsic/SignerPayload.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _Struct = _interopRequireDefault(__webpack_require__(/*! ../codec/Struct */ "../../node_modules/@polkadot/types/codec/Struct.js"));

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// We explicitly cast the type here to get the actual TypeScript exports right
// We can ignore the properties, added via Struct.with
const _Payload = _Struct.default.with({
  address: 'Address',
  blockHash: 'Hash',
  blockNumber: 'BlockNumber',
  era: 'ExtrinsicEra',
  genesisHash: 'Hash',
  method: 'Call',
  nonce: 'Compact<Index>',
  runtimeVersion: 'RuntimeVersion',
  signedExtensions: 'Vec<Text>',
  tip: 'Compact<Balance>',
  version: 'u8'
});
/**
 * @name SignerPayload
 * @description
 * A generic signer payload that can be used for serialization between API and signer
 */


class SignerPayload extends _Payload {
  /**
   * @description Creates an representation of the structure as an ISignerPayload JSON
   */
  toPayload() {
    const {
      address,
      blockHash,
      blockNumber,
      era,
      genesisHash,
      method,
      nonce,
      runtimeVersion: {
        specVersion,
        transactionVersion
      },
      signedExtensions,
      tip,
      version
    } = this;
    return {
      address: address.toString(),
      blockHash: blockHash.toHex(),
      blockNumber: blockNumber.toHex(),
      era: era.toHex(),
      genesisHash: genesisHash.toHex(),
      method: method.toHex(),
      nonce: nonce.toHex(),
      signedExtensions: signedExtensions.map(e => e.toString()),
      specVersion: specVersion.toHex(),
      tip: tip.toHex(),
      transactionVersion: transactionVersion.toHex(),
      version: version.toNumber()
    };
  }
  /**
   * @description Creates a representation of the payload in raw Exrinsic form
   */


  toRaw() {
    const payload = this.toPayload(); // NOTE Explicitly pass the bare flag so the method is encoded un-prefixed (non-decodable, for signing only)

    const data = (0, _util.u8aToHex)(this.registry.createType('ExtrinsicPayload', payload, {
      version: payload.version
    }).toU8a({
      method: true
    }));
    return {
      address: payload.address,
      data,
      type: 'payload'
    };
  }

}

exports.default = SignerPayload;

/***/ }),

/***/ "../../node_modules/@polkadot/types/extrinsic/constants.js":
/*!**********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/extrinsic/constants.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UNMASK_VERSION = exports.IMMORTAL_ERA = exports.DEFAULT_VERSION = exports.EMPTY_U8A = exports.BIT_UNSIGNED = exports.BIT_SIGNED = void 0;
// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
const BIT_SIGNED = 0b10000000;
exports.BIT_SIGNED = BIT_SIGNED;
const BIT_UNSIGNED = 0;
exports.BIT_UNSIGNED = BIT_UNSIGNED;
const EMPTY_U8A = new Uint8Array();
exports.EMPTY_U8A = EMPTY_U8A;
const DEFAULT_VERSION = 4;
exports.DEFAULT_VERSION = DEFAULT_VERSION;
const IMMORTAL_ERA = new Uint8Array([0]);
exports.IMMORTAL_ERA = IMMORTAL_ERA;
const UNMASK_VERSION = 0b01111111;
exports.UNMASK_VERSION = UNMASK_VERSION;

/***/ }),

/***/ "../../node_modules/@polkadot/types/extrinsic/index.js":
/*!******************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/extrinsic/index.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "../../node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  GenericExtrinsic: true,
  GenericExtrinsicEra: true,
  GenericMortalEra: true,
  GenericImmortalEra: true,
  GenericExtrinsicPayload: true,
  GenericExtrinsicPayloadUnknown: true,
  GenericExtrinsicUnknown: true,
  GenericSignerPayload: true
};
Object.defineProperty(exports, "GenericExtrinsic", {
  enumerable: true,
  get: function () {
    return _Extrinsic.default;
  }
});
Object.defineProperty(exports, "GenericExtrinsicEra", {
  enumerable: true,
  get: function () {
    return _ExtrinsicEra.default;
  }
});
Object.defineProperty(exports, "GenericMortalEra", {
  enumerable: true,
  get: function () {
    return _ExtrinsicEra.MortalEra;
  }
});
Object.defineProperty(exports, "GenericImmortalEra", {
  enumerable: true,
  get: function () {
    return _ExtrinsicEra.ImmortalEra;
  }
});
Object.defineProperty(exports, "GenericExtrinsicPayload", {
  enumerable: true,
  get: function () {
    return _ExtrinsicPayload.default;
  }
});
Object.defineProperty(exports, "GenericExtrinsicPayloadUnknown", {
  enumerable: true,
  get: function () {
    return _ExtrinsicPayloadUnknown.default;
  }
});
Object.defineProperty(exports, "GenericExtrinsicUnknown", {
  enumerable: true,
  get: function () {
    return _ExtrinsicUnknown.default;
  }
});
Object.defineProperty(exports, "GenericSignerPayload", {
  enumerable: true,
  get: function () {
    return _SignerPayload.default;
  }
});

var _Extrinsic = _interopRequireDefault(__webpack_require__(/*! ./Extrinsic */ "../../node_modules/@polkadot/types/extrinsic/Extrinsic.js"));

var _ExtrinsicEra = _interopRequireWildcard(__webpack_require__(/*! ./ExtrinsicEra */ "../../node_modules/@polkadot/types/extrinsic/ExtrinsicEra.js"));

var _ExtrinsicPayload = _interopRequireDefault(__webpack_require__(/*! ./ExtrinsicPayload */ "../../node_modules/@polkadot/types/extrinsic/ExtrinsicPayload.js"));

var _ExtrinsicPayloadUnknown = _interopRequireDefault(__webpack_require__(/*! ./ExtrinsicPayloadUnknown */ "../../node_modules/@polkadot/types/extrinsic/ExtrinsicPayloadUnknown.js"));

var _ExtrinsicUnknown = _interopRequireDefault(__webpack_require__(/*! ./ExtrinsicUnknown */ "../../node_modules/@polkadot/types/extrinsic/ExtrinsicUnknown.js"));

var _SignerPayload = _interopRequireDefault(__webpack_require__(/*! ./SignerPayload */ "../../node_modules/@polkadot/types/extrinsic/SignerPayload.js"));

var _v = __webpack_require__(/*! ./v4 */ "../../node_modules/@polkadot/types/extrinsic/v4/index.js");

Object.keys(_v).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _v[key];
    }
  });
});

/***/ }),

/***/ "../../node_modules/@polkadot/types/extrinsic/signedExtensions/emptyCheck.js":
/*!****************************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/extrinsic/signedExtensions/emptyCheck.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _default = {
  extra: {},
  types: {}
};
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types/extrinsic/signedExtensions/index.js":
/*!***********************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/extrinsic/signedExtensions/index.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.expandExtensionTypes = expandExtensionTypes;
exports.findUnknownExtensions = findUnknownExtensions;
exports.defaultExtensions = exports.allExtensions = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js"));

var _polkadot = _interopRequireDefault(__webpack_require__(/*! ./polkadot */ "../../node_modules/@polkadot/types/extrinsic/signedExtensions/polkadot.js"));

var _substrate = _interopRequireDefault(__webpack_require__(/*! ./substrate */ "../../node_modules/@polkadot/types/extrinsic/signedExtensions/substrate.js"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// A mapping of the known signed extensions to the extra fields that they contain. Unlike in the actual extensions,
// we define the extra fields not as a Tuple, but rather as a struct so they can be named. These will be expanded
// into the various fields when added to the payload (we only support V4 onwards with these, V3 and earlier are
// deemded fixed and non-changeable)
const allExtensions = _objectSpread(_objectSpread({}, _substrate.default), _polkadot.default); // the v4 signed extensions (the order is important here, as applied by default)


exports.allExtensions = allExtensions;
const defaultExtensions = ['CheckVersion', 'CheckGenesis', 'CheckEra', 'CheckNonce', 'CheckWeight', 'ChargeTransactionPayment', 'CheckBlockGasLimit'];
exports.defaultExtensions = defaultExtensions;

function findUnknownExtensions(extensions) {
  const names = Object.keys(allExtensions);
  return extensions.filter(key => !names.includes(key));
}

function expandExtensionTypes(extensions, type) {
  return extensions.map(key => allExtensions[key]).filter(info => !!info).reduce((result, info) => _objectSpread(_objectSpread({}, result), info[type]), {});
}

/***/ }),

/***/ "../../node_modules/@polkadot/types/extrinsic/signedExtensions/polkadot.js":
/*!**************************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/extrinsic/signedExtensions/polkadot.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _emptyCheck = _interopRequireDefault(__webpack_require__(/*! ./emptyCheck */ "../../node_modules/@polkadot/types/extrinsic/signedExtensions/emptyCheck.js"));

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _default = {
  LimitParathreadCommits: _emptyCheck.default,
  OnlyStakingAndClaims: _emptyCheck.default,
  PrevalidateAttests: _emptyCheck.default,
  RestrictFunctionality: _emptyCheck.default,
  TransactionCallFilter: _emptyCheck.default,
  ValidateDoubleVoteReports: _emptyCheck.default
};
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types/extrinsic/signedExtensions/substrate.js":
/*!***************************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/extrinsic/signedExtensions/substrate.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _emptyCheck = _interopRequireDefault(__webpack_require__(/*! ./emptyCheck */ "../../node_modules/@polkadot/types/extrinsic/signedExtensions/emptyCheck.js"));

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
const CheckMortality = {
  extra: {
    blockHash: 'Hash'
  },
  types: {
    era: 'ExtrinsicEra'
  }
};
var _default = {
  ChargeTransactionPayment: {
    extra: {},
    types: {
      tip: 'Compact<Balance>'
    }
  },
  CheckBlockGasLimit: _emptyCheck.default,
  CheckEra: CheckMortality,
  CheckGenesis: {
    extra: {
      genesisHash: 'Hash'
    },
    types: {}
  },
  CheckMortality,
  CheckNonce: {
    extra: {},
    types: {
      nonce: 'Compact<Index>'
    }
  },
  CheckSpecVersion: {
    extra: {
      specVersion: 'u32'
    },
    types: {}
  },
  CheckTxVersion: {
    extra: {
      transactionVersion: 'u32'
    },
    types: {}
  },
  CheckVersion: {
    extra: {
      specVersion: 'u32'
    },
    types: {}
  },
  CheckWeight: _emptyCheck.default,
  LockStakingStatus: _emptyCheck.default,
  ValidateEquivocationReport: _emptyCheck.default
};
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types/extrinsic/util.js":
/*!*****************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/extrinsic/util.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sign = sign;

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// a helper function for both types of payloads, Raw and metadata-known
function sign(registry, signerPair, u8a, options) {
  const encoded = u8a.length > 256 ? registry.hash(u8a) : u8a;
  return signerPair.sign(encoded, options);
}

/***/ }),

/***/ "../../node_modules/@polkadot/types/extrinsic/v4/Extrinsic.js":
/*!*************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/extrinsic/v4/Extrinsic.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.EXTRINSIC_VERSION = void 0;

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _Struct = _interopRequireDefault(__webpack_require__(/*! ../../codec/Struct */ "../../node_modules/@polkadot/types/codec/Struct.js"));

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
const EXTRINSIC_VERSION = 4;
exports.EXTRINSIC_VERSION = EXTRINSIC_VERSION;

/**
 * @name GenericExtrinsicV4
 * @description
 * The third generation of compact extrinsics
 */
class ExtrinsicV4 extends _Struct.default {
  constructor(registry, value, {
    isSigned
  } = {}) {
    super(registry, {
      signature: 'ExtrinsicSignatureV4',
      // eslint-disable-next-line sort-keys
      method: 'Call'
    }, ExtrinsicV4.decodeExtrinsic(registry, value, isSigned));
  }
  /** @internal */


  static decodeExtrinsic(registry, value, isSigned = false) {
    if (value instanceof ExtrinsicV4) {
      return value;
    } else if (value instanceof registry.createClass('Call')) {
      return {
        method: value
      };
    } else if ((0, _util.isU8a)(value)) {
      // here we decode manually since we need to pull through the version information
      const signature = registry.createType('ExtrinsicSignatureV4', value, {
        isSigned
      });
      const method = registry.createType('Call', value.subarray(signature.encodedLength));
      return {
        method,
        signature
      };
    }

    return value || {};
  }
  /**
   * @description The length of the value when encoded as a Uint8Array
   */


  get encodedLength() {
    return this.toU8a().length;
  }
  /**
   * @description The [[Call]] this extrinsic wraps
   */


  get method() {
    return this.get('method');
  }
  /**
   * @description The [[ExtrinsicSignatureV4]]
   */


  get signature() {
    return this.get('signature');
  }
  /**
   * @description The version for the signature
   */


  get version() {
    return EXTRINSIC_VERSION;
  }
  /**
   * @description Add an [[ExtrinsicSignatureV4]] to the extrinsic (already generated)
   */


  addSignature(signer, signature, payload) {
    this.signature.addSignature(signer, signature, payload);
    return this;
  }
  /**
   * @description Sign the extrinsic with a specific keypair
   */


  sign(account, options) {
    this.signature.sign(this.method, account, options);
    return this;
  }
  /**
   * @describe Adds a fake signature to the extrinsic
   */


  signFake(signer, options) {
    this.signature.signFake(this.method, signer, options);
    return this;
  }

}

exports.default = ExtrinsicV4;

/***/ }),

/***/ "../../node_modules/@polkadot/types/extrinsic/v4/ExtrinsicPayload.js":
/*!********************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/extrinsic/v4/ExtrinsicPayload.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js"));

var _Struct = _interopRequireDefault(__webpack_require__(/*! ../../codec/Struct */ "../../node_modules/@polkadot/types/codec/Struct.js"));

var _util = __webpack_require__(/*! ../util */ "../../node_modules/@polkadot/types/extrinsic/util.js");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * @name GenericExtrinsicPayloadV4
 * @description
 * A signing payload for an [[Extrinsic]]. For the final encoding, it is variable length based
 * on the contents included
 */
class ExtrinsicPayloadV4 extends _Struct.default {
  constructor(registry, value) {
    super(registry, _objectSpread(_objectSpread({
      method: 'Bytes'
    }, registry.getSignedExtensionTypes()), registry.getSignedExtensionExtra()), value);
  }
  /**
   * @description The block [[Hash]] the signature applies to (mortal/immortal)
   */


  get blockHash() {
    return this.get('blockHash');
  }
  /**
   * @description The [[ExtrinsicEra]]
   */


  get era() {
    return this.get('era');
  }
  /**
   * @description The genesis [[Hash]] the signature applies to (mortal/immortal)
   */


  get genesisHash() {
    return this.get('genesisHash');
  }
  /**
   * @description The [[Bytes]] contained in the payload
   */


  get method() {
    return this.get('method');
  }
  /**
   * @description The [[Index]]
   */


  get nonce() {
    return this.get('nonce');
  }
  /**
   * @description The specVersion for this signature
   */


  get specVersion() {
    return this.get('specVersion');
  }
  /**
   * @description The tip [[Balance]]
   */


  get tip() {
    return this.get('tip');
  }
  /**
   * @description The transactionVersion for this signature
   */


  get transactionVersion() {
    return this.get('transactionVersion');
  }
  /**
   * @description Sign the payload with the keypair
   */


  sign(signerPair) {
    // NOTE The `toU8a({ method: true })` argument is absolutely critical - we don't want the method (Bytes)
    // to have the length prefix included. This means that the data-as-signed is un-decodable,
    // but is also doesn't need the extra information, only the pure data (and is not decoded)
    // ... The same applies to V1..V3, if we have a V5, carry move this comment to latest
    return (0, _util.sign)(this.registry, signerPair, this.toU8a({
      method: true
    }), {
      withType: true
    });
  }

}

exports.default = ExtrinsicPayloadV4;

/***/ }),

/***/ "../../node_modules/@polkadot/types/extrinsic/v4/ExtrinsicSignature.js":
/*!**********************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/extrinsic/v4/ExtrinsicSignature.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js"));

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _Struct = _interopRequireDefault(__webpack_require__(/*! ../../codec/Struct */ "../../node_modules/@polkadot/types/codec/Struct.js"));

var _constants = __webpack_require__(/*! ../constants */ "../../node_modules/@polkadot/types/extrinsic/constants.js");

var _ExtrinsicPayload = _interopRequireDefault(__webpack_require__(/*! ./ExtrinsicPayload */ "../../node_modules/@polkadot/types/extrinsic/v4/ExtrinsicPayload.js"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * @name GenericExtrinsicSignatureV4
 * @description
 * A container for the [[Signature]] associated with a specific [[Extrinsic]]
 */
class ExtrinsicSignatureV4 extends _Struct.default {
  constructor(registry, value, {
    isSigned
  } = {}) {
    super(registry, _objectSpread({
      signer: 'Address',
      // eslint-disable-next-line sort-keys
      signature: 'MultiSignature'
    }, registry.getSignedExtensionTypes()), ExtrinsicSignatureV4.decodeExtrinsicSignature(value, isSigned));
  }
  /** @internal */


  static decodeExtrinsicSignature(value, isSigned = false) {
    if (!value) {
      return _constants.EMPTY_U8A;
    } else if (value instanceof ExtrinsicSignatureV4) {
      return value;
    }

    return isSigned ? value : _constants.EMPTY_U8A;
  }
  /**
   * @description The length of the value when encoded as a Uint8Array
   */


  get encodedLength() {
    return this.isSigned ? super.encodedLength : 0;
  }
  /**
   * @description `true` if the signature is valid
   */


  get isSigned() {
    return !this.signature.isEmpty;
  }
  /**
   * @description The [[ExtrinsicEra]] (mortal or immortal) this signature applies to
   */


  get era() {
    return this.get('era');
  }
  /**
   * @description The [[Index]] for the signature
   */


  get nonce() {
    return this.get('nonce');
  }
  /**
   * @description The actual [[EcdsaSignature]], [[Ed25519Signature]] or [[Sr25519Signature]]
   */


  get signature() {
    return this.multiSignature.value;
  }
  /**
   * @description The raw [[MultiSignature]]
   */


  get multiSignature() {
    return this.get('signature');
  }
  /**
   * @description The [[Address]] that signed
   */


  get signer() {
    return this.get('signer');
  }
  /**
   * @description The [[Balance]] tip
   */


  get tip() {
    return this.get('tip');
  }

  _injectSignature(signer, signature, {
    era,
    nonce,
    tip
  }) {
    this.set('era', era);
    this.set('nonce', nonce);
    this.set('signer', signer);
    this.set('signature', signature);
    this.set('tip', tip);
    return this;
  }
  /**
   * @description Adds a raw signature
   */


  addSignature(signer, signature, payload) {
    return this._injectSignature(this.registry.createType('Address', signer), this.registry.createType('MultiSignature', signature), new _ExtrinsicPayload.default(this.registry, payload));
  }
  /**
   * @description Creates a payload from the supplied options
   */


  createPayload(method, {
    blockHash,
    era,
    genesisHash,
    nonce,
    runtimeVersion: {
      specVersion,
      transactionVersion
    },
    tip
  }) {
    return new _ExtrinsicPayload.default(this.registry, {
      blockHash,
      era: era || _constants.IMMORTAL_ERA,
      genesisHash,
      method: method.toHex(),
      nonce,
      specVersion,
      tip: tip || 0,
      transactionVersion: transactionVersion || 0
    });
  }
  /**
   * @description Generate a payload and applies the signature from a keypair
   */


  sign(method, account, options) {
    const signer = this.registry.createType('Address', account.addressRaw);
    const payload = this.createPayload(method, options);
    const signature = this.registry.createType('MultiSignature', payload.sign(account));
    return this._injectSignature(signer, signature, payload);
  }
  /**
   * @description Generate a payload and applies a fake signature
   */


  signFake(method, address, options) {
    const signer = this.registry.createType('Address', address);
    const payload = this.createPayload(method, options);
    const signature = this.registry.createType('MultiSignature', (0, _util.u8aConcat)(new Uint8Array([1]), new Uint8Array(64).fill(0x42)));
    return this._injectSignature(signer, signature, payload);
  }
  /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */


  toU8a(isBare) {
    return this.isSigned ? super.toU8a(isBare) : _constants.EMPTY_U8A;
  }

}

exports.default = ExtrinsicSignatureV4;

/***/ }),

/***/ "../../node_modules/@polkadot/types/extrinsic/v4/index.js":
/*!*********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/extrinsic/v4/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "GenericExtrinsicV4", {
  enumerable: true,
  get: function () {
    return _Extrinsic.default;
  }
});
Object.defineProperty(exports, "GenericExtrinsicPayloadV4", {
  enumerable: true,
  get: function () {
    return _ExtrinsicPayload.default;
  }
});
Object.defineProperty(exports, "GenericExtrinsicSignatureV4", {
  enumerable: true,
  get: function () {
    return _ExtrinsicSignature.default;
  }
});

var _Extrinsic = _interopRequireDefault(__webpack_require__(/*! ./Extrinsic */ "../../node_modules/@polkadot/types/extrinsic/v4/Extrinsic.js"));

var _ExtrinsicPayload = _interopRequireDefault(__webpack_require__(/*! ./ExtrinsicPayload */ "../../node_modules/@polkadot/types/extrinsic/v4/ExtrinsicPayload.js"));

var _ExtrinsicSignature = _interopRequireDefault(__webpack_require__(/*! ./ExtrinsicSignature */ "../../node_modules/@polkadot/types/extrinsic/v4/ExtrinsicSignature.js"));

/***/ }),

/***/ "../../node_modules/@polkadot/types/generic/AccountId.js":
/*!********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/generic/AccountId.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _utilCrypto = __webpack_require__(/*! @polkadot/util-crypto */ "../../node_modules/@polkadot/util-crypto/index.js");

var _U8aFixed = _interopRequireDefault(__webpack_require__(/*! ../codec/U8aFixed */ "../../node_modules/@polkadot/types/codec/U8aFixed.js"));

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0

/** @internal */
function decodeAccountId(value) {
  if (!value) {
    return new Uint8Array();
  } else if ((0, _util.isU8a)(value) || Array.isArray(value)) {
    return (0, _util.u8aToU8a)(value);
  } else if ((0, _util.isHex)(value)) {
    return (0, _util.hexToU8a)(value.toString());
  } else if ((0, _util.isString)(value)) {
    return (0, _utilCrypto.decodeAddress)(value.toString());
  }

  throw new Error('Unknown type passed to AccountId constructor');
}
/**
 * @name AccountId
 * @description
 * A wrapper around an AccountId/PublicKey representation. Since we are dealing with
 * underlying PublicKeys (32 bytes in length), we extend from U8aFixed which is
 * just a Uint8Array wrapper with a fixed length.
 */


class AccountId extends _U8aFixed.default {
  constructor(registry, value) {
    const decoded = decodeAccountId(value); // Part of stream containing >= 32 bytes or a all empty (defaults)

    (0, _util.assert)(decoded.length >= 32 || !decoded.some(b => b), `Invalid AccountId provided, expected 32 bytes, found ${decoded.length}`);
    super(registry, decoded, 256);
  }

  static encode(value, ss58Format) {
    return (0, _utilCrypto.encodeAddress)(value, ss58Format);
  }
  /**
   * @description Compares the value of the input to see if there is a match
   */


  eq(other) {
    return super.eq(decodeAccountId(other));
  }
  /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */


  toHuman() {
    return this.toJSON();
  }
  /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */


  toJSON() {
    return this.toString();
  }
  /**
   * @description Returns the string representation of the value
   */


  toString() {
    return AccountId.encode(this, this.registry.chainSS58);
  }
  /**
   * @description Returns the base runtime type name for this instance
   */


  toRawType() {
    return 'AccountId';
  }

}

exports.default = AccountId;

/***/ }),

/***/ "../../node_modules/@polkadot/types/generic/AccountIndex.js":
/*!***********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/generic/AccountIndex.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.ENUMSET_SIZE = void 0;

var _bn = _interopRequireDefault(__webpack_require__(/*! bn.js */ "../../node_modules/bn.js/lib/bn.js"));

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _utilCrypto = __webpack_require__(/*! @polkadot/util-crypto */ "../../node_modules/@polkadot/util-crypto/index.js");

var _U = _interopRequireDefault(__webpack_require__(/*! ../primitive/U32 */ "../../node_modules/@polkadot/types/primitive/U32.js"));

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
const ENUMSET_SIZE = new _bn.default(64);
exports.ENUMSET_SIZE = ENUMSET_SIZE;
const PREFIX_1BYTE = 0xef;
const PREFIX_2BYTE = 0xfc;
const PREFIX_4BYTE = 0xfd;
const PREFIX_8BYTE = 0xfe;
const MAX_1BYTE = new _bn.default(PREFIX_1BYTE);
const MAX_2BYTE = new _bn.default(1).shln(16);
const MAX_4BYTE = new _bn.default(1).shln(32);
/** @internal */

function decodeAccountIndex(value) {
  // eslint-disable-next-line @typescript-eslint/no-use-before-define
  if (value instanceof AccountIndex) {
    // `value.toBn()` on AccountIndex returns a pure BN (i.e. not an
    // AccountIndex), which has the initial `toString()` implementation.
    return value.toBn();
  } else if ((0, _util.isBn)(value) || (0, _util.isNumber)(value) || (0, _util.isHex)(value) || (0, _util.isU8a)(value) || (0, _util.isBigInt)(value)) {
    return value;
  }

  return decodeAccountIndex((0, _utilCrypto.decodeAddress)(value));
}
/**
 * @name AccountIndex
 * @description
 * A wrapper around an AccountIndex, which is a shortened, variable-length encoding
 * for an Account. We extends from [[U32]] to provide the number-like properties.
 */


class AccountIndex extends _U.default {
  constructor(registry, value = new _bn.default(0)) {
    super(registry, decodeAccountIndex(value));
  }

  static calcLength(_value) {
    const value = (0, _util.bnToBn)(_value);

    if (value.lte(MAX_1BYTE)) {
      return 1;
    } else if (value.lt(MAX_2BYTE)) {
      return 2;
    } else if (value.lt(MAX_4BYTE)) {
      return 4;
    }

    return 8;
  }

  static readLength(input) {
    const first = input[0];

    if (first === PREFIX_2BYTE) {
      return [1, 2];
    } else if (first === PREFIX_4BYTE) {
      return [1, 4];
    } else if (first === PREFIX_8BYTE) {
      return [1, 8];
    }

    return [0, 1];
  }

  static writeLength(input) {
    switch (input.length) {
      case 2:
        return new Uint8Array([PREFIX_2BYTE]);

      case 4:
        return new Uint8Array([PREFIX_4BYTE]);

      case 8:
        return new Uint8Array([PREFIX_8BYTE]);

      default:
        return new Uint8Array([]);
    }
  }
  /**
   * @description Compares the value of the input to see if there is a match
   */


  eq(other) {
    // shortcut for BN or Number, don't create an object
    if ((0, _util.isBn)(other) || (0, _util.isNumber)(other)) {
      return super.eq(other);
    } // convert and compare


    return super.eq(this.registry.createType('AccountIndex', other));
  }
  /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */


  toHuman() {
    return this.toJSON();
  }
  /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */


  toJSON() {
    return this.toString();
  }
  /**
   * @description Returns the string representation of the value
   */


  toString() {
    const length = AccountIndex.calcLength(this);
    return (0, _utilCrypto.encodeAddress)(this.toU8a().subarray(0, length), this.registry.chainSS58);
  }
  /**
   * @description Returns the base runtime type name for this instance
   */


  toRawType() {
    return 'AccountIndex';
  }

}

exports.default = AccountIndex;

/***/ }),

/***/ "../../node_modules/@polkadot/types/generic/Block.js":
/*!****************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/generic/Block.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Struct = _interopRequireDefault(__webpack_require__(/*! ../codec/Struct */ "../../node_modules/@polkadot/types/codec/Struct.js"));

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name Block
 * @description
 * A block encoded with header and extrinsics
 */
class Block extends _Struct.default {
  constructor(registry, value) {
    super(registry, {
      header: 'Header',
      // eslint-disable-next-line sort-keys
      extrinsics: 'Vec<Extrinsic>'
    }, value);
  }
  /**
   * @description Encodes a content [[Hash]] for the block
   */


  get contentHash() {
    return this.registry.createType('H256', this.registry.hash(this.toU8a()));
  }
  /**
   * @description The [[Extrinsic]] contained in the block
   */


  get extrinsics() {
    return this.get('extrinsics');
  }
  /**
   * @description Block/header [[Hash]]
   */


  get hash() {
    return this.header.hash;
  }
  /**
   * @description The [[Header]] of the block
   */


  get header() {
    return this.get('header');
  }

}

exports.default = Block;

/***/ }),

/***/ "../../node_modules/@polkadot/types/generic/Call.js":
/*!***************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/generic/Call.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.CallIndex = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js"));

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _create = __webpack_require__(/*! ../create */ "../../node_modules/@polkadot/types/create/index.js");

var _Struct = _interopRequireDefault(__webpack_require__(/*! ../codec/Struct */ "../../node_modules/@polkadot/types/codec/Struct.js"));

var _U8aFixed = _interopRequireDefault(__webpack_require__(/*! ../codec/U8aFixed */ "../../node_modules/@polkadot/types/codec/U8aFixed.js"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * Get a mapping of `argument name -> argument type` for the function, from
 * its metadata.
 *
 * @param meta - The function metadata used to get the definition.
 * @internal
 */
function getArgsDef(registry, meta) {
  // eslint-disable-next-line @typescript-eslint/no-use-before-define
  return Call.filterOrigin(meta).reduce((result, {
    name,
    type
  }) => {
    const Type = (0, _create.getTypeClass)(registry, (0, _create.getTypeDef)(type.toString()));
    result[name.toString()] = Type;
    return result;
  }, {});
}
/** @internal */


function decodeCallViaObject(registry, value, _meta) {
  // we only pass args/methodsIndex out
  const {
    args,
    callIndex
  } = value; // Get the correct lookupIndex
  // eslint-disable-next-line @typescript-eslint/no-use-before-define

  const lookupIndex = callIndex instanceof CallIndex ? callIndex.toU8a() : callIndex; // Find metadata with callIndex

  const meta = _meta || registry.findMetaCall(lookupIndex).meta;

  return {
    args,
    argsDef: getArgsDef(registry, meta),
    callIndex,
    meta
  };
}
/** @internal */


function decodeCallViaU8a(registry, value, _meta) {
  // We need 2 bytes for the callIndex
  const callIndex = new Uint8Array(2);
  callIndex.set(value.subarray(0, 2), 0); // Find metadata with callIndex

  const meta = _meta || registry.findMetaCall(callIndex).meta;

  return {
    args: value.subarray(2),
    argsDef: getArgsDef(registry, meta),
    callIndex,
    meta
  };
}
/**
 * Decode input to pass into constructor.
 *
 * @param value - Value to decode, one of:
 * - hex
 * - Uint8Array
 * - {@see DecodeMethodInput}
 * @param _meta - Metadata to use, so that `injectMethods` lookup is not
 * necessary.
 * @internal
 */


function decodeCall(registry, value = new Uint8Array(), _meta) {
  if ((0, _util.isHex)(value) || (0, _util.isU8a)(value)) {
    return decodeCallViaU8a(registry, (0, _util.u8aToU8a)(value), _meta);
  } else if ((0, _util.isObject)(value) && value.callIndex && value.args) {
    return decodeCallViaObject(registry, value, _meta);
  }

  throw new Error(`Call: Cannot decode value '${value}' of type ${typeof value}`);
}
/**
 * @name CallIndex
 * @description
 * A wrapper around the `[sectionIndex, methodIndex]` value that uniquely identifies a method
 */


class CallIndex extends _U8aFixed.default {
  constructor(registry, value) {
    super(registry, value, 16);
  }

}
/**
 * @name Call
 * @description
 * Extrinsic function descriptor, as defined in
 * {@link https://github.com/paritytech/wiki/blob/master/Extrinsic.md#the-extrinsic-format-for-node}.
 */


exports.CallIndex = CallIndex;

class Call extends _Struct.default {
  constructor(registry, value, meta) {
    const decoded = decodeCall(registry, value, meta);
    super(registry, {
      callIndex: CallIndex,
      // eslint-disable-next-line sort-keys
      args: _Struct.default.with(decoded.argsDef)
    }, decoded);
    this._meta = void 0;
    this._meta = decoded.meta;
  } // If the extrinsic function has an argument of type `Origin`, we ignore it


  static filterOrigin(meta) {
    // FIXME should be `arg.type !== Origin`, but doesn't work...
    return meta ? meta.args.filter(({
      type
    }) => type.toString() !== 'Origin') : [];
  }
  /**
   * @description The arguments for the function call
   */


  get args() {
    // FIXME This should return a Struct instead of an Array
    return [...this.get('args').values()];
  }
  /**
   * @description The argument definitions
   */


  get argsDef() {
    return getArgsDef(this.registry, this.meta);
  }
  /**
   * @description The encoded `[sectionIndex, methodIndex]` identifier
   */


  get callIndex() {
    return this.get('callIndex').toU8a();
  }
  /**
   * @description The encoded data
   */


  get data() {
    return this.get('args').toU8a();
  }
  /**
   * @description `true` if the `Origin` type is on the method (extrinsic method)
   */


  get hasOrigin() {
    const firstArg = this.meta.args[0];
    return !!firstArg && firstArg.type.toString() === 'Origin';
  }
  /**
   * @description The [[FunctionMetadata]]
   */


  get meta() {
    return this._meta;
  }
  /**
   * @description Returns the name of the method
   */


  get methodName() {
    return this.registry.findMetaCall(this.callIndex).method;
  }
  /**
   * @description Returns the name of the method
   */


  get method() {
    return this.methodName;
  }
  /**
   * @description Returns the module containing the method
   */


  get sectionName() {
    return this.registry.findMetaCall(this.callIndex).section;
  }
  /**
   * @description Returns the module containing the method
   */


  get section() {
    return this.sectionName;
  }
  /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */


  toHuman(isExpanded) {
    var _call, _call2;

    let call;

    try {
      call = this.registry.findMetaCall(this.callIndex);
    } catch (error) {// swallow
    }

    return _objectSpread({
      args: this.args.map(arg => arg.toHuman(isExpanded)),
      // args: this.args.map((arg, index) => call
      //   ? { [call.meta.args[index].name.toString()]: arg.toHuman(isExpanded) }
      //   : arg.toHuman(isExpanded)
      // ),
      // callIndex: u8aToHex(this.callIndex),
      method: (_call = call) === null || _call === void 0 ? void 0 : _call.method,
      section: (_call2 = call) === null || _call2 === void 0 ? void 0 : _call2.section
    }, isExpanded && call ? {
      documentation: call.meta.documentation.map(d => d.toString())
    } : {});
  }
  /**
   * @description Returns the base runtime type name for this instance
   */


  toRawType() {
    return 'Call';
  }

}

exports.default = Call;

/***/ }),

/***/ "../../node_modules/@polkadot/types/generic/ConsensusEngineId.js":
/*!****************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/generic/ConsensusEngineId.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.CID_POW = exports.CID_GRPA = exports.CID_BABE = exports.CID_AURA = void 0;

var _bn = _interopRequireDefault(__webpack_require__(/*! bn.js */ "../../node_modules/bn.js/lib/bn.js"));

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _U = _interopRequireDefault(__webpack_require__(/*! ../primitive/U32 */ "../../node_modules/@polkadot/types/primitive/U32.js"));

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// there are all reversed since it is actually encoded as u32, LE,
// this means that FRNK has the bytes as KNRF
const CID_AURA = 0x61727561; // 'aura'

exports.CID_AURA = CID_AURA;
const CID_BABE = 0x45424142; // 'BABE'

exports.CID_BABE = CID_BABE;
const CID_GRPA = 0x4b4e5246; // 'FRNK' (don't ask, used to be afg1)

exports.CID_GRPA = CID_GRPA;
const CID_POW = 0x5f776f70; // 'pow_'

exports.CID_POW = CID_POW;

/**
 * @name ConsensusEngineId
 * @description
 * A 4-byte identifier (actually a [u8; 4]) identifying the engine, e.g. for Aura it would be [b'a', b'u', b'r', b'a']
 */
class ConsensusEngineId extends _U.default {
  static idToString(input) {
    return (0, _util.bnToBn)(input).toArray('le').map(code => String.fromCharCode(code)).join('');
  }

  static stringToId(input) {
    return input.split('').reverse().reduce((result, char) => result * 256 + char.charCodeAt(0), 0);
  }
  /**
   * @description `true` if the engine matches aura
   */


  get isAura() {
    return this.eq(CID_AURA);
  }
  /**
   * @description `true` is the engine matches babe
   */


  get isBabe() {
    return this.eq(CID_BABE);
  }
  /**
   * @description `true` is the engine matches grandpa
   */


  get isGrandpa() {
    return this.eq(CID_GRPA);
  }
  /**
   * @description `true` is the engine matches pow
   */


  get isPow() {
    return this.eq(CID_POW);
  }

  _getAuraAuthor(bytes, sessionValidators) {
    return sessionValidators[this.registry.createType('RawAuraPreDigest', bytes.toU8a(true)).slotNumber.mod(new _bn.default(sessionValidators.length)).toNumber()];
  }

  _getBabeAuthor(bytes, sessionValidators) {
    const digest = this.registry.createType('RawBabePreDigestCompat', bytes.toU8a(true));
    return sessionValidators[digest.value.toNumber()];
  }

  _getPowAuthor(bytes) {
    return this.registry.createType('AccountId', bytes);
  }
  /**
   * @description From the input bytes, decode into an author
   */


  extractAuthor(bytes, sessionValidators) {
    if (sessionValidators === null || sessionValidators === void 0 ? void 0 : sessionValidators.length) {
      if (this.isAura) {
        return this._getAuraAuthor(bytes, sessionValidators);
      } else if (this.isBabe) {
        return this._getBabeAuthor(bytes, sessionValidators);
      }
    }

    if (this.isPow) {
      return this._getPowAuthor(bytes);
    }

    return undefined;
  }
  /**
   * @description Override the default toString to return a 4-byte string
   */


  toString() {
    return ConsensusEngineId.idToString(this);
  }

}

exports.default = ConsensusEngineId;

/***/ }),

/***/ "../../node_modules/@polkadot/types/generic/Event.js":
/*!****************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/generic/Event.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.EventData = void 0;

var _classPrivateFieldLooseBase2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classPrivateFieldLooseBase */ "../../node_modules/@babel/runtime/helpers/classPrivateFieldLooseBase.js"));

var _classPrivateFieldLooseKey2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classPrivateFieldLooseKey */ "../../node_modules/@babel/runtime/helpers/classPrivateFieldLooseKey.js"));

var _Struct = _interopRequireDefault(__webpack_require__(/*! ../codec/Struct */ "../../node_modules/@polkadot/types/codec/Struct.js"));

var _Tuple = _interopRequireDefault(__webpack_require__(/*! ../codec/Tuple */ "../../node_modules/@polkadot/types/codec/Tuple.js"));

var _Null = _interopRequireDefault(__webpack_require__(/*! ../primitive/Null */ "../../node_modules/@polkadot/types/primitive/Null.js"));

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _meta = (0, _classPrivateFieldLooseKey2.default)("meta");

var _method = (0, _classPrivateFieldLooseKey2.default)("method");

var _section = (0, _classPrivateFieldLooseKey2.default)("section");

var _typeDef = (0, _classPrivateFieldLooseKey2.default)("typeDef");

/**
 * @name EventData
 * @description
 * Wrapper for the actual data that forms part of an [[Event]]
 */
class EventData extends _Tuple.default {
  constructor(registry, Types, value, typeDef, meta, section, method) {
    super(registry, Types, value);
    Object.defineProperty(this, _meta, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _method, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _section, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _typeDef, {
      writable: true,
      value: void 0
    });
    (0, _classPrivateFieldLooseBase2.default)(this, _meta)[_meta] = meta;
    (0, _classPrivateFieldLooseBase2.default)(this, _method)[_method] = method;
    (0, _classPrivateFieldLooseBase2.default)(this, _section)[_section] = section;
    (0, _classPrivateFieldLooseBase2.default)(this, _typeDef)[_typeDef] = typeDef;
  }
  /**
   * @description The wrapped [[EventMetadata]]
   */


  get meta() {
    return (0, _classPrivateFieldLooseBase2.default)(this, _meta)[_meta];
  }
  /**
   * @description The method as a string
   */


  get method() {
    return (0, _classPrivateFieldLooseBase2.default)(this, _method)[_method];
  }
  /**
   * @description The section as a string
   */


  get section() {
    return (0, _classPrivateFieldLooseBase2.default)(this, _section)[_section];
  }
  /**
   * @description The [[TypeDef]] for this event
   */


  get typeDef() {
    return (0, _classPrivateFieldLooseBase2.default)(this, _typeDef)[_typeDef];
  }

}
/**
 * @name Event
 * @description
 * A representation of a system event. These are generated via the [[Metadata]] interfaces and
 * specific to a specific Substrate runtime
 */


exports.EventData = EventData;

class Event extends _Struct.default {
  // Currently we _only_ decode from Uint8Array, since we expect it to
  // be used via EventRecord
  constructor(registry, _value) {
    const {
      DataType,
      value
    } = Event.decodeEvent(registry, _value);
    super(registry, {
      index: 'EventId',
      // eslint-disable-next-line sort-keys
      data: DataType
    }, value);
  }
  /** @internal */


  static decodeEvent(registry, value = new Uint8Array()) {
    if (!value.length) {
      return {
        DataType: _Null.default
      };
    }

    const index = value.subarray(0, 2);
    return {
      DataType: registry.findMetaEvent(index),
      value: {
        data: value.subarray(2),
        index
      }
    };
  }
  /**
   * @description The wrapped [[EventData]]
   */


  get data() {
    return this.get('data');
  }
  /**
   * @description The [[EventId]], identifying the raw event
   */


  get index() {
    return this.get('index');
  }
  /**
   * @description The [[EventMetadata]] with the documentation
   */


  get meta() {
    return this.data.meta;
  }
  /**
   * @description The method string identifying the event
   */


  get method() {
    return this.data.method;
  }
  /**
   * @description The section string identifying the event
   */


  get section() {
    return this.data.section;
  }
  /**
   * @description The [[TypeDef]] for the event
   */


  get typeDef() {
    return this.data.typeDef;
  }
  /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars


  toHuman(isExpanded) {
    // FIXME May this human-friendly
    return this.toJSON();
  }

}

exports.default = Event;

/***/ }),

/***/ "../../node_modules/@polkadot/types/generic/LookupSource.js":
/*!***********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/generic/LookupSource.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.ACCOUNT_ID_PREFIX = void 0;

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _utilCrypto = __webpack_require__(/*! @polkadot/util-crypto */ "../../node_modules/@polkadot/util-crypto/index.js");

var _Base = _interopRequireDefault(__webpack_require__(/*! ../codec/Base */ "../../node_modules/@polkadot/types/codec/Base.js"));

var _AccountId = _interopRequireDefault(__webpack_require__(/*! ./AccountId */ "../../node_modules/@polkadot/types/generic/AccountId.js"));

var _AccountIndex = _interopRequireDefault(__webpack_require__(/*! ./AccountIndex */ "../../node_modules/@polkadot/types/generic/AccountIndex.js"));

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
const ACCOUNT_ID_PREFIX = new Uint8Array([0xff]);
/** @internal */

exports.ACCOUNT_ID_PREFIX = ACCOUNT_ID_PREFIX;

function decodeString(registry, value) {
  const decoded = (0, _utilCrypto.decodeAddress)(value);
  return decoded.length === 32 ? registry.createType('AccountId', decoded) : registry.createType('AccountIndex', (0, _util.u8aToBn)(decoded, true));
}
/** @internal */


function decodeU8a(registry, value) {
  // This allows us to instantiate an address with a raw publicKey. Do this first before
  // we checking the first byte, otherwise we may split an already-existent valid address
  if (value.length === 32) {
    return registry.createType('AccountId', value);
  } else if (value[0] === 0xff) {
    return registry.createType('AccountId', value.subarray(1));
  }

  const [offset, length] = _AccountIndex.default.readLength(value);

  return registry.createType('AccountIndex', (0, _util.u8aToBn)(value.subarray(offset, offset + length), true));
}
/**
 * @name LookupSource
 * @description
 * A wrapper around an AccountId and/or AccountIndex that is encoded with a prefix.
 * Since we are dealing with underlying publicKeys (or shorter encoded addresses),
 * we extend from Base with an AccountId/AccountIndex wrapper. Basically the Address
 * is encoded as `[ <prefix-byte>, ...publicKey/...bytes ]` as per spec
 */


class LookupSource extends _Base.default {
  constructor(registry, value = new Uint8Array()) {
    super(registry, LookupSource._decodeAddress(registry, value));
  }
  /** @internal */


  static _decodeAddress(registry, value) {
    if (value instanceof _AccountId.default || value instanceof _AccountIndex.default) {
      return value;
    } else if (value instanceof LookupSource) {
      return value._raw;
    } else if ((0, _util.isBn)(value) || (0, _util.isNumber)(value)) {
      return registry.createType('AccountIndex', value);
    } else if (Array.isArray(value) || (0, _util.isHex)(value) || (0, _util.isU8a)(value)) {
      return decodeU8a(registry, (0, _util.u8aToU8a)(value));
    }

    return decodeString(registry, value);
  }
  /**
   * @description The length of the value when encoded as a Uint8Array
   */


  get encodedLength() {
    const rawLength = this._rawLength;
    return rawLength + ( // for 1 byte AccountIndexes, we are not adding a specific prefix
    rawLength > 1 ? 1 : 0);
  }
  /**
   * @description The length of the raw value, either AccountIndex or AccountId
   */


  get _rawLength() {
    return this._raw instanceof _AccountIndex.default ? _AccountIndex.default.calcLength(this._raw) : this._raw.encodedLength;
  }
  /**
   * @description Returns a hex string representation of the value
   */


  toHex() {
    return (0, _util.u8aToHex)(this.toU8a());
  }
  /**
   * @description Returns the base runtime type name for this instance
   */


  toRawType() {
    return 'Address';
  }
  /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */


  toU8a(isBare) {
    const encoded = this._raw.toU8a().subarray(0, this._rawLength);

    return isBare ? encoded : (0, _util.u8aConcat)(this._raw instanceof _AccountIndex.default ? _AccountIndex.default.writeLength(encoded) : ACCOUNT_ID_PREFIX, encoded);
  }

}

exports.default = LookupSource;

/***/ }),

/***/ "../../node_modules/@polkadot/types/generic/Vote.js":
/*!***************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/generic/Vote.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _U8aFixed = _interopRequireDefault(__webpack_require__(/*! ../codec/U8aFixed */ "../../node_modules/@polkadot/types/codec/U8aFixed.js"));

var _Bool = _interopRequireDefault(__webpack_require__(/*! ../primitive/Bool */ "../../node_modules/@polkadot/types/primitive/Bool.js"));

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// For votes, the topmost bit indicated aye/nay, the lower bits indicate the conviction
const AYE_BITS = 0b10000000;
const NAY_BITS = 0b00000000;
const CON_MASK = 0b01111111;
const DEF_CONV = 0b00000000; // the default conviction, None

/** @internal */

function decodeVoteBool(value) {
  return value ? new Uint8Array([AYE_BITS | DEF_CONV]) : new Uint8Array([NAY_BITS]);
}
/** @internal */


function decodeVoteU8a(value) {
  return value.length ? value.subarray(0, 1) : new Uint8Array([NAY_BITS]);
}
/** @internal */


function decodeVote(registry, value) {
  if ((0, _util.isUndefined)(value) || value instanceof Boolean || (0, _util.isBoolean)(value)) {
    return decodeVoteBool(new _Bool.default(registry, value).isTrue);
  } else if ((0, _util.isNumber)(value)) {
    return decodeVoteBool(value < 0);
  } else if ((0, _util.isU8a)(value)) {
    return decodeVoteU8a(value);
  }

  const vote = new _Bool.default(registry, value.aye).isTrue ? AYE_BITS : NAY_BITS;
  const conviction = registry.createType('Conviction', (0, _util.isUndefined)(value.conviction) ? DEF_CONV : value.conviction);
  return new Uint8Array([vote | conviction.index]);
}
/**
 * @name Vote
 * @description
 * A number of lock periods, plus a vote, one way or the other.
 */


class Vote extends _U8aFixed.default {
  constructor(registry, value) {
    // decoded is just 1 byte
    // Aye: Most Significant Bit
    // Conviction: 0000 - 0101
    const decoded = decodeVote(registry, value);
    super(registry, decoded, 8);
    this._aye = void 0;
    this._conviction = void 0;
    this._aye = (decoded[0] & AYE_BITS) === AYE_BITS;
    this._conviction = this.registry.createType('Conviction', decoded[0] & CON_MASK);
  }
  /**
   * @description returns a V2 conviction
   */


  get conviction() {
    return this._conviction;
  }
  /**
   * @description true if the wrapped value is a positive vote
   */


  get isAye() {
    return this._aye;
  }
  /**
   * @description true if the wrapped value is a negative vote
   */


  get isNay() {
    return !this.isAye;
  }
  /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */


  toHuman(isExpanded) {
    return {
      conviction: this.conviction.toHuman(isExpanded),
      vote: this.isAye ? 'Aye' : 'Nay'
    };
  }
  /**
   * @description Returns the base runtime type name for this instance
   */


  toRawType() {
    return 'Vote';
  }

}

exports.default = Vote;

/***/ }),

/***/ "../../node_modules/@polkadot/types/generic/index.js":
/*!****************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/generic/index.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  GenericAccountId: true,
  GenericAccountIndex: true,
  GenericBlock: true,
  GenericCall: true,
  GenericConsensusEngineId: true,
  GenericEvent: true,
  GenericLookupSource: true,
  GenericVote: true
};
Object.defineProperty(exports, "GenericAccountId", {
  enumerable: true,
  get: function () {
    return _AccountId.default;
  }
});
Object.defineProperty(exports, "GenericAccountIndex", {
  enumerable: true,
  get: function () {
    return _AccountIndex.default;
  }
});
Object.defineProperty(exports, "GenericBlock", {
  enumerable: true,
  get: function () {
    return _Block.default;
  }
});
Object.defineProperty(exports, "GenericCall", {
  enumerable: true,
  get: function () {
    return _Call.default;
  }
});
Object.defineProperty(exports, "GenericConsensusEngineId", {
  enumerable: true,
  get: function () {
    return _ConsensusEngineId.default;
  }
});
Object.defineProperty(exports, "GenericEvent", {
  enumerable: true,
  get: function () {
    return _Event.default;
  }
});
Object.defineProperty(exports, "GenericLookupSource", {
  enumerable: true,
  get: function () {
    return _LookupSource.default;
  }
});
Object.defineProperty(exports, "GenericVote", {
  enumerable: true,
  get: function () {
    return _Vote.default;
  }
});

var _ethereum = __webpack_require__(/*! ../ethereum */ "../../node_modules/@polkadot/types/ethereum/index.js");

Object.keys(_ethereum).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _ethereum[key];
    }
  });
});

var _AccountId = _interopRequireDefault(__webpack_require__(/*! ./AccountId */ "../../node_modules/@polkadot/types/generic/AccountId.js"));

var _AccountIndex = _interopRequireDefault(__webpack_require__(/*! ./AccountIndex */ "../../node_modules/@polkadot/types/generic/AccountIndex.js"));

var _Block = _interopRequireDefault(__webpack_require__(/*! ./Block */ "../../node_modules/@polkadot/types/generic/Block.js"));

var _Call = _interopRequireDefault(__webpack_require__(/*! ./Call */ "../../node_modules/@polkadot/types/generic/Call.js"));

var _ConsensusEngineId = _interopRequireDefault(__webpack_require__(/*! ./ConsensusEngineId */ "../../node_modules/@polkadot/types/generic/ConsensusEngineId.js"));

var _Event = _interopRequireDefault(__webpack_require__(/*! ./Event */ "../../node_modules/@polkadot/types/generic/Event.js"));

var _LookupSource = _interopRequireDefault(__webpack_require__(/*! ./LookupSource */ "../../node_modules/@polkadot/types/generic/LookupSource.js"));

var _Vote = _interopRequireDefault(__webpack_require__(/*! ./Vote */ "../../node_modules/@polkadot/types/generic/Vote.js"));

/***/ }),

/***/ "../../node_modules/@polkadot/types/index.js":
/*!********************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__dirname) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _codec = __webpack_require__(/*! ./codec */ "../../node_modules/@polkadot/types/codec/index.js");

Object.keys(_codec).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _codec[key];
    }
  });
});

var _create = __webpack_require__(/*! ./create */ "../../node_modules/@polkadot/types/create/index.js");

Object.keys(_create).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _create[key];
    }
  });
});

var _index = __webpack_require__(/*! ./index.types */ "../../node_modules/@polkadot/types/index.types.js");

Object.keys(_index).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index[key];
    }
  });
});
// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// FIXME This really should be `import(...).then(...)`, but need to check rejections
// eslint-disable-next-line @typescript-eslint/no-var-requires
(0, _util.detectPackage)(__webpack_require__(/*! ./package.json */ "../../node_modules/@polkadot/types/package.json"),  true && __dirname);
/* WEBPACK VAR INJECTION */}.call(this, "/"))

/***/ }),

/***/ "../../node_modules/@polkadot/types/index.types.js":
/*!**************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/index.types.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  Metadata: true
};
Object.defineProperty(exports, "Metadata", {
  enumerable: true,
  get: function () {
    return _Metadata.default;
  }
});

var _Metadata = _interopRequireDefault(__webpack_require__(/*! @polkadot/metadata/Metadata */ "../../node_modules/@polkadot/metadata/Metadata/index.js"));

var _extrinsic = __webpack_require__(/*! ./extrinsic */ "../../node_modules/@polkadot/types/extrinsic/index.js");

Object.keys(_extrinsic).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _extrinsic[key];
    }
  });
});

var _generic = __webpack_require__(/*! ./generic */ "../../node_modules/@polkadot/types/generic/index.js");

Object.keys(_generic).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _generic[key];
    }
  });
});

var _primitive = __webpack_require__(/*! ./primitive */ "../../node_modules/@polkadot/types/primitive/index.js");

Object.keys(_primitive).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _primitive[key];
    }
  });
});

/***/ }),

/***/ "../../node_modules/@polkadot/types/interfaces/attestations/definitions.js":
/*!**************************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/interfaces/attestations/definitions.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)

/* eslint-disable sort-keys */
var _default = {
  rpc: {},
  types: {
    BlockAttestations: {
      receipt: 'CandidateReceipt',
      valid: 'Vec<AccountId>',
      invalid: 'Vec<AccountId>'
    },
    IncludedBlocks: {
      actualNumber: 'BlockNumber',
      session: 'SessionIndex',
      randomSeed: 'H256',
      activeParachains: 'Vec<ParaId>',
      paraBlocks: 'Vec<Hash>'
    },
    MoreAttestations: {}
  }
};
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types/interfaces/aura/definitions.js":
/*!******************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/interfaces/aura/definitions.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)

/* eslint-disable sort-keys */
var _default = {
  rpc: {},
  types: {
    RawAuraPreDigest: {
      slotNumber: 'u64'
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types/interfaces/author/definitions.js":
/*!********************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/interfaces/author/definitions.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)

/* eslint-disable sort-keys */
var _default = {
  rpc: {
    hasKey: {
      description: 'Returns true if the keystore has private keys for the given public key and key type.',
      params: [{
        name: 'publicKey',
        type: 'Bytes'
      }, {
        name: 'keyType',
        type: 'Text'
      }],
      type: 'bool'
    },
    hasSessionKeys: {
      description: 'Returns true if the keystore has private keys for the given session public keys.',
      params: [{
        name: 'sessionKeys',
        type: 'Bytes'
      }],
      type: 'bool'
    },
    removeExtrinsic: {
      description: 'Remove given extrinsic from the pool and temporarily ban it to prevent reimporting',
      params: [{
        name: 'bytesOrHash',
        type: 'Vec<ExtrinsicOrHash>'
      }],
      type: 'Vec<Hash>'
    },
    insertKey: {
      description: 'Insert a key into the keystore.',
      params: [{
        name: 'keyType',
        type: 'Text'
      }, {
        name: 'suri',
        type: 'Text'
      }, {
        name: 'publicKey',
        type: 'Bytes'
      }],
      type: 'Bytes'
    },
    rotateKeys: {
      description: 'Generate new session keys and returns the corresponding public keys',
      params: [],
      type: 'Bytes'
    },
    pendingExtrinsics: {
      description: 'Returns all pending extrinsics, potentially grouped by sender',
      params: [],
      type: 'Vec<Extrinsic>'
    },
    submitExtrinsic: {
      isSigned: true,
      description: 'Submit a fully formatted extrinsic for block inclusion',
      params: [{
        name: 'extrinsic',
        type: 'Extrinsic'
      }],
      type: 'Hash'
    },
    submitAndWatchExtrinsic: {
      description: 'Submit and subscribe to watch an extrinsic until unsubscribed',
      isSigned: true,
      params: [{
        name: 'extrinsic',
        type: 'Extrinsic'
      }],
      pubsub: ['extrinsicUpdate', 'submitAndWatchExtrinsic', 'unwatchExtrinsic'],
      type: 'ExtrinsicStatus'
    }
  },
  types: {
    ExtrinsicOrHash: {
      _enum: {
        Hash: 'Hash',
        Extrinsic: 'Bytes'
      }
    },
    ExtrinsicStatus: {
      _enum: {
        Future: 'Null',
        Ready: 'Null',
        Broadcast: 'Vec<Text>',
        InBlock: 'Hash',
        Retracted: 'Hash',
        FinalityTimeout: 'Hash',
        Finalized: 'Hash',
        Usurped: 'Hash',
        Dropped: 'Null',
        Invalid: 'Null'
      }
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types/interfaces/authorship/definitions.js":
/*!************************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/interfaces/authorship/definitions.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)

/* eslint-disable sort-keys */
var _default = {
  rpc: {},
  types: {
    UncleEntryItem: {
      _enum: {
        InclusionHeight: 'BlockNumber',
        Uncle: '(Hash, Option<AccountId>)'
      }
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types/interfaces/babe/definitions.js":
/*!******************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/interfaces/babe/definitions.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)

/* eslint-disable sort-keys */
var _default = {
  rpc: {
    epochAuthorship: {
      description: 'Returns data about which slots (primary or secondary) can be claimed in the current epoch with the keys in the keystore',
      params: [],
      type: 'HashMap<AuthorityId, EpochAuthorship>'
    }
  },
  types: {
    AllowedSlots: {
      _enum: ['PrimarySlots', 'PrimaryAndSecondaryPlainSlots', 'PrimaryAndSecondaryVRFSlots']
    },
    BabeAuthorityWeight: 'u64',
    BabeBlockWeight: 'u32',
    BabeEquivocationProof: {
      offender: 'AuthorityId',
      slotNumber: 'SlotNumber',
      firstHeader: 'Header',
      secondHeader: 'Header'
    },
    BabeWeight: 'u64',
    MaybeRandomness: 'Option<Randomness>',
    MaybeVrf: 'Option<VrfData>',
    EpochAuthorship: {
      primary: 'Vec<u64>',
      secondary: 'Vec<u64>',
      secondary_vrf: 'Vec<u64>'
    },
    NextConfigDescriptor: {
      _enum: {
        V0: 'Null',
        V1: 'NextConfigDescriptorV1'
      }
    },
    NextConfigDescriptorV1: {
      c: '(u64, u64)',
      allowedSlots: 'AllowedSlots'
    },
    Randomness: 'Hash',
    RawBabePreDigest: {
      _enum: {
        Phantom: 'Null',
        // index starts at 1... empty slot at 0
        Primary: 'RawBabePreDigestPrimary',
        SecondaryPlain: 'RawBabePreDigestSecondaryPlain',
        SecondaryVRF: 'RawBabePreDigestSecondaryVRF'
      }
    },
    RawBabePreDigestPrimary: {
      authorityIndex: 'u32',
      // AuthorityIndex (also in aura)
      slotNumber: 'SlotNumber',
      vrfOutput: 'VrfOutput',
      vrfProof: 'VrfProof'
    },
    RawBabePreDigestSecondaryPlain: {
      authorityIndex: 'u32',
      // AuthorityIndex (also in aura)
      slotNumber: 'SlotNumber'
    },
    RawBabePreDigestSecondaryVRF: {
      authorityIndex: 'u32',
      slotNumber: 'SlotNumber',
      vrfOutput: 'VrfOutput',
      vrfProof: 'VrfProof'
    },
    RawBabePreDigestTo159: {
      _enum: {
        Primary: 'RawBabePreDigestPrimaryTo159',
        Secondary: 'RawBabePreDigestSecondaryTo159'
      }
    },
    RawBabePreDigestPrimaryTo159: {
      authorityIndex: 'u32',
      slotNumber: 'SlotNumber',
      weight: 'BabeBlockWeight',
      vrfOutput: 'VrfOutput',
      vrfProof: 'VrfProof'
    },
    RawBabePreDigestSecondaryTo159: {
      authorityIndex: 'u32',
      slotNumber: 'SlotNumber',
      weight: 'BabeBlockWeight'
    },
    // a cross old/new compatible version of the digest, that is _only_ useful
    // for partial parsing and extraction of the author. This assumes that all
    // entries has the authorityIndex in the first position - and that it is all
    // we are interested in
    RawBabePreDigestCompat: {
      _enum: {
        Zero: 'u32',
        One: 'u32',
        Two: 'u32',
        Three: 'u32'
      }
    },
    SlotNumber: 'u64',
    VrfData: '[u8; 32]',
    VrfOutput: '[u8; 32]',
    VrfProof: '[u8; 64]'
  }
};
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types/interfaces/balances/definitions.js":
/*!**********************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/interfaces/balances/definitions.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)

/* eslint-disable sort-keys */
var _default = {
  rpc: {},
  types: {
    AccountData: {
      free: 'Balance',
      reserved: 'Balance',
      miscFrozen: 'Balance',
      feeFrozen: 'Balance'
    },
    BalanceLockTo212: {
      id: 'LockIdentifier',
      amount: 'Balance',
      until: 'BlockNumber',
      reasons: 'WithdrawReasons'
    },
    BalanceLock: {
      id: 'LockIdentifier',
      amount: 'Balance',
      reasons: 'Reasons'
    },
    BalanceStatus: {
      _enum: ['Free', 'Reserved']
    },
    Reasons: {
      _enum: ['Fee', 'Misc', 'All']
    },
    VestingSchedule: {
      offset: 'Balance',
      perBlock: 'Balance',
      startingBlock: 'BlockNumber'
    },
    WithdrawReasons: {
      _set: {
        TransactionPayment: 0b00000001,
        Transfer: 0b00000010,
        Reserve: 0b00000100,
        Fee: 0b00001000,
        Tip: 0b00010000
      }
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types/interfaces/chain/definitions.js":
/*!*******************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/interfaces/chain/definitions.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)

/* eslint-disable sort-keys */
var _default = {
  rpc: {
    getHeader: {
      alias: ['chain_getHead'],
      description: 'Retrieves the header for a specific block',
      params: [{
        name: 'hash',
        type: 'BlockHash',
        isCached: true,
        isOptional: true
      }],
      type: 'Header'
    },
    getBlock: {
      description: 'Get header and body of a relay chain block',
      params: [{
        name: 'hash',
        type: 'BlockHash',
        isHistoric: true,
        isOptional: true
      }],
      type: 'SignedBlock'
    },
    getBlockHash: {
      description: 'Get the block hash for a specific block',
      params: [{
        name: 'blockNumber',
        type: 'BlockNumber',
        isOptional: true
      }],
      type: 'BlockHash'
    },
    getFinalizedHead: {
      alias: ['chain_getFinalisedHead'],
      description: 'Get hash of the last finalized block in the canon chain',
      params: [],
      type: 'BlockHash'
    },
    subscribeNewHeads: {
      alias: ['chain_unsubscribeNewHeads', 'subscribe_newHead', 'unsubscribe_newHead'],
      description: 'Retrieves the best header via subscription',
      params: [],
      // NOTE These still has the aliassed version, compatible with 1.x
      pubsub: ['newHead', 'subscribeNewHead', 'unsubscribeNewHead'],
      type: 'Header'
    },
    subscribeFinalizedHeads: {
      alias: ['chain_subscribeFinalisedHeads', 'chain_unsubscribeFinalisedHeads'],
      description: 'Retrieves the best finalized header via subscription',
      params: [],
      pubsub: ['finalizedHead', 'subscribeFinalizedHeads', 'unsubscribeFinalizedHeads'],
      type: 'Header'
    },
    subscribeAllHeads: {
      description: 'Retrieves the newest header via subscription',
      params: [],
      pubsub: ['allHead', 'subscribeAllHeads', 'unsubscribeAllHeads'],
      type: 'Header'
    }
  },
  types: {
    BlockHash: 'Hash'
  }
};
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types/interfaces/childstate/definitions.js":
/*!************************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/interfaces/childstate/definitions.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)

/* eslint-disable sort-keys */
var _default = {
  rpc: {
    getKeys: {
      description: 'Returns the keys with prefix from a child storage, leave empty to get all the keys',
      params: [{
        name: 'childKey',
        type: 'PrefixedStorageKey'
      }, {
        name: 'prefix',
        type: 'StorageKey'
      }, {
        name: 'at',
        type: 'Hash',
        isHistoric: true,
        isOptional: true
      }],
      type: 'Vec<StorageKey>'
    },
    getStorage: {
      description: 'Returns a child storage entry at a specific block state',
      params: [{
        name: 'childKey',
        type: 'PrefixedStorageKey'
      }, {
        name: 'key',
        type: 'StorageKey'
      }, {
        name: 'at',
        type: 'Hash',
        isHistoric: true,
        isOptional: true
      }],
      type: 'Option<StorageData>'
    },
    getStorageHash: {
      description: 'Returns the hash of a child storage entry at a block state',
      params: [{
        name: 'childKey',
        type: 'PrefixedStorageKey'
      }, {
        name: 'key',
        type: 'StorageKey'
      }, {
        name: 'at',
        type: 'Hash',
        isHistoric: true,
        isOptional: true
      }],
      type: 'Option<Hash>'
    },
    getStorageSize: {
      description: 'Returns the size of a child storage entry at a block state',
      params: [{
        name: 'childKey',
        type: 'PrefixedStorageKey'
      }, {
        name: 'key',
        type: 'StorageKey'
      }, {
        name: 'at',
        type: 'Hash',
        isHistoric: true,
        isOptional: true
      }],
      type: 'Option<u64>'
    }
  },
  types: {
    // StorageKey extends Bytes
    PrefixedStorageKey: 'StorageKey'
  }
};
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types/interfaces/claims/definitions.js":
/*!********************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/interfaces/claims/definitions.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)

/* eslint-disable sort-keys */
var _default = {
  rpc: {},
  types: {
    EthereumAddress: 'H160',
    StatementKind: {
      _enum: ['Regular', 'Saft']
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types/interfaces/collective/definitions.js":
/*!************************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/interfaces/collective/definitions.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)

/* eslint-disable sort-keys */
var _default = {
  rpc: {},
  types: {
    CollectiveOrigin: {
      _enum: {
        Members: '(MemberCount, MemberCount)',
        Member: 'AccountId'
      }
    },
    MemberCount: 'u32',
    ProposalIndex: 'u32',
    VotesTo230: {
      index: 'ProposalIndex',
      threshold: 'MemberCount',
      ayes: 'Vec<AccountId>',
      nays: 'Vec<AccountId>'
    },
    Votes: {
      index: 'ProposalIndex',
      threshold: 'MemberCount',
      ayes: 'Vec<AccountId>',
      nays: 'Vec<AccountId>',
      end: 'BlockNumber'
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types/interfaces/consensus/definitions.js":
/*!***********************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/interfaces/consensus/definitions.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)

/* eslint-disable sort-keys */
var _default = {
  rpc: {},
  types: {
    AuthorityId: 'AccountId',
    RawVRFOutput: '[u8; 32]'
  }
};
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types/interfaces/contracts/definitions.js":
/*!***********************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/interfaces/contracts/definitions.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)

/* eslint-disable sort-keys */
var _default = {
  rpc: {
    call: {
      description: 'Executes a call to a contract',
      params: [{
        name: 'callRequest',
        type: 'ContractCallRequest'
      }, {
        name: 'at',
        type: 'BlockHash',
        isHistoric: true,
        isOptional: true
      }],
      type: 'ContractExecResult'
    },
    getStorage: {
      description: 'Returns the value under a specified storage key in a contract',
      params: [{
        name: 'address',
        type: 'AccountId'
      }, {
        name: 'key',
        type: 'H256'
      }, {
        name: 'at',
        type: 'BlockHash',
        isHistoric: true,
        isOptional: true
      }],
      type: 'Option<Bytes>'
    },
    rentProjection: {
      description: 'Returns the projected time a given contract will be able to sustain paying its rent',
      params: [{
        name: 'address',
        type: 'AccountId'
      }, {
        name: 'at',
        type: 'BlockHash',
        isHistoric: true,
        isOptional: true
      }],
      type: 'Option<BlockNumber>'
    }
  },
  types: {
    AliveContractInfo: {
      trieId: 'TrieId',
      storageSize: 'u32',
      emptyPairCount: 'u32',
      totalPairCount: 'u32',
      codeHash: 'CodeHash',
      rentAllowance: 'Balance',
      deductBlock: 'BlockNumber',
      lastWrite: 'Option<BlockNumber>'
    },
    CodeHash: 'Hash',
    ContractCallRequest: {
      origin: 'AccountId',
      dest: 'AccountId',
      value: 'Balance',
      gasLimit: 'u64',
      inputData: 'Bytes'
    },
    ContractExecResultSuccessTo255: {
      status: 'u8',
      data: 'Raw'
    },
    ContractExecResultTo255: {
      _enum: {
        Success: 'ContractExecResultSuccessTo255',
        Error: 'Null'
      }
    },
    ContractExecResultSuccess: {
      flags: 'u32',
      data: 'Bytes',
      gasConsumed: 'u64'
    },
    ContractExecResult: {
      _enum: {
        Success: 'ContractExecResultSuccess',
        Error: 'Null'
      }
    },
    ContractInfo: {
      _enum: {
        Alive: 'AliveContractInfo',
        Tombstone: 'TombstoneContractInfo'
      }
    },
    ContractStorageKey: '[u8; 32]',
    Gas: 'u64',
    HostFnWeights: {
      caller: 'Weight',
      address: 'Weight',
      gasLeft: 'Weight',
      balance: 'Weight',
      valueTransferred: 'Weight',
      minimumBalance: 'Weight',
      tombstoneDeposit: 'Weight',
      rentAllowance: 'Weight',
      blockNumber: 'Weight',
      now: 'Weight',
      weightToFee: 'Weight',
      gas: 'Weight',
      input: 'Weight',
      inputPerByte: 'Weight',
      return: 'Weight',
      returnPerByte: 'Weight',
      terminate: 'Weight',
      restoreTo: 'Weight',
      restoreToPerDelta: 'Weight',
      random: 'Weight',
      depositEvent: 'Weight',
      depositEventPerTopic: 'Weight',
      depositEventPerByte: 'Weight',
      setRentAllowance: 'Weight',
      setStorage: 'Weight',
      setStoragePerByte: 'Weight',
      clearStorage: 'Weight',
      getStorage: 'Weight',
      getStoragePerByte: 'Weight',
      transfer: 'Weight',
      call: 'Weight',
      callTransferSurcharge: 'Weight',
      callPerInputByte: 'Weight',
      callPerOutputByte: 'Weight',
      instantiate: 'Weight',
      instantiatePerInputByte: 'Weight',
      instantiatePerOutputByte: 'Weight',
      hashSha2256: 'Weight',
      hashSha2256PerByte: 'Weight',
      hashKeccak256: 'Weight',
      hashKeccak256PerByte: 'Weight',
      hashBlake2256: 'Weight',
      hashBlake2256PerByte: 'Weight',
      hashBlake2128: 'Weight',
      hashBlake2128PerByte: 'Weight'
    },
    InstructionWeights: {
      growMem: 'Weight',
      regular: 'Weight'
    },
    PrefabWasmModule: {
      scheduleVersion: 'Compact<u32>',
      initial: 'Compact<u32>',
      maximum: 'Compact<u32>',
      _reserved: 'PrefabWasmModuleReserved',
      code: 'Bytes'
    },
    PrefabWasmModuleReserved: 'Option<Null>',
    ScheduleTo212: {
      version: 'u32',
      putCodePerByteCost: 'Gas',
      growMemCost: 'Gas',
      regularOpCost: 'Gas',
      returnDataPerByteCost: 'Gas',
      eventDataPerByteCost: 'Gas',
      eventPerTopicCost: 'Gas',
      eventBaseCost: 'Gas',
      sandboxDataReadCost: 'Gas',
      sandboxDataWriteCost: 'Gas',
      maxEventTopics: 'u32',
      maxStackHeight: 'u32',
      maxMemoryPages: 'u32',
      enablePrintln: 'bool',
      maxSubjectLen: 'u32'
    },
    ScheduleTo258: {
      version: 'u32',
      putCodePerByteCost: 'Gas',
      growMemCost: 'Gas',
      regularOpCost: 'Gas',
      returnDataPerByteCost: 'Gas',
      eventDataPerByteCost: 'Gas',
      eventPerTopicCost: 'Gas',
      eventBaseCost: 'Gas',
      sandboxDataReadCost: 'Gas',
      sandboxDataWriteCost: 'Gas',
      transferCost: 'Gas',
      maxEventTopics: 'u32',
      maxStackHeight: 'u32',
      maxMemoryPages: 'u32',
      enablePrintln: 'bool',
      maxSubjectLen: 'u32'
    },
    Schedule: {
      version: 'u32',
      instructionWeights: 'InstructionWeights',
      hostFnWeights: 'HostFnWeights',
      enablePrintln: 'bool',
      maxEventTopics: 'u32',
      maxStackHeight: 'u32',
      maxMemoryPages: 'u32',
      maxTableSize: 'u32',
      maxSubjectLen: 'u32',
      maxCodeSize: 'u32'
    },
    SeedOf: 'Hash',
    TombstoneContractInfo: 'Hash',
    TrieId: 'Bytes'
  }
};
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types/interfaces/contractsAbi/definitions.js":
/*!**************************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/interfaces/contractsAbi/definitions.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)

/* eslint-disable sort-keys */
const layout = {
  InkCryptoHasher: {
    _enum: ['Blake2x256', 'Sha2x256', 'Keccak256']
  },
  InkDiscriminant: 'u32',
  InkLayoutArray: {
    offset: 'InkLayoutKey',
    len: 'u32',
    cellsPerElem: 'u64',
    layout: 'InkStorageLayout'
  },
  InkLayoutCell: {
    key: 'InkLayoutKey',
    ty: 'MtLookupTypeId'
  },
  InkLayoutEnum: {
    dispatchKey: 'InkLayoutKey',
    variants: 'BTreeMap<InkDiscriminant, InkLayoutStruct>'
  },
  InkLayoutHash: {
    offset: 'InkLayoutKey',
    strategy: 'InkLayoutHashingStrategy',
    layout: 'InkStorageLayout'
  },
  InkLayoutHashingStrategy: {
    hasher: 'InkCryptoHasher',
    postfix: 'Vec<u8>',
    prefix: 'Vec<u8>'
  },
  InkLayoutKey: '[u8; 32]',
  InkLayoutStruct: {
    fields: 'Vec<InkLayoutStructField>'
  },
  InkLayoutStructField: {
    layout: 'InkStorageLayout',
    name: 'Text'
  },
  InkStorageLayout: {
    _enum: {
      Cell: 'InkLayoutCell',
      Hash: 'InkLayoutHash',
      Array: 'InkLayoutArray',
      Struct: 'InkLayoutStruct',
      Enum: 'InkLayoutEnum'
    }
  }
};
const spec = {
  InkConstructorSpec: {
    name: 'Text',
    selector: 'InkSelector',
    args: 'Vec<InkMessageParamSpec>',
    docs: 'Vec<Text>'
  },
  InkContractSpec: {
    constructors: 'Vec<InkConstructorSpec>',
    messages: 'Vec<InkMessageSpec>',
    events: 'Vec<InkEventSpec>',
    docs: 'Vec<Text>'
  },
  InkDisplayName: 'MtPath',
  InkEventParamSpec: {
    name: 'Text',
    indexed: 'bool',
    type: 'InkTypeSpec',
    docs: 'Vec<Text>'
  },
  InkEventSpec: {
    name: 'Text',
    args: 'Vec<InkEventParamSpec>',
    docs: 'Vec<Text>'
  },
  InkMessageParamSpec: {
    name: 'Text',
    type: 'InkTypeSpec'
  },
  InkMessageSpec: {
    name: 'Text',
    selector: 'InkSelector',
    mutates: 'bool',
    payable: 'bool',
    args: 'Vec<InkMessageParamSpec>',
    returnType: 'Option<InkTypeSpec>',
    docs: 'Vec<Text>'
  },
  InkSelector: '[u8; 4]',
  InkTypeSpec: {
    type: 'MtLookupTypeId',
    displayName: 'InkDisplayName'
  }
};
const registry = {
  MtField: {
    name: 'Option<Text>',
    type: 'MtLookupTypeId'
  },
  MtLookupTypeId: 'u32',
  MtPath: 'Vec<Text>',
  MtType: {
    path: 'MtPath',
    params: 'Vec<MtLookupTypeId>',
    def: 'MtTypeDef'
  },
  MtTypeDef: {
    _enum: {
      Composite: 'MtTypeDefComposite',
      Variant: 'MtTypeDefVariant',
      Sequence: 'MtTypeDefSequence',
      Array: 'MtTypeDefArray',
      Tuple: 'MtTypeDefTuple',
      Primitive: 'MtTypeDefPrimitive'
    }
  },
  MtTypeDefArray: {
    len: 'u16',
    type: 'MtLookupTypeId'
  },
  MtTypeDefComposite: {
    fields: 'Vec<MtField>'
  },
  MtTypeDefVariant: {
    variants: 'Vec<MtVariant>'
  },
  MtTypeDefPrimitive: {
    // this enum definition is mapped in api-contracts/inkTypes.ts
    _enum: ['Bool', 'Char', 'Str', 'U8', 'U16', 'U32', 'U64', 'U128', 'I8', 'I16', 'I32', 'I64', 'I128']
  },
  MtTypeDefSequence: {
    type: 'MtLookupTypeId'
  },
  MtTypeDefTuple: 'Vec<MtLookupTypeId>',
  MtVariant: {
    name: 'Text',
    fields: 'Vec<MtField>',
    discriminant: 'Option<u64>'
  }
};
var _default = {
  rpc: {},
  types: _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, layout), registry), spec), {}, {
    InkProject: {
      // added by ABI serialization
      metadataVersion: 'Text',
      source: 'InkProjectSource',
      contract: 'InkProjectContract',
      // expanded scale registry: RegistryReadOnly
      types: 'Vec<MtType>',
      // renamed from layout (ignored for now, incomplete)
      // storage: 'InkStorageLayout',
      spec: 'InkContractSpec'
    },
    InkProjectContract: {
      name: 'Text',
      version: 'Text',
      authors: 'Vec<Text>',
      description: 'Option<Text>',
      documentation: 'Option<Text>',
      repository: 'Option<Text>',
      homepage: 'Option<Text>',
      license: 'Option<Text>'
    },
    InkProjectSource: {
      hash: '[u8; 32]',
      language: 'Text',
      compiler: 'Text'
    }
  })
};
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types/interfaces/definitions.js":
/*!*************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/interfaces/definitions.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "runtime", {
  enumerable: true,
  get: function () {
    return _definitions.default;
  }
});
Object.defineProperty(exports, "authorship", {
  enumerable: true,
  get: function () {
    return _definitions2.default;
  }
});
Object.defineProperty(exports, "aura", {
  enumerable: true,
  get: function () {
    return _definitions3.default;
  }
});
Object.defineProperty(exports, "babe", {
  enumerable: true,
  get: function () {
    return _definitions4.default;
  }
});
Object.defineProperty(exports, "balances", {
  enumerable: true,
  get: function () {
    return _definitions5.default;
  }
});
Object.defineProperty(exports, "collective", {
  enumerable: true,
  get: function () {
    return _definitions6.default;
  }
});
Object.defineProperty(exports, "consensus", {
  enumerable: true,
  get: function () {
    return _definitions7.default;
  }
});
Object.defineProperty(exports, "contracts", {
  enumerable: true,
  get: function () {
    return _definitions8.default;
  }
});
Object.defineProperty(exports, "contractsAbi", {
  enumerable: true,
  get: function () {
    return _definitions9.default;
  }
});
Object.defineProperty(exports, "democracy", {
  enumerable: true,
  get: function () {
    return _definitions10.default;
  }
});
Object.defineProperty(exports, "elections", {
  enumerable: true,
  get: function () {
    return _definitions11.default;
  }
});
Object.defineProperty(exports, "engine", {
  enumerable: true,
  get: function () {
    return _definitions12.default;
  }
});
Object.defineProperty(exports, "evm", {
  enumerable: true,
  get: function () {
    return _definitions13.default;
  }
});
Object.defineProperty(exports, "extrinsics", {
  enumerable: true,
  get: function () {
    return _definitions14.default;
  }
});
Object.defineProperty(exports, "genericAsset", {
  enumerable: true,
  get: function () {
    return _definitions15.default;
  }
});
Object.defineProperty(exports, "grandpa", {
  enumerable: true,
  get: function () {
    return _definitions16.default;
  }
});
Object.defineProperty(exports, "identity", {
  enumerable: true,
  get: function () {
    return _definitions17.default;
  }
});
Object.defineProperty(exports, "imOnline", {
  enumerable: true,
  get: function () {
    return _definitions18.default;
  }
});
Object.defineProperty(exports, "offences", {
  enumerable: true,
  get: function () {
    return _definitions19.default;
  }
});
Object.defineProperty(exports, "proxy", {
  enumerable: true,
  get: function () {
    return _definitions20.default;
  }
});
Object.defineProperty(exports, "recovery", {
  enumerable: true,
  get: function () {
    return _definitions21.default;
  }
});
Object.defineProperty(exports, "scheduler", {
  enumerable: true,
  get: function () {
    return _definitions22.default;
  }
});
Object.defineProperty(exports, "session", {
  enumerable: true,
  get: function () {
    return _definitions23.default;
  }
});
Object.defineProperty(exports, "society", {
  enumerable: true,
  get: function () {
    return _definitions24.default;
  }
});
Object.defineProperty(exports, "staking", {
  enumerable: true,
  get: function () {
    return _definitions25.default;
  }
});
Object.defineProperty(exports, "support", {
  enumerable: true,
  get: function () {
    return _definitions26.default;
  }
});
Object.defineProperty(exports, "system", {
  enumerable: true,
  get: function () {
    return _definitions27.default;
  }
});
Object.defineProperty(exports, "treasury", {
  enumerable: true,
  get: function () {
    return _definitions28.default;
  }
});
Object.defineProperty(exports, "txpayment", {
  enumerable: true,
  get: function () {
    return _definitions29.default;
  }
});
Object.defineProperty(exports, "utility", {
  enumerable: true,
  get: function () {
    return _definitions30.default;
  }
});
Object.defineProperty(exports, "vesting", {
  enumerable: true,
  get: function () {
    return _definitions31.default;
  }
});
Object.defineProperty(exports, "attestations", {
  enumerable: true,
  get: function () {
    return _definitions32.default;
  }
});
Object.defineProperty(exports, "claims", {
  enumerable: true,
  get: function () {
    return _definitions33.default;
  }
});
Object.defineProperty(exports, "parachains", {
  enumerable: true,
  get: function () {
    return _definitions34.default;
  }
});
Object.defineProperty(exports, "poll", {
  enumerable: true,
  get: function () {
    return _definitions35.default;
  }
});
Object.defineProperty(exports, "purchase", {
  enumerable: true,
  get: function () {
    return _definitions36.default;
  }
});
Object.defineProperty(exports, "ethereum", {
  enumerable: true,
  get: function () {
    return _definitions37.default;
  }
});
Object.defineProperty(exports, "metadata", {
  enumerable: true,
  get: function () {
    return _definitions38.default;
  }
});
Object.defineProperty(exports, "rpc", {
  enumerable: true,
  get: function () {
    return _definitions39.default;
  }
});
Object.defineProperty(exports, "author", {
  enumerable: true,
  get: function () {
    return _definitions40.default;
  }
});
Object.defineProperty(exports, "chain", {
  enumerable: true,
  get: function () {
    return _definitions41.default;
  }
});
Object.defineProperty(exports, "childstate", {
  enumerable: true,
  get: function () {
    return _definitions42.default;
  }
});
Object.defineProperty(exports, "offchain", {
  enumerable: true,
  get: function () {
    return _definitions43.default;
  }
});
Object.defineProperty(exports, "payment", {
  enumerable: true,
  get: function () {
    return _definitions44.default;
  }
});
Object.defineProperty(exports, "state", {
  enumerable: true,
  get: function () {
    return _definitions45.default;
  }
});

var _definitions = _interopRequireDefault(__webpack_require__(/*! ./runtime/definitions */ "../../node_modules/@polkadot/types/interfaces/runtime/definitions.js"));

var _definitions2 = _interopRequireDefault(__webpack_require__(/*! ./authorship/definitions */ "../../node_modules/@polkadot/types/interfaces/authorship/definitions.js"));

var _definitions3 = _interopRequireDefault(__webpack_require__(/*! ./aura/definitions */ "../../node_modules/@polkadot/types/interfaces/aura/definitions.js"));

var _definitions4 = _interopRequireDefault(__webpack_require__(/*! ./babe/definitions */ "../../node_modules/@polkadot/types/interfaces/babe/definitions.js"));

var _definitions5 = _interopRequireDefault(__webpack_require__(/*! ./balances/definitions */ "../../node_modules/@polkadot/types/interfaces/balances/definitions.js"));

var _definitions6 = _interopRequireDefault(__webpack_require__(/*! ./collective/definitions */ "../../node_modules/@polkadot/types/interfaces/collective/definitions.js"));

var _definitions7 = _interopRequireDefault(__webpack_require__(/*! ./consensus/definitions */ "../../node_modules/@polkadot/types/interfaces/consensus/definitions.js"));

var _definitions8 = _interopRequireDefault(__webpack_require__(/*! ./contracts/definitions */ "../../node_modules/@polkadot/types/interfaces/contracts/definitions.js"));

var _definitions9 = _interopRequireDefault(__webpack_require__(/*! ./contractsAbi/definitions */ "../../node_modules/@polkadot/types/interfaces/contractsAbi/definitions.js"));

var _definitions10 = _interopRequireDefault(__webpack_require__(/*! ./democracy/definitions */ "../../node_modules/@polkadot/types/interfaces/democracy/definitions.js"));

var _definitions11 = _interopRequireDefault(__webpack_require__(/*! ./elections/definitions */ "../../node_modules/@polkadot/types/interfaces/elections/definitions.js"));

var _definitions12 = _interopRequireDefault(__webpack_require__(/*! ./engine/definitions */ "../../node_modules/@polkadot/types/interfaces/engine/definitions.js"));

var _definitions13 = _interopRequireDefault(__webpack_require__(/*! ./evm/definitions */ "../../node_modules/@polkadot/types/interfaces/evm/definitions.js"));

var _definitions14 = _interopRequireDefault(__webpack_require__(/*! ./extrinsics/definitions */ "../../node_modules/@polkadot/types/interfaces/extrinsics/definitions.js"));

var _definitions15 = _interopRequireDefault(__webpack_require__(/*! ./genericAsset/definitions */ "../../node_modules/@polkadot/types/interfaces/genericAsset/definitions.js"));

var _definitions16 = _interopRequireDefault(__webpack_require__(/*! ./grandpa/definitions */ "../../node_modules/@polkadot/types/interfaces/grandpa/definitions.js"));

var _definitions17 = _interopRequireDefault(__webpack_require__(/*! ./identity/definitions */ "../../node_modules/@polkadot/types/interfaces/identity/definitions.js"));

var _definitions18 = _interopRequireDefault(__webpack_require__(/*! ./imOnline/definitions */ "../../node_modules/@polkadot/types/interfaces/imOnline/definitions.js"));

var _definitions19 = _interopRequireDefault(__webpack_require__(/*! ./offences/definitions */ "../../node_modules/@polkadot/types/interfaces/offences/definitions.js"));

var _definitions20 = _interopRequireDefault(__webpack_require__(/*! ./proxy/definitions */ "../../node_modules/@polkadot/types/interfaces/proxy/definitions.js"));

var _definitions21 = _interopRequireDefault(__webpack_require__(/*! ./recovery/definitions */ "../../node_modules/@polkadot/types/interfaces/recovery/definitions.js"));

var _definitions22 = _interopRequireDefault(__webpack_require__(/*! ./scheduler/definitions */ "../../node_modules/@polkadot/types/interfaces/scheduler/definitions.js"));

var _definitions23 = _interopRequireDefault(__webpack_require__(/*! ./session/definitions */ "../../node_modules/@polkadot/types/interfaces/session/definitions.js"));

var _definitions24 = _interopRequireDefault(__webpack_require__(/*! ./society/definitions */ "../../node_modules/@polkadot/types/interfaces/society/definitions.js"));

var _definitions25 = _interopRequireDefault(__webpack_require__(/*! ./staking/definitions */ "../../node_modules/@polkadot/types/interfaces/staking/definitions.js"));

var _definitions26 = _interopRequireDefault(__webpack_require__(/*! ./support/definitions */ "../../node_modules/@polkadot/types/interfaces/support/definitions.js"));

var _definitions27 = _interopRequireDefault(__webpack_require__(/*! ./system/definitions */ "../../node_modules/@polkadot/types/interfaces/system/definitions.js"));

var _definitions28 = _interopRequireDefault(__webpack_require__(/*! ./treasury/definitions */ "../../node_modules/@polkadot/types/interfaces/treasury/definitions.js"));

var _definitions29 = _interopRequireDefault(__webpack_require__(/*! ./txpayment/definitions */ "../../node_modules/@polkadot/types/interfaces/txpayment/definitions.js"));

var _definitions30 = _interopRequireDefault(__webpack_require__(/*! ./utility/definitions */ "../../node_modules/@polkadot/types/interfaces/utility/definitions.js"));

var _definitions31 = _interopRequireDefault(__webpack_require__(/*! ./vesting/definitions */ "../../node_modules/@polkadot/types/interfaces/vesting/definitions.js"));

var _definitions32 = _interopRequireDefault(__webpack_require__(/*! ./attestations/definitions */ "../../node_modules/@polkadot/types/interfaces/attestations/definitions.js"));

var _definitions33 = _interopRequireDefault(__webpack_require__(/*! ./claims/definitions */ "../../node_modules/@polkadot/types/interfaces/claims/definitions.js"));

var _definitions34 = _interopRequireDefault(__webpack_require__(/*! ./parachains/definitions */ "../../node_modules/@polkadot/types/interfaces/parachains/definitions.js"));

var _definitions35 = _interopRequireDefault(__webpack_require__(/*! ./poll/definitions */ "../../node_modules/@polkadot/types/interfaces/poll/definitions.js"));

var _definitions36 = _interopRequireDefault(__webpack_require__(/*! ./purchase/definitions */ "../../node_modules/@polkadot/types/interfaces/purchase/definitions.js"));

var _definitions37 = _interopRequireDefault(__webpack_require__(/*! ./ethereum/definitions */ "../../node_modules/@polkadot/types/interfaces/ethereum/definitions.js"));

var _definitions38 = _interopRequireDefault(__webpack_require__(/*! ./metadata/definitions */ "../../node_modules/@polkadot/types/interfaces/metadata/definitions.js"));

var _definitions39 = _interopRequireDefault(__webpack_require__(/*! ./rpc/definitions */ "../../node_modules/@polkadot/types/interfaces/rpc/definitions.js"));

var _definitions40 = _interopRequireDefault(__webpack_require__(/*! ./author/definitions */ "../../node_modules/@polkadot/types/interfaces/author/definitions.js"));

var _definitions41 = _interopRequireDefault(__webpack_require__(/*! ./chain/definitions */ "../../node_modules/@polkadot/types/interfaces/chain/definitions.js"));

var _definitions42 = _interopRequireDefault(__webpack_require__(/*! ./childstate/definitions */ "../../node_modules/@polkadot/types/interfaces/childstate/definitions.js"));

var _definitions43 = _interopRequireDefault(__webpack_require__(/*! ./offchain/definitions */ "../../node_modules/@polkadot/types/interfaces/offchain/definitions.js"));

var _definitions44 = _interopRequireDefault(__webpack_require__(/*! ./payment/definitions */ "../../node_modules/@polkadot/types/interfaces/payment/definitions.js"));

var _definitions45 = _interopRequireDefault(__webpack_require__(/*! ./state/definitions */ "../../node_modules/@polkadot/types/interfaces/state/definitions.js"));

/***/ }),

/***/ "../../node_modules/@polkadot/types/interfaces/democracy/definitions.js":
/*!***********************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/interfaces/democracy/definitions.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.AllConvictions = void 0;
// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)

/* eslint-disable sort-keys */
const AllConvictions = [// 0.1x votes, unlocked.
'None', // 1x votes, locked for an enactment period following a successful vote.
'Locked1x', // 2x votes, locked for 2x enactment periods following a successful vote.
'Locked2x', // 3x votes, locked for 4x...
'Locked3x', // 4x votes, locked for 8x...
'Locked4x', // 5x votes, locked for 16x...
'Locked5x', /// 6x votes, locked for 32x...
'Locked6x'];
exports.AllConvictions = AllConvictions;
var _default = {
  rpc: {},
  types: {
    AccountVote: {
      _enum: {
        Standard: 'AccountVoteStandard',
        Split: 'AccountVoteSplit'
      }
    },
    AccountVoteSplit: {
      aye: 'Balance',
      nay: 'Balance'
    },
    AccountVoteStandard: {
      vote: 'Vote',
      balance: 'Balance'
    },
    Conviction: {
      _enum: AllConvictions
    },
    Delegations: {
      votes: 'Balance',
      capital: 'Balance'
    },
    PreimageStatus: {
      _enum: {
        Missing: 'BlockNumber',
        Available: 'PreimageStatusAvailable'
      }
    },
    PreimageStatusAvailable: {
      data: 'Bytes',
      provider: 'AccountId',
      deposit: 'Balance',
      since: 'BlockNumber',
      expiry: 'Option<BlockNumber>'
    },
    PriorLock: '(BlockNumber, Balance)',
    PropIndex: 'u32',
    Proposal: 'Call',
    ProxyState: {
      _enum: {
        Open: 'AccountId',
        Active: 'AccountId'
      }
    },
    ReferendumIndex: 'u32',
    ReferendumInfoTo239: {
      end: 'BlockNumber',
      proposalHash: 'Hash',
      threshold: 'VoteThreshold',
      delay: 'BlockNumber'
    },
    ReferendumInfo: {
      _enum: {
        Ongoing: 'ReferendumStatus',
        Finished: 'ReferendumInfoFinished'
      }
    },
    ReferendumInfoFinished: {
      approved: 'bool',
      end: 'BlockNumber'
    },
    ReferendumStatus: {
      end: 'BlockNumber',
      proposalHash: 'Hash',
      threshold: 'VoteThreshold',
      delay: 'BlockNumber',
      tally: 'Tally'
    },
    Tally: {
      ayes: 'Balance',
      nays: 'Balance',
      turnout: 'Balance'
    },
    Voting: {
      _enum: {
        Direct: 'VotingDirect',
        Delegating: 'VotingDelegating'
      }
    },
    VotingDirect: {
      votes: 'Vec<VotingDirectVote>',
      delegations: 'Delegations',
      prior: 'PriorLock'
    },
    VotingDirectVote: '(ReferendumIndex, AccountVote)',
    VotingDelegating: {
      balance: 'Balance',
      target: 'AccountId',
      conviction: 'Conviction',
      delegations: 'Delegations',
      prior: 'PriorLock'
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types/interfaces/elections/definitions.js":
/*!***********************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/interfaces/elections/definitions.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)

/* eslint-disable sort-keys */
var _default = {
  rpc: {},
  types: {
    ApprovalFlag: 'u32',
    DefunctVoter: {
      who: 'AccountId',
      voteCount: 'Compact<u32>',
      candidateCount: 'Compact<u32>'
    },
    Renouncing: {
      _enum: {
        Member: 'Null',
        RunnerUp: 'Null',
        Candidate: 'Compact<u32>'
      }
    },
    SetIndex: 'u32',
    Vote: 'GenericVote',
    VoteIndex: 'u32',
    VoterInfo: {
      lastActive: 'VoteIndex',
      lastWin: 'VoteIndex',
      pot: 'Balance',
      stake: 'Balance'
    },
    VoteThreshold: {
      _enum: ['Super majority approval', 'Super majority rejection', 'Simple majority']
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types/interfaces/engine/definitions.js":
/*!********************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/interfaces/engine/definitions.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)

/* eslint-disable sort-keys */
var _default = {
  rpc: {
    createBlock: {
      description: 'Instructs the manual-seal authorship task to create a new block',
      params: [{
        name: 'createEmpty',
        type: 'bool'
      }, {
        name: 'finalize',
        type: 'bool'
      }, {
        name: 'parentHash',
        type: 'BlockHash',
        isOptional: true
      }],
      type: 'CreatedBlock'
    },
    finalizeBlock: {
      description: 'Instructs the manual-seal authorship task to finalize a block',
      params: [{
        name: 'hash',
        type: 'BlockHash'
      }, {
        name: 'justification',
        type: 'Justification',
        isOptional: true
      }],
      type: 'bool'
    }
  },
  types: {
    CreatedBlock: {
      hash: 'BlockHash',
      aux: 'ImportedAux'
    },
    ImportedAux: {
      headerOnly: 'bool',
      clearJustificationRequests: 'bool',
      needsJustification: 'bool',
      badJustification: 'bool',
      needsFinalityProof: 'bool',
      isNewBest: 'bool'
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types/interfaces/ethereum/definitions.js":
/*!**********************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/interfaces/ethereum/definitions.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)

/* eslint-disable sort-keys */
var _default = {
  rpc: {},
  types: {
    EthereumAccountId: 'GenericEthereumAccountId',
    EthereumLookupSource: 'GenericEthereumLookupSource'
  }
};
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types/interfaces/evm/definitions.js":
/*!*****************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/interfaces/evm/definitions.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)

/* eslint-disable sort-keys */
var _default = {
  rpc: {},
  types: {
    Account: {
      nonce: 'U256',
      balance: 'U256'
    },
    Log: {
      address: 'H160',
      topics: 'Vec<H256>',
      data: 'Bytes'
    },
    Vicinity: {
      gasPrice: 'U256',
      origin: 'H160'
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types/interfaces/extrinsics/definitions.js":
/*!************************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/interfaces/extrinsics/definitions.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)

/* eslint-disable sort-keys */
var _default = {
  rpc: {},
  types: {
    Extrinsic: 'GenericExtrinsic',
    ExtrinsicEra: 'GenericExtrinsicEra',
    ExtrinsicPayload: 'GenericExtrinsicPayload',
    ExtrinsicV4: 'GenericExtrinsicV4',
    ExtrinsicPayloadV4: 'GenericExtrinsicPayloadV4',
    ExtrinsicSignatureV4: 'GenericExtrinsicSignatureV4',
    ExtrinsicUnknown: 'GenericExtrinsicUnknown',
    ExtrinsicPayloadUnknown: 'GenericExtrinsicPayloadUnknown',
    // eras
    ImmortalEra: 'GenericImmortalEra',
    MortalEra: 'GenericMortalEra',
    // signatures & signer
    MultiSignature: {
      _enum: {
        Ed25519: 'Ed25519Signature',
        Sr25519: 'Sr25519Signature',
        Ecdsa: 'EcdsaSignature'
      }
    },
    Signature: 'H512',
    SignerPayload: 'GenericSignerPayload',
    EcdsaSignature: '[u8; 65]',
    Ed25519Signature: 'H512',
    Sr25519Signature: 'H512'
  }
};
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types/interfaces/genericAsset/definitions.js":
/*!**************************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/interfaces/genericAsset/definitions.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)

/* eslint-disable sort-keys */
var _default = {
  rpc: {},
  types: {
    AssetOptions: {
      initalIssuance: 'Compact<Balance>',
      permissions: 'PermissionLatest'
    },
    Owner: {
      _enum: {
        None: 'Null',
        Address: 'AccountId'
      }
    },
    PermissionsV1: {
      update: 'Owner',
      mint: 'Owner',
      burn: 'Owner'
    },
    PermissionVersions: {
      _enum: {
        V1: 'PermissionsV1'
      }
    },
    PermissionLatest: 'PermissionsV1'
  }
};
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types/interfaces/grandpa/definitions.js":
/*!*********************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/interfaces/grandpa/definitions.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)

/* eslint-disable sort-keys */
var _default = {
  rpc: {
    proveFinality: {
      description: 'Prove finality for the range (begin; end] hash.',
      params: [{
        name: 'begin',
        type: 'BlockHash'
      }, {
        name: 'end',
        type: 'BlockHash'
      }, {
        name: 'authoritiesSetId',
        type: 'u64',
        isOptional: true
      }],
      type: 'Option<EncodedFinalityProofs>'
    },
    roundState: {
      description: 'Returns the state of the current best round state as well as the ongoing background rounds',
      params: [],
      type: 'ReportedRoundStates'
    },
    subscribeJustifications: {
      description: 'Subscribes to grandpa justifications',
      params: [],
      pubsub: ['justifications', 'subscribeJustifications', 'unsubscribeJustifications'],
      type: 'JustificationNotification'
    }
  },
  types: {
    AuthorityIndex: 'u64',
    AuthorityList: 'Vec<NextAuthority>',
    AuthorityWeight: 'u64',
    EncodedFinalityProofs: 'Bytes',
    GrandpaEquivocation: {
      _enum: {
        Prevote: 'GrandpaEquivocationValue',
        Precommit: 'GrandpaEquivocationValue'
      }
    },
    GrandpaEquivocationProof: {
      setId: 'SetId',
      equivocation: 'GrandpaEquivocation'
    },
    GrandpaEquivocationValue: {
      roundNumber: 'u64',
      identity: 'AuthorityId',
      first: '(GrandpaPrevote, AuthoritySignature)',
      second: '(GrandpaPrevote, AuthoritySignature)'
    },
    GrandpaPrevote: {
      targetHash: 'Hash',
      targetNumber: 'BlockNumber'
    },
    JustificationNotification: 'Bytes',
    KeyOwnerProof: 'MembershipProof',
    NextAuthority: '(AuthorityId, AuthorityWeight)',
    PendingPause: {
      /// Block at which the intention to pause was scheduled.
      scheduledAt: 'BlockNumber',
      /// Number of blocks after which the change will be enacted.
      delay: 'BlockNumber'
    },
    PendingResume: {
      /// Block at which the intention to resume was scheduled.
      scheduledAt: 'BlockNumber',
      /// Number of blocks after which the change will be enacted.
      delay: 'BlockNumber'
    },
    Precommits: {
      currentWeight: 'u32',
      missing: 'BTreeSet<AuthorityId>'
    },
    Prevotes: {
      currentWeight: 'u32',
      missing: 'BTreeSet<AuthorityId>'
    },
    ReportedRoundStates: {
      setId: 'u32',
      best: 'RoundState',
      background: 'Vec<RoundState>'
    },
    RoundState: {
      round: 'u32',
      totalWeight: 'u32',
      thresholdWeight: 'u32',
      prevotes: 'Prevotes',
      precommits: 'Precommits'
    },
    SetId: 'u64',
    StoredPendingChange: {
      scheduledAt: 'BlockNumber',
      delay: 'BlockNumber',
      nextAuthorities: 'AuthorityList'
    },
    StoredState: {
      _enum: {
        /// The current authority set is live, and GRANDPA is enabled.
        Live: 'Null',
        /// There is a pending pause event which will be enacted at the given block height.
        PendingPause: 'PendingPause',
        /// The current GRANDPA authority set is paused.
        Paused: 'Null',
        /// There is a pending resume event which will be enacted at the given block height.
        PendingResume: 'PendingResume'
      }
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types/interfaces/identity/definitions.js":
/*!**********************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/interfaces/identity/definitions.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)

/* eslint-disable sort-keys */
var _default = {
  rpc: {},
  types: {
    IdentityFields: {
      _set: {
        _bitLength: 64,
        // Mapped here to 32 bits, in Rust these are 64-bit values
        Display: 0b00000000000000000000000000000001,
        Legal: 0b00000000000000000000000000000010,
        Web: 0b00000000000000000000000000000100,
        Riot: 0b00000000000000000000000000001000,
        Email: 0b00000000000000000000000000010000,
        PgpFingerprint: 0b00000000000000000000000000100000,
        Image: 0b00000000000000000000000001000000,
        Twitter: 0b00000000000000000000000010000000
      }
    },
    IdentityInfoAdditional: '(Data, Data)',
    IdentityInfo: {
      additional: 'Vec<IdentityInfoAdditional>',
      display: 'Data',
      legal: 'Data',
      web: 'Data',
      riot: 'Data',
      email: 'Data',
      pgpFingerprint: 'Option<H160>',
      image: 'Data',
      twitter: 'Data'
    },
    IdentityJudgement: {
      _enum: {
        Unknown: 'Null',
        FeePaid: 'Balance',
        Reasonable: 'Null',
        KnownGood: 'Null',
        OutOfDate: 'Null',
        LowQuality: 'Null',
        Erroneous: 'Null'
      }
    },
    RegistrationJudgement: '(RegistrarIndex, IdentityJudgement)',
    Registration: {
      judgements: 'Vec<RegistrationJudgement>',
      deposit: 'Balance',
      info: 'IdentityInfo'
    },
    RegistrarIndex: 'u32',
    RegistrarInfo: {
      account: 'AccountId',
      fee: 'Balance',
      fields: 'IdentityFields'
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types/interfaces/imOnline/definitions.js":
/*!**********************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/interfaces/imOnline/definitions.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)

/* eslint-disable sort-keys */
var _default = {
  rpc: {},
  types: {
    AuthIndex: 'u32',
    AuthoritySignature: 'Signature',
    Heartbeat: {
      blockNumber: 'BlockNumber',
      networkState: 'OpaqueNetworkState',
      sessionIndex: 'SessionIndex',
      authorityIndex: 'AuthIndex',
      validatorsLen: 'u32'
    },
    HeartbeatTo244: {
      blockNumber: 'BlockNumber',
      networkState: 'OpaqueNetworkState',
      sessionIndex: 'SessionIndex',
      authorityIndex: 'AuthIndex'
    },
    OpaqueMultiaddr: 'Bytes',
    OpaquePeerId: 'Bytes',
    OpaqueNetworkState: {
      peerId: 'OpaquePeerId',
      externalAddresses: 'Vec<OpaqueMultiaddr>'
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types/interfaces/jsonrpc.js":
/*!*********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/interfaces/jsonrpc.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "../../node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js"));

var definitions = _interopRequireWildcard(__webpack_require__(/*! ./definitions */ "../../node_modules/@polkadot/types/interfaces/definitions.js"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const jsonrpc = {};
Object.keys(definitions).filter(key => Object.keys(definitions[key].rpc || {}).length !== 0).forEach(section => {
  jsonrpc[section] = {};
  Object.entries(definitions[section].rpc).forEach(([method, def]) => {
    const isSubscription = !!def.pubsub;
    jsonrpc[section][method] = _objectSpread(_objectSpread({}, def), {}, {
      isSubscription,
      jsonrpc: `${section}_${method}`,
      method,
      section
    });
  });
});
var _default = jsonrpc;
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types/interfaces/metadata/definitions.js":
/*!**********************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/interfaces/metadata/definitions.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.AllHashers = void 0;
// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)

/* eslint-disable sort-keys */
const AllHashers = {
  Blake2_128: null,
  // eslint-disable-line camelcase
  Blake2_256: null,
  // eslint-disable-line camelcase
  Blake2_128Concat: null,
  // eslint-disable-line camelcase
  Twox128: null,
  Twox256: null,
  Twox64Concat: null,
  // new in v11
  Identity: null
};
exports.AllHashers = AllHashers;
var _default = {
  rpc: {},
  types: {
    // v9
    DoubleMapTypeV9: {
      hasher: 'StorageHasherV9',
      key1: 'Type',
      key2: 'Type',
      value: 'Type',
      key2Hasher: 'StorageHasherV9'
    },
    ErrorMetadataV9: {
      name: 'Text',
      documentation: 'Vec<Text>'
    },
    EventMetadataV9: {
      name: 'Text',
      args: 'Vec<Type>',
      documentation: 'Vec<Text>'
    },
    FunctionArgumentMetadataV9: {
      name: 'Text',
      type: 'Type'
    },
    FunctionMetadataV9: {
      name: 'Text',
      args: 'Vec<FunctionArgumentMetadataV9>',
      documentation: 'Vec<Text>'
    },
    MapTypeV9: {
      hasher: 'StorageHasherV9',
      key: 'Type',
      value: 'Type',
      linked: 'bool'
    },
    MetadataV9: {
      modules: 'Vec<ModuleMetadataV9>'
    },
    ModuleConstantMetadataV9: {
      name: 'Text',
      type: 'Type',
      value: 'Bytes',
      documentation: 'Vec<Text>'
    },
    ModuleMetadataV9: {
      name: 'Text',
      storage: 'Option<StorageMetadataV9>',
      calls: 'Option<Vec<FunctionMetadataV9>>',
      events: 'Option<Vec<EventMetadataV9>>',
      constants: 'Vec<ModuleConstantMetadataV9>',
      errors: 'Vec<ErrorMetadataV9>'
    },
    StorageEntryMetadataV9: {
      name: 'Text',
      modifier: 'StorageEntryModifierV9',
      type: 'StorageEntryTypeV9',
      fallback: 'Bytes',
      documentation: 'Vec<Text>'
    },
    StorageEntryModifierV9: {
      _enum: ['Optional', 'Default', 'Required']
    },
    StorageEntryTypeV9: {
      _enum: {
        Plain: 'Type',
        Map: 'MapTypeV9',
        DoubleMap: 'DoubleMapTypeV9'
      }
    },
    StorageHasherV9: {
      _enum: {
        Blake2_128: null,
        // eslint-disable-line camelcase
        Blake2_256: null,
        // eslint-disable-line camelcase
        Twox128: null,
        Twox256: null,
        Twox64Concat: null
      }
    },
    StorageMetadataV9: {
      prefix: 'Text',
      items: 'Vec<StorageEntryMetadataV9>'
    },
    // v10
    DoubleMapTypeV10: {
      hasher: 'StorageHasherV10',
      key1: 'Type',
      key2: 'Type',
      value: 'Type',
      key2Hasher: 'StorageHasherV10'
    },
    ErrorMetadataV10: 'ErrorMetadataV9',
    EventMetadataV10: 'EventMetadataV9',
    FunctionArgumentMetadataV10: 'FunctionArgumentMetadataV9',
    FunctionMetadataV10: 'FunctionMetadataV9',
    MapTypeV10: {
      hasher: 'StorageHasherV10',
      key: 'Type',
      value: 'Type',
      linked: 'bool'
    },
    MetadataV10: {
      modules: 'Vec<ModuleMetadataV10>'
    },
    ModuleConstantMetadataV10: 'ModuleConstantMetadataV9',
    ModuleMetadataV10: {
      name: 'Text',
      storage: 'Option<StorageMetadataV10>',
      calls: 'Option<Vec<FunctionMetadataV10>>',
      events: 'Option<Vec<EventMetadataV10>>',
      constants: 'Vec<ModuleConstantMetadataV10>',
      errors: 'Vec<ErrorMetadataV10>'
    },
    StorageEntryModifierV10: 'StorageEntryModifierV9',
    StorageEntryMetadataV10: {
      name: 'Text',
      modifier: 'StorageEntryModifierV10',
      type: 'StorageEntryTypeV10',
      fallback: 'Bytes',
      documentation: 'Vec<Text>'
    },
    StorageEntryTypeV10: {
      _enum: {
        Plain: 'Type',
        Map: 'MapTypeV10',
        DoubleMap: 'DoubleMapTypeV10'
      }
    },
    StorageMetadataV10: {
      prefix: 'Text',
      items: 'Vec<StorageEntryMetadataV10>'
    },
    StorageHasherV10: {
      _enum: {
        Blake2_128: null,
        // eslint-disable-line camelcase
        Blake2_256: null,
        // eslint-disable-line camelcase
        Blake2_128Concat: null,
        // eslint-disable-line camelcase
        Twox128: null,
        Twox256: null,
        Twox64Concat: null
      }
    },
    // v11
    DoubleMapTypeV11: {
      hasher: 'StorageHasherV11',
      key1: 'Type',
      key2: 'Type',
      value: 'Type',
      key2Hasher: 'StorageHasherV11'
    },
    ErrorMetadataV11: 'ErrorMetadataV10',
    EventMetadataV11: 'EventMetadataV10',
    ExtrinsicMetadataV11: {
      version: 'u8',
      signedExtensions: 'Vec<Text>'
    },
    FunctionArgumentMetadataV11: 'FunctionArgumentMetadataV10',
    FunctionMetadataV11: 'FunctionMetadataV10',
    MapTypeV11: {
      hasher: 'StorageHasherV11',
      key: 'Type',
      value: 'Type',
      linked: 'bool'
    },
    MetadataV11: {
      modules: 'Vec<ModuleMetadataV11>',
      extrinsic: 'ExtrinsicMetadataV11'
    },
    ModuleConstantMetadataV11: 'ModuleConstantMetadataV10',
    ModuleMetadataV11: {
      name: 'Text',
      storage: 'Option<StorageMetadataV11>',
      calls: 'Option<Vec<FunctionMetadataV11>>',
      events: 'Option<Vec<EventMetadataV11>>',
      constants: 'Vec<ModuleConstantMetadataV11>',
      errors: 'Vec<ErrorMetadataV11>'
    },
    StorageEntryModifierV11: 'StorageEntryModifierV10',
    StorageEntryMetadataV11: {
      name: 'Text',
      modifier: 'StorageEntryModifierV11',
      type: 'StorageEntryTypeV11',
      fallback: 'Bytes',
      documentation: 'Vec<Text>'
    },
    StorageEntryTypeV11: {
      _enum: {
        Plain: 'Type',
        Map: 'MapTypeV11',
        DoubleMap: 'DoubleMapTypeV11'
      }
    },
    StorageMetadataV11: {
      prefix: 'Text',
      items: 'Vec<StorageEntryMetadataV11>'
    },
    StorageHasherV11: {
      _enum: AllHashers
    },
    // v12
    DoubleMapTypeV12: 'DoubleMapTypeV11',
    ErrorMetadataV12: 'ErrorMetadataV11',
    EventMetadataV12: 'EventMetadataV11',
    ExtrinsicMetadataV12: 'ExtrinsicMetadataV11',
    FunctionArgumentMetadataV12: 'FunctionArgumentMetadataV11',
    FunctionMetadataV12: 'FunctionMetadataV11',
    MapTypeV12: 'MapTypeV11',
    MetadataV12: {
      modules: 'Vec<ModuleMetadataV12>',
      extrinsic: 'ExtrinsicMetadataV12'
    },
    ModuleConstantMetadataV12: 'ModuleConstantMetadataV11',
    ModuleMetadataV12: {
      name: 'Text',
      storage: 'Option<StorageMetadataV12>',
      calls: 'Option<Vec<FunctionMetadataV12>>',
      events: 'Option<Vec<EventMetadataV12>>',
      constants: 'Vec<ModuleConstantMetadataV12>',
      errors: 'Vec<ErrorMetadataV12>',
      index: 'u8'
    },
    StorageEntryModifierV12: 'StorageEntryModifierV11',
    StorageEntryMetadataV12: 'StorageEntryMetadataV11',
    StorageEntryTypeV12: 'StorageEntryTypeV11',
    StorageMetadataV12: 'StorageMetadataV11',
    StorageHasherV12: 'StorageHasherV11',
    // This always maps to the latest
    DoubleMapTypeLatest: 'DoubleMapTypeV12',
    EventMetadataLatest: 'EventMetadataV12',
    ExtrinsicMetadataLatest: 'ExtrinsicMetadataV12',
    FunctionArgumentMetadataLatest: 'FunctionArgumentMetadataV12',
    FunctionMetadataLatest: 'FunctionMetadataV12',
    MapTypeLatest: 'MapTypeV12',
    MetadataLatest: 'MetadataV12',
    ModuleConstantMetadataLatest: 'ModuleConstantMetadataV12',
    ModuleMetadataLatest: 'ModuleMetadataV12',
    StorageEntryMetadataLatest: 'StorageEntryMetadataV12',
    StorageEntryModifierLatest: 'StorageEntryModifierV12',
    StorageEntryTypeLatest: 'StorageEntryTypeV12',
    StorageMetadataLatest: 'StorageMetadataV12',
    StorageHasher: 'StorageHasherV12',
    // the enum containing all the mappings
    MetadataAll: {
      _enum: {
        V0: 'DoNotConstruct<MetadataV0>',
        V1: 'DoNotConstruct<MetadataV1>',
        V2: 'DoNotConstruct<MetadataV2>',
        V3: 'DoNotConstruct<MetadataV3>',
        V4: 'DoNotConstruct<MetadataV4>',
        V5: 'DoNotConstruct<MetadataV5>',
        V6: 'DoNotConstruct<MetadataV6>',
        V7: 'DoNotConstruct<MetadataV7>',
        V8: 'DoNotConstruct<MetadataV8>',
        // First version on Kusama in V9, dropping will be problematic
        V9: 'MetadataV9',
        V10: 'MetadataV10',
        V11: 'MetadataV11',
        V12: 'MetadataV12'
      }
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types/interfaces/offchain/definitions.js":
/*!**********************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/interfaces/offchain/definitions.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)

/* eslint-disable sort-keys */
var _default = {
  rpc: {
    localStorageSet: {
      description: 'Set offchain local storage under given key and prefix',
      params: [{
        name: 'kind',
        type: 'StorageKind'
      }, {
        name: 'key',
        type: 'Bytes'
      }, {
        name: 'value',
        type: 'Bytes'
      }],
      type: 'Null'
    },
    localStorageGet: {
      description: 'Get offchain local storage under given key and prefix',
      params: [{
        name: 'kind',
        type: 'StorageKind'
      }, {
        name: 'key',
        type: 'Bytes'
      }],
      type: 'Option<Bytes>'
    }
  },
  types: {
    StorageKind: {
      _enum: ['__UNUSED', 'PERSISTENT', 'LOCAL']
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types/interfaces/offences/definitions.js":
/*!**********************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/interfaces/offences/definitions.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)

/* eslint-disable sort-keys */
var _default = {
  rpc: {},
  types: {
    DeferredOffenceOf: '(Vec<OffenceDetails>, Vec<Perbill>, SessionIndex)',
    Kind: '[u8; 16]',
    OffenceDetails: {
      offender: 'Offender',
      reporters: 'Vec<Reporter>'
    },
    Offender: 'IdentificationTuple',
    OpaqueTimeSlot: 'Bytes',
    ReportIdOf: 'Hash',
    Reporter: 'AccountId'
  }
};
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types/interfaces/parachains/definitions.js":
/*!************************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/interfaces/parachains/definitions.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)

/* eslint-disable sort-keys */
const SLOT_RANGE_COUNT = 10;
const proposeTypes = {
  ParachainProposal: {
    proposer: 'AccountId',
    validationFunction: 'ValidationCode',
    initialHeadState: 'HeadData',
    validators: 'Vec<ValidatorId>',
    name: 'Vec<u8>',
    balance: 'Balance'
  },
  RegisteredParachainInfo: {
    validators: 'Vec<ValidatorId>',
    proposer: 'AccountId'
  }
};
var _default = {
  rpc: {},
  types: _objectSpread(_objectSpread({}, proposeTypes), {}, {
    AbridgedCandidateReceipt: {
      parachainIndex: 'ParaId',
      relayParent: 'Hash',
      headData: 'HeadData',
      collator: 'CollatorId',
      signature: 'CollatorSignature',
      povBlockHash: 'Hash',
      commitments: 'CandidateCommitments'
    },
    AttestedCandidate: {
      candidate: 'AbridgedCandidateReceipt',
      validityVotes: 'Vec<ValidityAttestation>',
      validatorIndices: 'BitVec'
    },
    AuctionIndex: 'u32',
    Bidder: {
      _enum: {
        New: 'NewBidder',
        Existing: 'ParaId'
      }
    },
    CandidateCommitments: {
      fees: 'Balance',
      upwardMessages: 'Vec<UpwardMessage>',
      erasureRoot: 'Hash',
      newValidationCode: 'Option<ValidationCode>',
      processedDownwardMessages: 'u32'
    },
    CandidateReceipt: {
      parachainIndex: 'ParaId',
      relayParent: 'Hash',
      head_data: 'HeadData',
      collator: 'CollatorId',
      signature: 'CollatorSignature',
      povBlockHash: 'Hash',
      globalValidation: 'GlobalValidationSchedule',
      localValidation: 'LocalValidationData',
      commitments: 'CandidateCommitments'
    },
    CollatorId: '[u8; 32]',
    CollatorSignature: 'Signature',
    DoubleVoteReport: {
      identity: 'ValidatorId',
      first: '(Statement, ValidatorSignature)',
      second: '(Statement, ValidatorSignature)',
      proof: 'MembershipProof',
      signingContext: 'SigningContext'
    },
    DownwardMessage: {
      _enum: {
        TransferInto: '(AccountId, Balance, Remark)',
        Opaque: 'Vec<u8>'
      }
    },
    GlobalValidationSchedule: {
      maxCodeSize: 'u32',
      maxHeadDataSize: 'u32',
      blockNumber: 'BlockNumber'
    },
    HeadData: 'Bytes',
    IncomingParachain: {
      _enum: {
        Unset: 'NewBidder',
        Fixed: 'IncomingParachainFixed',
        Deploy: 'IncomingParachainDeploy'
      }
    },
    IncomingParachainFixed: {
      codeHash: 'Hash',
      codeSize: 'u32',
      initialHeadData: 'HeadData'
    },
    IncomingParachainDeploy: {
      code: 'ValidationCode',
      initialHeadData: 'HeadData'
    },
    LeasePeriod: 'BlockNumber',
    LeasePeriodOf: 'LeasePeriod',
    LocalValidationData: {
      parentHead: 'HeadData',
      balance: 'Balance',
      codeUpgradeAllowed: 'Option<BlockNumber>'
    },
    NewBidder: {
      who: 'AccountId',
      sub: 'SubId'
    },
    ParachainDispatchOrigin: {
      _enum: ['Signed', 'Parachain', 'Root']
    },
    ParaId: 'u32',
    ParaInfo: {
      scheduling: 'Scheduling'
    },
    ParaPastCodeMeta: {
      upgradeTimes: 'Vec<BlockNumber>',
      lastPruned: 'Option<BlockNumber>'
    },
    ParaScheduling: {
      _enum: ['Always', 'Dynamic']
    },
    RelayChainBlockNumber: 'BlockNumber',
    Remark: '[u8; 32]',
    Retriable: {
      _enum: {
        Never: 'Null',
        WithRetries: 'u32'
      }
    },
    Scheduling: {
      _enum: ['Always', 'Dynamic']
    },
    SigningContext: {
      sessionIndex: 'SessionIndex',
      parentHash: 'Hash'
    },
    SlotRange: {
      _enum: ['ZeroZero', 'ZeroOne', 'ZeroTwo', 'ZeroThree', 'OneOne', 'OneTwo', 'OneThree', 'TwoTwo', 'TwoThree', 'ThreeThree']
    },
    Statement: {
      _enum: {
        Never: 'Null',
        // starts at 1
        Candidate: 'Hash',
        Valid: 'Hash',
        Invalid: 'Hash'
      }
    },
    SubId: 'u32',
    UpwardMessage: {
      origin: 'ParachainDispatchOrigin',
      data: 'Vec<u8>'
    },
    ValidationFunctionParams: {
      maxCodeSize: 'u32',
      relayChainHeight: 'RelayChainBlockNumber',
      codeUpgradeAllowed: 'Option<RelayChainBlockNumber>'
    },
    ValidationCode: 'Bytes',
    ValidatorSignature: 'Signature',
    ValidityAttestation: {
      _enum: {
        Never: 'Null',
        // starts at 1
        Implicit: 'ValidatorSignature',
        Explicit: 'ValidatorSignature'
      }
    },
    WinningData: `[WinningDataEntry; ${SLOT_RANGE_COUNT}]`,
    WinningDataEntry: 'Option<Bidder>'
  })
};
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types/interfaces/payment/definitions.js":
/*!*********************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/interfaces/payment/definitions.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)

/* eslint-disable sort-keys */
var _default = {
  rpc: {
    queryInfo: {
      description: 'Retrieves the fee information for an encoded extrinsic',
      params: [{
        name: 'extrinsic',
        type: 'Bytes'
      }, {
        name: 'at',
        type: 'BlockHash',
        isHistoric: true,
        isOptional: true
      }],
      type: 'RuntimeDispatchInfo'
    }
  },
  types: {
    RuntimeDispatchInfo: {
      weight: 'Weight',
      class: 'DispatchClass',
      partialFee: 'Balance'
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types/interfaces/poll/definitions.js":
/*!******************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/interfaces/poll/definitions.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)

/* eslint-disable sort-keys */
var _default = {
  rpc: {},
  types: {
    Approvals: '[bool; 4]'
  }
};
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types/interfaces/proxy/definitions.js":
/*!*******************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/interfaces/proxy/definitions.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)

/* eslint-disable sort-keys */
var _default = {
  rpc: {},
  types: {
    ProxyDefinition: {
      delegate: 'AccountId',
      proxyType: 'ProxyType',
      delay: 'BlockNumber'
    },
    ProxyType: {
      _enum: ['Any', 'NonTransfer', 'Governance', 'Staking']
    },
    ProxyAnnouncement: {
      real: 'AccountId',
      callHash: 'Hash',
      height: 'BlockNumber'
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types/interfaces/purchase/definitions.js":
/*!**********************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/interfaces/purchase/definitions.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)

/* eslint-disable sort-keys */
var _default = {
  rpc: {},
  types: {
    AccountStatus: {
      validity: 'AccountValidity',
      freeBalance: 'Balance',
      lockedBalance: 'Balance',
      signature: 'Vec<u8>',
      vat: 'Permill'
    },
    AccountValidity: {
      _enum: ['Invalid', 'Initiated', 'Pending', 'ValidLow', 'ValidHigh', 'Completed']
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types/interfaces/recovery/definitions.js":
/*!**********************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/interfaces/recovery/definitions.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)

/* eslint-disable sort-keys */
var _default = {
  rpc: {},
  types: {
    ActiveRecovery: {
      created: 'BlockNumber',
      deposit: 'Balance',
      friends: 'Vec<AccountId>'
    },
    RecoveryConfig: {
      delayPeriod: 'BlockNumber',
      deposit: 'Balance',
      friends: 'Vec<AccountId>',
      threshold: 'u16'
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types/interfaces/rpc/definitions.js":
/*!*****************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/interfaces/rpc/definitions.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)

/* eslint-disable sort-keys */
var _default = {
  rpc: {
    methods: {
      description: 'Retrieves the list of RPC methods that are exposed by the node',
      params: [],
      type: 'RpcMethods'
    }
  },
  types: {
    RpcMethods: {
      version: 'u32',
      methods: 'Vec<Text>'
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types/interfaces/runtime/definitions.js":
/*!*********************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/interfaces/runtime/definitions.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)

/* eslint-disable sort-keys */
const numberTypes = {
  Fixed64: 'Int<64, Fixed64>',
  FixedI64: 'Int<64, FixedI64>',
  FixedU64: 'UInt<64, FixedU64>',
  Fixed128: 'Int<128, Fixed128>',
  FixedI128: 'Int<128, FixedI128>',
  FixedU128: 'UInt<128, FixedU128>',
  I32F32: 'Int<64, I32F32>',
  U32F32: 'UInt<64, U32F32>',
  PerU16: 'UInt<16, PerU16>',
  Perbill: 'UInt<32, Perbill>',
  Percent: 'UInt<8, Percent>',
  Permill: 'UInt<32, Permill>',
  Perquintill: 'UInt<64, Perquintill>'
};
var _default = {
  rpc: {},
  types: _objectSpread(_objectSpread({}, numberTypes), {}, {
    AccountId: 'GenericAccountId',
    AccountIdOf: 'AccountId',
    AccountIndex: 'GenericAccountIndex',
    Address: 'GenericAddress',
    AssetId: 'u32',
    Balance: 'UInt<128, Balance>',
    BalanceOf: 'Balance',
    Block: 'GenericBlock',
    BlockNumber: 'u32',
    Call: 'GenericCall',
    CallHash: 'Hash',
    CallHashOf: 'CallHash',
    ChangesTrieConfiguration: {
      digestInterval: 'u32',
      digestLevels: 'u32'
    },
    ConsensusEngineId: 'GenericConsensusEngineId',
    Digest: {
      logs: 'Vec<DigestItem>'
    },
    DigestItem: {
      _enum: {
        Other: 'Bytes',
        // 0
        AuthoritiesChange: 'Vec<AuthorityId>',
        // 1
        ChangesTrieRoot: 'Hash',
        // 2
        SealV0: 'SealV0',
        // 3
        Consensus: 'Consensus',
        // 4
        Seal: 'Seal',
        // 5
        PreRuntime: 'PreRuntime' // 6

      }
    },
    ExtrinsicsWeight: {
      normal: 'Weight',
      operational: 'Weight'
    },
    GenericAddress: 'LookupSource',
    H160: '[u8; 20; H160]',
    H256: '[u8; 32; H256]',
    H512: '[u8; 64; H512]',
    Hash: 'H256',
    Header: {
      parentHash: 'Hash',
      number: 'Compact<BlockNumber>',
      stateRoot: 'Hash',
      extrinsicsRoot: 'Hash',
      digest: 'Digest'
    },
    Index: 'u32',
    Justification: 'Bytes',
    KeyValue: '(StorageKey, StorageData)',
    KeyTypeId: 'u32',
    LockIdentifier: '[u8; 8]',
    LookupSource: 'GenericLookupSource',
    LookupTarget: 'AccountId',
    ModuleId: 'LockIdentifier',
    Moment: 'u64',
    OpaqueCall: 'Bytes',
    Origin: 'DoNotConstruct<Origin>',
    OriginCaller: {
      _enum: {
        // this should be dynamically built from the actual modules, based on index
        System: 'SystemOrigin'
      }
    },
    PalletsOrigin: 'OriginCaller',
    PalletVersion: {
      major: 'u16',
      minor: 'u8',
      patch: 'u8'
    },
    Pays: {
      _enum: ['Yes', 'No']
    },
    Phantom: 'Null',
    PhantomData: 'Null',
    Releases: {
      _enum: ['V1', 'V2', 'V3', 'V4', 'V5', 'V6', 'V7', 'V8', 'V9', 'V10']
    },
    RuntimeDbWeight: {
      read: 'Weight',
      write: 'Weight'
    },
    SignedBlock: {
      block: 'Block',
      justification: 'Justification'
    },
    StorageData: 'Bytes',
    TransactionPriority: 'u64',
    ValidatorId: 'AccountId',
    Weight: 'u64',
    WeightMultiplier: 'Fixed64',
    // digest
    PreRuntime: '(ConsensusEngineId, Bytes)',
    SealV0: '(u64, Signature)',
    Seal: '(ConsensusEngineId, Bytes)',
    Consensus: '(ConsensusEngineId, Bytes)'
  })
};
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types/interfaces/scheduler/definitions.js":
/*!***********************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/interfaces/scheduler/definitions.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)

/* eslint-disable sort-keys */
var _default = {
  rpc: {},
  types: {
    Period: '(BlockNumber, u32)',
    Priority: 'u8',
    SchedulePeriod: 'Period',
    SchedulePriority: 'Priority',
    Scheduled: {
      maybeId: 'Option<Bytes>',
      priority: 'SchedulePriority',
      call: 'Call',
      maybePeriodic: 'Option<SchedulePeriod>',
      origin: 'PalletsOrigin'
    },
    ScheduledTo254: {
      maybeId: 'Option<Bytes>',
      priority: 'SchedulePriority',
      call: 'Call',
      maybePeriodic: 'Option<SchedulePeriod>'
    },
    TaskAddress: '(BlockNumber, u32)'
  }
};
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types/interfaces/session/definitions.js":
/*!*********************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/interfaces/session/definitions.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)

/* eslint-disable sort-keys */
// The runtime definition of SessionKeys are passed as a Trait to session
// Defined in `node/runtime/src/lib.rs` as follow
//   impl_opaque_keys! {
//     pub struct SessionKeys {
// Here we revert to tuples to keep the interfaces "opaque", as per the use
const keyTypes = {
  // default to Substrate master defaults, 4 keys (polkadot master, 5 keys)
  Keys: 'SessionKeys4',
  // shortcuts for 1, 2, 3, 4, 5 & 6 key tuples
  SessionKeys1: '(AccountId)',
  SessionKeys2: '(AccountId, AccountId)',
  // older substrate master
  SessionKeys3: '(AccountId, AccountId, AccountId)',
  // CC2, Substrate master
  SessionKeys4: '(AccountId, AccountId, AccountId, AccountId)',
  // CC3
  SessionKeys5: '(AccountId, AccountId, AccountId, AccountId, AccountId)',
  SessionKeys6: '(AccountId, AccountId, AccountId, AccountId, AccountId, AccountId)'
};
var _default = {
  rpc: {},
  types: _objectSpread(_objectSpread({}, keyTypes), {}, {
    FullIdentification: 'Exposure',
    IdentificationTuple: '(ValidatorId, FullIdentification)',
    MembershipProof: {
      session: 'SessionIndex',
      trieNodes: 'Vec<Vec<u8>>',
      validatorCount: 'ValidatorCount'
    },
    SessionIndex: 'u32',
    ValidatorCount: 'u32'
  })
};
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types/interfaces/society/definitions.js":
/*!*********************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/interfaces/society/definitions.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)

/* eslint-disable sort-keys */
var _default = {
  rpc: {},
  types: {
    Bid: {
      who: 'AccountId',
      kind: 'BidKind',
      value: 'Balance'
    },
    BidKind: {
      _enum: {
        Deposit: 'Balance',
        Vouch: '(AccountId, Balance)'
      }
    },
    // a society-specific Judgement (not the same as identity Judgement)
    SocietyJudgement: {
      _enum: ['Rebid', 'Reject', 'Approve']
    },
    // a society-specific Vote
    SocietyVote: {
      _enum: ['Skeptic', 'Reject', 'Approve']
    },
    StrikeCount: 'u32',
    VouchingStatus: {
      _enum: ['Vouching', 'Banned']
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types/interfaces/staking/definitions.js":
/*!*********************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/interfaces/staking/definitions.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../node_modules/@babel/runtime/helpers/defineProperty.js"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)

/* eslint-disable sort-keys */
const deprecated = {
  Points: 'u32',
  EraPoints: {
    total: 'Points',
    individual: 'Vec<Points>'
  }
};
var _default = {
  rpc: {},
  types: _objectSpread(_objectSpread({}, deprecated), {}, {
    ActiveEraInfo: {
      index: 'EraIndex',
      start: 'Option<Moment>'
    },
    CompactAssignments: {
      votes1: 'Vec<(NominatorIndexCompact, ValidatorIndexCompact)>',
      votes2: 'Vec<(NominatorIndexCompact, CompactScoreCompact, ValidatorIndexCompact)>',
      votes3: 'Vec<(NominatorIndexCompact, [CompactScoreCompact; 2], ValidatorIndexCompact)>',
      votes4: 'Vec<(NominatorIndexCompact, [CompactScoreCompact; 3], ValidatorIndexCompact)>',
      votes5: 'Vec<(NominatorIndexCompact, [CompactScoreCompact; 4], ValidatorIndexCompact)>',
      votes6: 'Vec<(NominatorIndexCompact, [CompactScoreCompact; 5], ValidatorIndexCompact)>',
      votes7: 'Vec<(NominatorIndexCompact, [CompactScoreCompact; 6], ValidatorIndexCompact)>',
      votes8: 'Vec<(NominatorIndexCompact, [CompactScoreCompact; 7], ValidatorIndexCompact)>',
      votes9: 'Vec<(NominatorIndexCompact, [CompactScoreCompact; 8], ValidatorIndexCompact)>',
      votes10: 'Vec<(NominatorIndexCompact, [CompactScoreCompact; 9], ValidatorIndexCompact)>',
      votes11: 'Vec<(NominatorIndexCompact, [CompactScoreCompact; 10], ValidatorIndexCompact)>',
      votes12: 'Vec<(NominatorIndexCompact, [CompactScoreCompact; 11], ValidatorIndexCompact)>',
      votes13: 'Vec<(NominatorIndexCompact, [CompactScoreCompact; 12], ValidatorIndexCompact)>',
      votes14: 'Vec<(NominatorIndexCompact, [CompactScoreCompact; 13], ValidatorIndexCompact)>',
      votes15: 'Vec<(NominatorIndexCompact, [CompactScoreCompact; 14], ValidatorIndexCompact)>',
      votes16: 'Vec<(NominatorIndexCompact, [CompactScoreCompact; 15], ValidatorIndexCompact)>'
    },
    CompactAssignmentsTo257: {
      votes1: 'Vec<(NominatorIndex, [CompactScore; 0], ValidatorIndex)>',
      votes2: 'Vec<(NominatorIndex, [CompactScore; 1], ValidatorIndex)>',
      votes3: 'Vec<(NominatorIndex, [CompactScore; 2], ValidatorIndex)>',
      votes4: 'Vec<(NominatorIndex, [CompactScore; 3], ValidatorIndex)>',
      votes5: 'Vec<(NominatorIndex, [CompactScore; 4], ValidatorIndex)>',
      votes6: 'Vec<(NominatorIndex, [CompactScore; 5], ValidatorIndex)>',
      votes7: 'Vec<(NominatorIndex, [CompactScore; 6], ValidatorIndex)>',
      votes8: 'Vec<(NominatorIndex, [CompactScore; 7], ValidatorIndex)>',
      votes9: 'Vec<(NominatorIndex, [CompactScore; 8], ValidatorIndex)>',
      votes10: 'Vec<(NominatorIndex, [CompactScore; 9], ValidatorIndex)>',
      votes11: 'Vec<(NominatorIndex, [CompactScore; 10], ValidatorIndex)>',
      votes12: 'Vec<(NominatorIndex, [CompactScore; 11], ValidatorIndex)>',
      votes13: 'Vec<(NominatorIndex, [CompactScore; 12], ValidatorIndex)>',
      votes14: 'Vec<(NominatorIndex, [CompactScore; 13], ValidatorIndex)>',
      votes15: 'Vec<(NominatorIndex, [CompactScore; 14], ValidatorIndex)>',
      votes16: 'Vec<(NominatorIndex, [CompactScore; 15], ValidatorIndex)>'
    },
    CompactScore: '(ValidatorIndex, OffchainAccuracy)',
    CompactScoreCompact: '(ValidatorIndexCompact, OffchainAccuracyCompact)',
    ElectionCompute: {
      _enum: ['OnChain', 'Signed', 'Authority']
    },
    ElectionResult: {
      compute: 'ElectionCompute',
      slotStake: 'Balance',
      electedStashes: 'Vec<AccountId>',
      exposures: 'Vec<(AccountId, Exposure)>'
    },
    ElectionScore: '[u128; 3]',
    ElectionSize: {
      validators: 'Compact<ValidatorIndex>',
      nominators: 'Compact<NominatorIndex>'
    },
    ElectionStatus: {
      _enum: {
        Close: 'Null',
        Open: 'BlockNumber'
      }
    },
    EraIndex: 'u32',
    EraRewardPoints: {
      total: 'RewardPoint',
      individual: 'BTreeMap<AccountId, RewardPoint>'
    },
    EraRewards: {
      total: 'u32',
      rewards: 'Vec<u32>'
    },
    Exposure: {
      total: 'Compact<Balance>',
      own: 'Compact<Balance>',
      others: 'Vec<IndividualExposure>'
    },
    Forcing: {
      _enum: ['NotForcing', 'ForceNew', 'ForceNone', 'ForceAlways']
    },
    IndividualExposure: {
      who: 'AccountId',
      value: 'Compact<Balance>'
    },
    KeyType: 'AccountId',
    MomentOf: 'Moment',
    Nominations: {
      targets: 'Vec<AccountId>',
      submittedIn: 'EraIndex',
      suppressed: 'bool'
    },
    NominatorIndex: 'u32',
    NominatorIndexCompact: 'Compact<NominatorIndex>',
    OffchainAccuracy: 'PerU16',
    OffchainAccuracyCompact: 'Compact<OffchainAccuracy>',
    PhragmenScore: '[u128; 3]',
    Points: 'u32',
    RewardDestination: {
      _enum: {
        Staked: 'Null',
        Stash: 'Null',
        Controller: 'Null',
        Account: 'AccountId'
      }
    },
    RewardDestinationTo257: {
      _enum: ['Staked', 'Stash', 'Controller']
    },
    RewardPoint: 'u32',
    SlashJournalEntry: {
      who: 'AccountId',
      amount: 'Balance',
      ownSlash: 'Balance'
    },
    SlashingSpansTo204: {
      spanIndex: 'SpanIndex',
      lastStart: 'EraIndex',
      prior: 'Vec<EraIndex>'
    },
    SlashingSpans: {
      spanIndex: 'SpanIndex',
      lastStart: 'EraIndex',
      lastNonzeroSlash: 'EraIndex',
      prior: 'Vec<EraIndex>'
    },
    SpanIndex: 'u32',
    SpanRecord: {
      slashed: 'Balance',
      paidOut: 'Balance'
    },
    StakingLedgerTo223: {
      stash: 'AccountId',
      total: 'Compact<Balance>',
      active: 'Compact<Balance>',
      unlocking: 'Vec<UnlockChunk>'
    },
    StakingLedgerTo240: {
      stash: 'AccountId',
      total: 'Compact<Balance>',
      active: 'Compact<Balance>',
      unlocking: 'Vec<UnlockChunk>',
      lastReward: 'Option<EraIndex>'
    },
    StakingLedger: {
      stash: 'AccountId',
      total: 'Compact<Balance>',
      active: 'Compact<Balance>',
      unlocking: 'Vec<UnlockChunk>',
      claimedRewards: 'Vec<EraIndex>'
    },
    UnappliedSlashOther: '(AccountId, Balance)',
    UnappliedSlash: {
      validator: 'AccountId',
      own: 'Balance',
      others: 'Vec<UnappliedSlashOther>',
      reporters: 'Vec<AccountId>',
      payout: 'Balance'
    },
    UnlockChunk: {
      value: 'Compact<Balance>',
      era: 'Compact<BlockNumber>'
    },
    ValidatorIndex: 'u16',
    ValidatorIndexCompact: 'Compact<ValidatorIndex>',
    ValidatorPrefs: {
      commission: 'Compact<Perbill>'
    },
    ValidatorPrefsTo196: {
      validatorPayment: 'Compact<Balance>'
    },
    ValidatorPrefsTo145: {
      unstakeThreshold: 'Compact<u32>',
      validatorPayment: 'Compact<Balance>'
    }
  })
};
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types/interfaces/state/definitions.js":
/*!*******************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/interfaces/state/definitions.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)

/* eslint-disable sort-keys */
var _default = {
  rpc: {
    call: {
      alias: ['state_callAt'],
      description: 'Perform a call to a builtin on the chain',
      params: [{
        name: 'method',
        type: 'Text'
      }, {
        name: 'data',
        type: 'Bytes'
      }, {
        name: 'at',
        type: 'BlockHash',
        isHistoric: true,
        isOptional: true
      }],
      type: 'Bytes'
    },
    getKeys: {
      description: 'Retrieves the keys with a certain prefix',
      params: [{
        name: 'key',
        type: 'StorageKey'
      }, {
        name: 'at',
        type: 'BlockHash',
        isHistoric: true,
        isOptional: true
      }],
      type: 'Vec<StorageKey>'
    },
    getPairs: {
      description: 'Returns the keys with prefix, leave empty to get all the keys (deprecated: Use getKeysPaged)',
      params: [{
        name: 'prefix',
        type: 'StorageKey'
      }, {
        name: 'at',
        type: 'BlockHash',
        isHistoric: true,
        isOptional: true
      }],
      type: 'Vec<KeyValue>'
    },
    getKeysPaged: {
      alias: ['state_getKeysPagedAt'],
      description: 'Returns the keys with prefix with pagination support.',
      params: [{
        name: 'key',
        type: 'StorageKey'
      }, {
        name: 'count',
        type: 'u32'
      }, {
        name: 'startKey',
        type: 'StorageKey',
        isOptional: true
      }, {
        name: 'at',
        type: 'BlockHash',
        isHistoric: true,
        isOptional: true
      }],
      type: 'Vec<StorageKey>'
    },
    getStorage: {
      alias: ['state_getStorageAt'],
      description: 'Retrieves the storage for a key',
      params: [{
        name: 'key',
        type: 'StorageKey'
      }, {
        name: 'at',
        type: 'BlockHash',
        isHistoric: true,
        isOptional: true
      }],
      type: 'StorageData'
    },
    getStorageHash: {
      alias: ['state_getStorageHashAt'],
      description: 'Retrieves the storage hash',
      params: [{
        name: 'key',
        type: 'StorageKey'
      }, {
        name: 'at',
        type: 'BlockHash',
        isHistoric: true,
        isOptional: true
      }],
      type: 'Hash'
    },
    getStorageSize: {
      alias: ['state_getStorageSizeAt'],
      description: 'Retrieves the storage size',
      params: [{
        name: 'key',
        type: 'StorageKey'
      }, {
        name: 'at',
        type: 'BlockHash',
        isHistoric: true,
        isOptional: true
      }],
      type: 'u64'
    },
    getChildKeys: {
      description: 'Retrieves the keys with prefix of a specific child storage',
      params: [{
        name: 'childStorageKey',
        type: 'StorageKey'
      }, {
        name: 'childDefinition',
        type: 'StorageKey'
      }, {
        name: 'childType',
        type: 'u32'
      }, {
        name: 'key',
        type: 'StorageKey'
      }, {
        name: 'at',
        type: 'BlockHash',
        isHistoric: true,
        isOptional: true
      }],
      type: 'Vec<StorageKey>'
    },
    getChildStorage: {
      description: 'Retrieves the child storage for a key',
      params: [{
        name: 'childStorageKey',
        type: 'StorageKey'
      }, {
        name: 'childDefinition',
        type: 'StorageKey'
      }, {
        name: 'childType',
        type: 'u32'
      }, {
        name: 'key',
        type: 'StorageKey'
      }, {
        name: 'at',
        type: 'BlockHash',
        isHistoric: true,
        isOptional: true
      }],
      type: 'StorageData'
    },
    getChildStorageHash: {
      description: 'Retrieves the child storage hash',
      params: [{
        name: 'childStorageKey',
        type: 'StorageKey'
      }, {
        name: 'childDefinition',
        type: 'StorageKey'
      }, {
        name: 'childType',
        type: 'u32'
      }, {
        name: 'key',
        type: 'StorageKey'
      }, {
        name: 'at',
        type: 'BlockHash',
        isHistoric: true,
        isOptional: true
      }],
      type: 'Hash'
    },
    getChildStorageSize: {
      description: 'Retrieves the child storage size',
      params: [{
        name: 'childStorageKey',
        type: 'StorageKey'
      }, {
        name: 'childDefinition',
        type: 'StorageKey'
      }, {
        name: 'childType',
        type: 'u32'
      }, {
        name: 'key',
        type: 'StorageKey'
      }, {
        name: 'at',
        type: 'BlockHash',
        isHistoric: true,
        isOptional: true
      }],
      type: 'u64'
    },
    getMetadata: {
      description: 'Returns the runtime metadata',
      params: [{
        name: 'at',
        type: 'BlockHash',
        isCached: true,
        isOptional: true
      }],
      type: 'Metadata'
    },
    getRuntimeVersion: {
      alias: ['chain_getRuntimeVersion'],
      description: 'Get the runtime version',
      params: [{
        name: 'at',
        type: 'BlockHash',
        isCached: true,
        isOptional: true
      }],
      type: 'RuntimeVersion'
    },
    queryStorage: {
      description: 'Query historical storage entries (by key) starting from a start block',
      params: [{
        name: 'keys',
        type: 'Vec<StorageKey>'
      }, {
        name: 'fromBlock',
        type: 'Hash'
      }, {
        name: 'toBlock',
        type: 'BlockHash',
        isOptional: true
      }],
      type: 'Vec<StorageChangeSet>'
    },
    queryStorageAt: {
      description: 'Query storage entries (by key) starting at block hash given as the second parameter',
      params: [{
        name: 'keys',
        type: 'Vec<StorageKey>'
      }, {
        name: 'at',
        type: 'BlockHash',
        isHistoric: true,
        isOptional: true
      }],
      type: 'Vec<StorageChangeSet>'
    },
    getReadProof: {
      description: 'Returns proof of storage entries at a specific block state',
      params: [{
        name: 'keys',
        type: 'Vec<StorageKey>'
      }, {
        name: 'at',
        type: 'BlockHash',
        isHistoric: true,
        isOptional: true
      }],
      type: 'ReadProof'
    },
    subscribeRuntimeVersion: {
      alias: ['chain_subscribeRuntimeVersion', 'chain_unsubscribeRuntimeVersion'],
      description: 'Retrieves the runtime version via subscription',
      params: [],
      pubsub: ['runtimeVersion', 'subscribeRuntimeVersion', 'unsubscribeRuntimeVersion'],
      type: 'RuntimeVersion'
    },
    subscribeStorage: {
      description: 'Subscribes to storage changes for the provided keys',
      params: [{
        name: 'keys',
        type: 'Vec<StorageKey>',
        isOptional: true
      }],
      pubsub: ['storage', 'subscribeStorage', 'unsubscribeStorage'],
      type: 'StorageChangeSet'
    }
  },
  types: {
    ApiId: '[u8; 8]',
    KeyValueOption: '(StorageKey, Option<StorageData>)',
    ReadProof: {
      at: 'Hash',
      proof: 'Vec<Bytes>'
    },
    RuntimeVersionApi: '(ApiId, u32)',
    RuntimeVersion: {
      specName: 'Text',
      implName: 'Text',
      authoringVersion: 'u32',
      specVersion: 'u32',
      implVersion: 'u32',
      apis: 'Vec<RuntimeVersionApi>',
      transactionVersion: 'u32'
    },
    StorageChangeSet: {
      block: 'Hash',
      changes: 'Vec<KeyValueOption>'
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types/interfaces/support/definitions.js":
/*!*********************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/interfaces/support/definitions.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)

/* eslint-disable sort-keys */
var _default = {
  rpc: {},
  types: {
    WeightToFeeCoefficient: {
      coeffInteger: 'Balance',
      coeffFrac: 'Perbill',
      negative: 'bool',
      degree: 'u8'
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types/interfaces/system/definitions.js":
/*!********************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/interfaces/system/definitions.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)

/* eslint-disable sort-keys */
var _default = {
  rpc: {
    accountNextIndex: {
      alias: ['account_nextIndex'],
      description: 'Retrieves the next accountIndex as available on the node',
      params: [{
        name: 'accountId',
        type: 'AccountId'
      }],
      type: 'Index'
    },
    dryRun: {
      alias: ['system_dryRunAt'],
      description: 'Dry run an extrinsic at a given block',
      params: [{
        name: 'extrinsic',
        type: 'Bytes'
      }, {
        name: 'at',
        type: 'BlockHash',
        isHistoric: true,
        isOptional: true
      }],
      type: 'ApplyExtrinsicResult'
    },
    name: {
      description: 'Retrieves the node name',
      params: [],
      type: 'Text'
    },
    version: {
      description: 'Retrieves the version of the node',
      params: [],
      type: 'Text'
    },
    chain: {
      description: 'Retrieves the chain',
      params: [],
      type: 'Text'
    },
    chainType: {
      description: 'Retrieves the chain type',
      params: [],
      type: 'ChainType'
    },
    properties: {
      description: 'Get a custom set of properties as a JSON object, defined in the chain spec',
      params: [],
      type: 'ChainProperties'
    },
    health: {
      description: 'Return health status of the node',
      params: [],
      type: 'Health'
    },
    localPeerId: {
      description: 'Returns the base58-encoded PeerId of the node',
      params: [],
      type: 'Text'
    },
    localListenAddresses: {
      description: 'The addresses include a trailing /p2p/ with the local PeerId, and are thus suitable to be passed to addReservedPeer or as a bootnode address for example',
      params: [],
      type: 'Vec<Text>'
    },
    peers: {
      description: 'Returns the currently connected peers',
      params: [],
      type: 'Vec<PeerInfo>'
    },
    networkState: {
      description: 'Returns current state of the network',
      params: [],
      type: 'NetworkState'
    },
    addReservedPeer: {
      description: 'Adds a reserved peer',
      params: [{
        name: 'peer',
        type: 'Text'
      }],
      type: 'Text'
    },
    removeReservedPeer: {
      description: 'Remove a reserved peer',
      params: [{
        name: 'peerId',
        type: 'Text'
      }],
      type: 'Text'
    },
    nodeRoles: {
      description: 'Returns the roles the node is running as',
      params: [],
      type: 'Vec<NodeRole>'
    }
  },
  types: {
    AccountInfo: {
      nonce: 'Index',
      refcount: 'RefCount',
      data: 'AccountData'
    },
    ApplyExtrinsicResult: 'Result<DispatchOutcome, TransactionValidityError>',
    ChainProperties: {
      ss58Format: 'Option<u8>',
      tokenDecimals: 'Option<u32>',
      tokenSymbol: 'Option<Text>'
    },
    ChainType: {
      _enum: {
        Development: 'Null',
        Local: 'Null',
        Live: 'Null',
        Custom: 'Text'
      }
    },
    DigestOf: 'Digest',
    DispatchClass: {
      _enum: ['Normal', 'Operational', 'Mandatory']
    },
    DispatchError: {
      _enum: {
        Other: 'Null',
        CannotLookup: 'Null',
        BadOrigin: 'Null',
        Module: 'DispatchErrorModule'
      }
    },
    DispatchErrorModule: {
      index: 'u8',
      error: 'u8'
    },
    DispatchErrorTo198: {
      module: 'Option<u8>',
      error: 'u8'
    },
    DispatchInfo: {
      weight: 'Weight',
      class: 'DispatchClass',
      paysFee: 'Pays'
    },
    DispatchInfoTo190: {
      weight: 'Weight',
      class: 'DispatchClass'
    },
    DispatchInfoTo244: {
      weight: 'Weight',
      class: 'DispatchClass',
      paysFee: 'bool'
    },
    DispatchOutcome: 'Result<(), DispatchError>',
    DispatchResult: 'Result<(), DispatchError>',
    DispatchResultOf: 'DispatchResult',
    DispatchResultTo198: 'Result<(), Text>',
    Event: 'GenericEvent',
    EventId: '[u8; 2]',
    EventIndex: 'u32',
    EventRecord: {
      phase: 'Phase',
      event: 'Event',
      topics: 'Vec<Hash>'
    },
    Health: {
      peers: 'u64',
      isSyncing: 'bool',
      shouldHavePeers: 'bool'
    },
    InvalidTransaction: {
      _enum: {
        Call: 'Null',
        Payment: 'Null',
        Future: 'Null',
        Stale: 'Null',
        BadProof: 'Null',
        AncientBirthBlock: 'Null',
        ExhaustsResources: 'Null',
        Custom: 'u8',
        BadMandatory: 'Null',
        MandatoryDispatch: 'Null'
      }
    },
    Key: 'Bytes',
    LastRuntimeUpgradeInfo: {
      specVersion: 'Compact<u32>',
      specName: 'Text'
    },
    NetworkState: {
      peerId: 'Text',
      listenedAddresses: 'Vec<Text>',
      externalAddresses: 'Vec<Text>',
      connectedPeers: 'HashMap<Text, Peer>',
      notConnectedPeers: 'HashMap<Text, NotConnectedPeer>',
      averageDownloadPerSec: 'u64',
      averageUploadPerSec: 'u64',
      peerset: 'NetworkStatePeerset'
    },
    NetworkStatePeerset: {
      messageQueue: 'u64',
      nodes: 'HashMap<Text, NetworkStatePeersetInfo>'
    },
    NetworkStatePeersetInfo: {
      connected: 'bool',
      reputation: 'i32'
    },
    NodeRole: {
      _enum: {
        Full: 'Null',
        LightClient: 'Null',
        Authority: 'Null',
        UnknownRole: 'u8'
      }
    },
    NotConnectedPeer: {
      knownAddresses: 'Vec<Text>',
      latestPingTime: 'Option<PeerPing>',
      versionString: 'Option<Text>'
    },
    Peer: {
      enabled: 'bool',
      endpoint: 'PeerEndpoint',
      knownAddresses: 'Vec<Text>',
      latestPingTime: 'PeerPing',
      open: 'bool',
      versionString: 'Text'
    },
    PeerEndpoint: {
      listening: 'PeerEndpointAddr'
    },
    PeerEndpointAddr: {
      _alias: {
        localAddr: 'local_addr',
        sendBackAddr: 'send_back_addr'
      },
      localAddr: 'Text',
      sendBackAddr: 'Text'
    },
    PeerPing: {
      nanos: 'u64',
      secs: 'u64'
    },
    PeerInfo: {
      peerId: 'Text',
      roles: 'Text',
      protocolVersion: 'u32',
      bestHash: 'Hash',
      bestNumber: 'BlockNumber'
    },
    Phase: {
      _enum: {
        ApplyExtrinsic: 'u32',
        Finalization: 'Null',
        Initialization: 'Null'
      }
    },
    RawOrigin: {
      _enum: {
        Root: 'Null',
        Signed: 'AccountId',
        None: 'Null'
      }
    },
    RefCount: 'u32',
    RefCountTo259: 'u8',
    SystemOrigin: 'RawOrigin',
    TransactionValidityError: {
      _enum: {
        Invalid: 'InvalidTransaction',
        Unknown: 'UnknownTransaction'
      }
    },
    UnknownTransaction: {
      _enum: {
        CannotLookup: 'Null',
        NoUnsignedValidator: 'Null',
        Custom: 'u8'
      }
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types/interfaces/treasury/definitions.js":
/*!**********************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/interfaces/treasury/definitions.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)

/* eslint-disable sort-keys */
var _default = {
  rpc: {},
  types: {
    Bounty: {
      proposer: 'AccountId',
      value: 'Balance',
      fee: 'Balance',
      curatorDeposit: 'Balance',
      bond: 'Balance',
      status: 'BountyStatus'
    },
    BountyIndex: 'u32',
    BountyStatus: {
      _enum: {
        Proposed: 'Null',
        Approved: 'Null',
        Funded: 'Null',
        CuratorProposed: 'BountyStatusCuratorProposed',
        Active: 'BountyStatusActive',
        PendingPayout: 'BountyStatusPendingPayout'
      }
    },
    BountyStatusActive: {
      curator: 'AccountId',
      updateDue: 'BlockNumber'
    },
    BountyStatusCuratorProposed: {
      curator: 'AccountId'
    },
    BountyStatusPendingPayout: {
      curator: 'AccountId',
      beneficiary: 'AccountId',
      unlockAt: 'BlockNumber'
    },
    OpenTip: {
      reason: 'Hash',
      who: 'AccountId',
      finder: 'AccountId',
      deposit: 'Balance',
      closes: 'Option<BlockNumber>',
      tips: 'Vec<OpenTipTip>',
      findersFee: 'bool'
    },
    OpenTipTo225: {
      reason: 'Hash',
      who: 'AccountId',
      finder: 'Option<OpenTipFinderTo225>',
      closes: 'Option<BlockNumber>',
      tips: 'Vec<OpenTipTip>'
    },
    OpenTipFinderTo225: '(AccountId, Balance)',
    OpenTipTip: '(AccountId, Balance)',
    TreasuryProposal: {
      proposer: 'AccountId',
      value: 'Balance',
      beneficiary: 'AccountId',
      bond: 'Balance'
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types/interfaces/txpayment/definitions.js":
/*!***********************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/interfaces/txpayment/definitions.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
var _default = {
  rpc: {},
  types: {
    Multiplier: 'Fixed128'
  }
};
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types/interfaces/utility/definitions.js":
/*!*********************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/interfaces/utility/definitions.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)

/* eslint-disable sort-keys */
var _default = {
  rpc: {},
  types: {
    Multisig: {
      when: 'Timepoint',
      deposit: 'Balance',
      depositor: 'AccountId',
      approvals: 'Vec<AccountId>'
    },
    Timepoint: {
      height: 'BlockNumber',
      index: 'u32'
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types/interfaces/vesting/definitions.js":
/*!*********************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/interfaces/vesting/definitions.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// order important in structs... :)

/* eslint-disable sort-keys */
var _default = {
  rpc: {},
  types: {
    VestingInfo: {
      locked: 'Balance',
      perBlock: 'Balance',
      startingBlock: 'BlockNumber'
    }
  }
};
exports.default = _default;

/***/ }),

/***/ "../../node_modules/@polkadot/types/package.json":
/*!************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/package.json ***!
  \************************************************************/
/*! exports provided: name, version, description, main, keywords, author, maintainers, contributors, license, publishConfig, repository, bugs, homepage, dependencies, devDependencies, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"name\":\"@polkadot/types\",\"version\":\"2.2.2-2\",\"description\":\"Implementation of the Parity codec\",\"main\":\"index.js\",\"keywords\":[\"Polkadot\",\"JsonRPC\"],\"author\":\"Jaco Greeff <jacogr@gmail.com>\",\"maintainers\":[\"Jaco Greeff <jacogr@gmail.com>\"],\"contributors\":[],\"license\":\"Apache-2.0\",\"publishConfig\":{\"access\":\"public\",\"registry\":\"https://registry.npmjs.org\"},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/polkadot-js/api.git\"},\"bugs\":{\"url\":\"https://github.com/polkadot-js/api/issues\"},\"homepage\":\"https://github.com/polkadot-js/api/tree/master/packages/types#readme\",\"dependencies\":{\"@babel/runtime\":\"^7.11.2\",\"@polkadot/metadata\":\"2.2.2-2\",\"@polkadot/util\":\"^3.5.1\",\"@polkadot/util-crypto\":\"^3.5.1\",\"@types/bn.js\":\"^4.11.6\",\"bn.js\":\"^5.1.3\",\"memoizee\":\"^0.4.14\",\"rxjs\":\"^6.6.3\"},\"devDependencies\":{\"@polkadot/keyring\":\"^3.5.1\",\"@types/memoizee\":\"^0.4.4\"}}");

/***/ }),

/***/ "../../node_modules/@polkadot/types/primitive/BitVec.js":
/*!*******************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/primitive/BitVec.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _Compact = _interopRequireDefault(__webpack_require__(/*! ../codec/Compact */ "../../node_modules/@polkadot/types/codec/Compact.js"));

var _Raw = _interopRequireDefault(__webpack_require__(/*! ../codec/Raw */ "../../node_modules/@polkadot/types/codec/Raw.js"));

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0

/** @internal */
function decodeBitVecU8a(value) {
  if (!value || !value.length) {
    return new Uint8Array();
  } // handle all other Uint8Array inputs, these do have a length prefix which is the number of bits encoded


  const [offset, length] = _Compact.default.decodeU8a(value);

  const total = offset + Math.ceil(length.toNumber() / 8);
  (0, _util.assert)(total <= value.length, `BitVec: required length less than remainder, expected at least ${total}, found ${value.length}`);
  return value.subarray(offset, total);
}
/** @internal */


function decodeBitVec(value) {
  if (Array.isArray(value) || (0, _util.isString)(value)) {
    return (0, _util.u8aToU8a)(value);
  }

  return decodeBitVecU8a(value);
}
/**
 * @name BitVec
 * @description
 * A BitVec that represents an array of bits. The bits are however stored encoded. The difference between this
 * and a normal Bytes would be that the length prefix indicates the number of bits encoded, not the bytes
 */


class BitVec extends _Raw.default {
  constructor(registry, value) {
    super(registry, decodeBitVec(value));
  }
  /**
   * @description The length of the value when encoded as a Uint8Array
   */


  get encodedLength() {
    return this.length + _Compact.default.encodeU8a(this.bitLength()).length;
  }
  /**
   * @description Returns the base runtime type name for this instance
   */


  toRawType() {
    return 'BitVec';
  }
  /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */


  toU8a(isBare) {
    const bitVec = super.toU8a();
    return isBare ? bitVec : (0, _util.u8aConcat)(_Compact.default.encodeU8a(this.bitLength()), bitVec);
  }

}

exports.default = BitVec;

/***/ }),

/***/ "../../node_modules/@polkadot/types/primitive/Bool.js":
/*!*****************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/primitive/Bool.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0

/** @internal */
function decodeBool(value) {
  if (value instanceof Boolean) {
    return value.valueOf();
  } else if ((0, _util.isU8a)(value)) {
    return value[0] === 1;
  }

  return !!value;
}
/**
 * @name Bool
 * @description
 * Representation for a boolean value in the system. It extends the base JS `Boolean` class
 * @noInheritDoc
 */


class Bool extends Boolean {
  // eslint-disable-next-line @typescript-eslint/ban-types
  constructor(registry, value = false) {
    super(decodeBool(value));
    this.registry = void 0;
    this.registry = registry;
  }
  /**
   * @description The length of the value when encoded as a Uint8Array
   */


  get encodedLength() {
    return 1;
  }
  /**
   * @description returns a hash of the contents
   */


  get hash() {
    return this.registry.createType('H256', this.registry.hash(this.toU8a()));
  }
  /**
   * @description Checks if the value is an empty value (true when it wraps false/default)
   */


  get isEmpty() {
    return this.isFalse;
  }
  /**
   * @description Checks if the value is an empty value (always false)
   */


  get isFalse() {
    return !this.isTrue;
  }
  /**
   * @description Checks if the value is an empty value (always false)
   */


  get isTrue() {
    return this.valueOf();
  }
  /**
   * @description Compares the value of the input to see if there is a match
   */


  eq(other) {
    return this.valueOf() === (other instanceof Boolean ? other.valueOf() : other);
  }
  /**
   * @description Returns a hex string representation of the value
   */


  toHex() {
    return (0, _util.u8aToHex)(this.toU8a());
  }
  /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */


  toHuman() {
    return this.toJSON();
  }
  /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */


  toJSON() {
    return this.valueOf();
  }
  /**
   * @description Returns the base runtime type name for this instance
   */


  toRawType() {
    return 'bool';
  }
  /**
   * @description Returns the string representation of the value
   */


  toString() {
    return this.toJSON().toString();
  }
  /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars


  toU8a(isBare) {
    return new Uint8Array([this.valueOf() ? 1 : 0]);
  }

}

exports.default = Bool;

/***/ }),

/***/ "../../node_modules/@polkadot/types/primitive/Bytes.js":
/*!******************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/primitive/Bytes.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _Compact = _interopRequireDefault(__webpack_require__(/*! ../codec/Compact */ "../../node_modules/@polkadot/types/codec/Compact.js"));

var _Raw = _interopRequireDefault(__webpack_require__(/*! ../codec/Raw */ "../../node_modules/@polkadot/types/codec/Raw.js"));

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Bytes are used for things like on-chain code, so it has a healthy limit
const MAX_LENGTH = 10 * 1024 * 1024;
/** @internal */

function decodeBytesU8a(value) {
  if (!value.length) {
    return new Uint8Array();
  } // handle all other Uint8Array inputs, these do have a length prefix


  const [offset, length] = _Compact.default.decodeU8a(value);

  const total = offset + length.toNumber();
  (0, _util.assert)(length.lten(MAX_LENGTH), `Bytes length ${length.toString()} exceeds ${MAX_LENGTH}`);
  (0, _util.assert)(total <= value.length, `Bytes: required length less than remainder, expected at least ${total}, found ${value.length}`);
  return value.subarray(offset, total);
}
/** @internal */


function decodeBytes(value) {
  if (Array.isArray(value) || (0, _util.isString)(value)) {
    return (0, _util.u8aToU8a)(value);
  } else if (!(value instanceof _Raw.default) && (0, _util.isU8a)(value)) {
    // We are ensuring we are not a Raw instance. In the case of a Raw we already have gotten
    // rid of the length, i.e. new Bytes(new Bytes(...)) will work as expected
    return decodeBytesU8a(value);
  }

  return value;
}
/**
 * @name Bytes
 * @description
 * A Bytes wrapper for Vec<u8>. The significant difference between this and a normal Uint8Array
 * is that this version allows for length-encoding. (i.e. it is a variable-item codec, the same
 * as what is found in [[Text]] and [[Vec]])
 */


class Bytes extends _Raw.default {
  constructor(registry, value) {
    super(registry, decodeBytes(value));
  }
  /**
   * @description The length of the value when encoded as a Uint8Array
   */


  get encodedLength() {
    return this.length + _Compact.default.encodeU8a(this.length).length;
  }
  /**
   * @description Returns the base runtime type name for this instance
   */


  toRawType() {
    return 'Bytes';
  }
  /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */


  toU8a(isBare) {
    return isBare ? super.toU8a(isBare) : _Compact.default.addLengthPrefix(this);
  }

}

exports.default = Bytes;

/***/ }),

/***/ "../../node_modules/@polkadot/types/primitive/Data.js":
/*!*****************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/primitive/Data.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _Enum = _interopRequireDefault(__webpack_require__(/*! ../codec/Enum */ "../../node_modules/@polkadot/types/codec/Enum.js"));

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0

/** @internal */
function decodeDataU8a(registry, value) {
  if (!value.length) {
    return [undefined, undefined];
  }

  const indicator = value[0];

  if (indicator === 0) {
    return [null, 0];
  } else if (indicator >= 1 && indicator <= 33) {
    const length = indicator - 1;
    const data = value.subarray(1, length + 1); // in this case, we are passing a Raw back (since we have no length)

    return [registry.createType('Raw', data), 1];
  } else if (indicator >= 34 && indicator <= 37) {
    return [value.subarray(1, 32 + 1), indicator - 32]; // 34 becomes 2
  }

  throw new Error(`Unable to decode Data, invalid indicator byte ${indicator}`);
}
/** @internal */


function decodeData(registry, value) {
  if (!value) {
    return [undefined, undefined];
  } else if ((0, _util.isString)(value)) {
    return decodeDataU8a(registry, (0, _util.u8aToU8a)(value));
  } else if ((0, _util.isU8a)(value)) {
    return decodeDataU8a(registry, value);
  } // assume we have an Enum or an  object input, handle this via the normal Enum decoding


  return [value, undefined];
}
/**
 * @name Data
 * @description
 * A [[Data]] container with node, raw or hashed data
 */


class Data extends _Enum.default {
  constructor(registry, value) {
    super(registry, {
      None: 'Null',
      // 0
      Raw: 'Bytes',
      // 1
      // eslint-disable-next-line sort-keys
      BlakeTwo256: 'H256',
      // 2
      Sha256: 'H256',
      // 3
      // eslint-disable-next-line sort-keys
      Keccak256: 'H256',
      // 4
      ShaThree256: 'H256' // 5

    }, ...decodeData(registry, value));
  }

  get asRaw() {
    return this.value;
  }

  get asSha256() {
    return this.value;
  }

  get isRaw() {
    return this.index === 1;
  }

  get isSha256() {
    return this.index === 3;
  }
  /**
   * @description The encoded length
   */


  get encodedLength() {
    return this.toU8a().length;
  }
  /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   */


  toU8a() {
    if (this.index === 0) {
      return new Uint8Array(1);
    } else if (this.index === 1) {
      // don't add the length, just the data
      const data = this.value.toU8a(true);
      const length = Math.min(data.length, 32);
      const u8a = new Uint8Array(length + 1);
      u8a.set([data.length + 1], 0);
      u8a.set(data.subarray(0, length), 1);
      return u8a;
    } // otherwise we simply have a hash


    const u8a = new Uint8Array(33);
    u8a.set([this.index + 32], 0);
    u8a.set(this.value.toU8a(), 1);
    return u8a;
  }

}

exports.default = Data;

/***/ }),

/***/ "../../node_modules/@polkadot/types/primitive/DoNotConstruct.js":
/*!***************************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/primitive/DoNotConstruct.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Null = _interopRequireDefault(__webpack_require__(/*! ./Null */ "../../node_modules/@polkadot/types/primitive/Null.js"));

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name DoNotConstruct
 * @description
 * An unknown type that fails on construction with the type info
 */
class DoNotConstruct extends _Null.default {
  constructor(registry, typeName) {
    super(registry);
    throw new Error(`Cannot construct unknown type ${typeName}`);
  }

  static with(typeName = 'DoNotConstruct') {
    return class extends DoNotConstruct {
      constructor(registry) {
        super(registry, typeName);
      }

    };
  }

}

exports.default = DoNotConstruct;

/***/ }),

/***/ "../../node_modules/@polkadot/types/primitive/I128.js":
/*!*****************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/primitive/I128.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Int = _interopRequireDefault(__webpack_require__(/*! ../codec/Int */ "../../node_modules/@polkadot/types/codec/Int.js"));

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name I128
 * @description
 * A 128-bit signed integer
 */
class I128 extends _Int.default.with(128) {}

exports.default = I128;

/***/ }),

/***/ "../../node_modules/@polkadot/types/primitive/I16.js":
/*!****************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/primitive/I16.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Int = _interopRequireDefault(__webpack_require__(/*! ../codec/Int */ "../../node_modules/@polkadot/types/codec/Int.js"));

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name I16
 * @description
 * A 16-bit signed integer
 */
class I16 extends _Int.default.with(16) {}

exports.default = I16;

/***/ }),

/***/ "../../node_modules/@polkadot/types/primitive/I256.js":
/*!*****************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/primitive/I256.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Int = _interopRequireDefault(__webpack_require__(/*! ../codec/Int */ "../../node_modules/@polkadot/types/codec/Int.js"));

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name I256
 * @description
 * A 256-bit signed integer
 */
class I256 extends _Int.default.with(256) {}

exports.default = I256;

/***/ }),

/***/ "../../node_modules/@polkadot/types/primitive/I32.js":
/*!****************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/primitive/I32.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Int = _interopRequireDefault(__webpack_require__(/*! ../codec/Int */ "../../node_modules/@polkadot/types/codec/Int.js"));

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name I32
 * @description
 * A 32-bit signed integer
 */
class I32 extends _Int.default.with(32) {}

exports.default = I32;

/***/ }),

/***/ "../../node_modules/@polkadot/types/primitive/I64.js":
/*!****************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/primitive/I64.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Int = _interopRequireDefault(__webpack_require__(/*! ../codec/Int */ "../../node_modules/@polkadot/types/codec/Int.js"));

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name I64
 * @description
 * A 64-bit signed integer
 */
class I64 extends _Int.default.with(64) {}

exports.default = I64;

/***/ }),

/***/ "../../node_modules/@polkadot/types/primitive/I8.js":
/*!***************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/primitive/I8.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Int = _interopRequireDefault(__webpack_require__(/*! ../codec/Int */ "../../node_modules/@polkadot/types/codec/Int.js"));

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name I8
 * @description
 * An 8-bit signed integer
 */
class I8 extends _Int.default.with(8) {}

exports.default = I8;

/***/ }),

/***/ "../../node_modules/@polkadot/types/primitive/Null.js":
/*!*****************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/primitive/Null.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name Null
 * @description
 * Implements a type that does not contain anything (apart from `null`)
 */
class Null {
  constructor(registry) {
    this.registry = void 0;
    this.registry = registry;
  }
  /**
   * @description The length of the value when encoded as a Uint8Array
   */


  get encodedLength() {
    return 0;
  }
  /**
   * @description returns a hash of the contents
   */


  get hash() {
    throw new Error('.hash is not implemented on Null');
  }
  /**
   * @description Checks if the value is an empty value (always true)
   */


  get isEmpty() {
    return true;
  }
  /**
   * @description Compares the value of the input to see if there is a match
   */


  eq(other) {
    return other instanceof Null || (0, _util.isNull)(other);
  }
  /**
   * @description Returns a hex string representation of the value
   */


  toHex() {
    return '0x';
  }
  /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */


  toHuman() {
    return this.toJSON();
  }
  /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */


  toJSON() {
    return null;
  }
  /**
   * @description Returns the base runtime type name for this instance
   */


  toRawType() {
    return 'Null';
  }
  /**
   * @description Returns the string representation of the value
   */


  toString() {
    return '';
  }
  /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars


  toU8a(isBare) {
    return new Uint8Array();
  }

}

exports.default = Null;

/***/ }),

/***/ "../../node_modules/@polkadot/types/primitive/StorageKey.js":
/*!***********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/primitive/StorageKey.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unwrapStorageType = unwrapStorageType;
exports.default = void 0;

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _Bytes = _interopRequireDefault(__webpack_require__(/*! ./Bytes */ "../../node_modules/@polkadot/types/primitive/Bytes.js"));

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
const HASHER_MAP = {
  // opaque
  Blake2_128: [16, false],
  // eslint-disable-line camelcase
  Blake2_128Concat: [16, true],
  // eslint-disable-line camelcase
  Blake2_256: [32, false],
  // eslint-disable-line camelcase
  Identity: [0, true],
  Twox128: [16, false],
  Twox256: [32, false],
  Twox64Concat: [8, true]
};

function getStorageType(type) {
  if (type.isPlain) {
    return [false, type.asPlain.toString()];
  } else if (type.isDoubleMap) {
    return [false, type.asDoubleMap.value.toString()];
  }

  return [false, type.asMap.value.toString()];
} // we unwrap the type here, turning into an output usable for createType

/** @internal */


function unwrapStorageType(type, isOptional) {
  const [hasWrapper, outputType] = getStorageType(type);
  return isOptional && !hasWrapper ? `Option<${outputType}>` : outputType;
}
/** @internal */


function decodeStorageKey(value) {
  // eslint-disable-next-line @typescript-eslint/no-use-before-define
  if (value instanceof StorageKey) {
    return {
      key: value,
      method: value.method,
      section: value.section
    };
  } else if (!value || (0, _util.isString)(value) || (0, _util.isU8a)(value)) {
    // let Bytes handle these inputs
    return {
      key: value
    };
  } else if ((0, _util.isFunction)(value)) {
    return {
      key: value(),
      method: value.method,
      section: value.section
    };
  } else if (Array.isArray(value)) {
    const [fn, ...arg] = value;
    (0, _util.assert)((0, _util.isFunction)(fn), 'Expected function input for key construction');
    return {
      key: fn(...arg),
      method: fn.method,
      section: fn.section
    };
  }

  throw new Error(`Unable to convert input ${value} to StorageKey`);
}

function decodeHashers(registry, value, hashers) {
  // the storage entry is xxhashAsU8a(prefix, 128) + xxhashAsU8a(method, 128), 256 bits total
  let offset = 32;
  return hashers.reduce((result, [hasher, type]) => {
    const [hashLen, canDecode] = HASHER_MAP[hasher.type];
    const decoded = canDecode ? registry.createType(type, value.subarray(offset + hashLen)) : registry.createType('Raw', value.subarray(offset, offset + hashLen));
    offset += hashLen + (canDecode ? decoded.encodedLength : 0);
    result.push(decoded);
    return result;
  }, []);
}
/** @internal */


function decodeArgsFromMeta(registry, value, meta) {
  if (!meta || !(meta.type.isDoubleMap || meta.type.isMap)) {
    return [];
  }

  if (meta.type.isMap) {
    const mapInfo = meta.type.asMap;
    return decodeHashers(registry, value, [[mapInfo.hasher, mapInfo.key.toString()]]);
  }

  const mapInfo = meta.type.asDoubleMap;
  return decodeHashers(registry, value, [[mapInfo.hasher, mapInfo.key1.toString()], [mapInfo.key2Hasher, mapInfo.key2.toString()]]);
}
/**
 * @name StorageKey
 * @description
 * A representation of a storage key (typically hashed) in the system. It can be
 * constructed by passing in a raw key or a StorageEntry with (optional) arguments.
 */


class StorageKey extends _Bytes.default {
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore This is assigned via this.decodeArgsFromMeta()
  constructor(registry, value, override = {}) {
    const {
      key,
      method,
      section
    } = decodeStorageKey(value);
    super(registry, key);
    this._args = void 0;
    this._meta = void 0;
    this._outputType = void 0;
    this._method = void 0;
    this._section = void 0;
    this._method = override.method || method;
    this._section = override.section || section;
    this._outputType = StorageKey.getType(value); // decode the args (as applicable based on the key and the hashers, after all init)

    this.setMeta(StorageKey.getMeta(value));
  }

  static getMeta(value) {
    if (value instanceof StorageKey) {
      return value.meta;
    } else if ((0, _util.isFunction)(value)) {
      return value.meta;
    } else if (Array.isArray(value)) {
      const [fn] = value;
      return fn.meta;
    }

    return undefined;
  }

  static getType(value) {
    if (value instanceof StorageKey) {
      return value.outputType;
    } else if ((0, _util.isFunction)(value)) {
      return unwrapStorageType(value.meta.type);
    } else if (Array.isArray(value)) {
      const [fn] = value;

      if (fn.meta) {
        return unwrapStorageType(fn.meta.type);
      }
    } // If we have no type set, default to Raw


    return 'Raw';
  }
  /**
   * @description Return the decoded arguments (applicable to map/doublemap with decodable values)
   */


  get args() {
    return this._args;
  }
  /**
   * @description The metadata or `undefined` when not available
   */


  get meta() {
    return this._meta;
  }
  /**
   * @description The key method or `undefined` when not specified
   */


  get method() {
    return this._method;
  }
  /**
   * @description The output type
   */


  get outputType() {
    return this._outputType;
  }
  /**
   * @description The key section or `undefined` when not specified
   */


  get section() {
    return this._section;
  }
  /**
   * @description Sets the meta for this key
   */


  setMeta(meta) {
    this._meta = meta;

    if (meta) {
      this._outputType = unwrapStorageType(meta.type);
    }

    try {
      this._args = decodeArgsFromMeta(this.registry, this.toU8a(true), this.meta);
    } catch (error) {// ignore...
    }

    return this;
  }
  /**
   * @description Returns the Human representation for this type
   */


  toHuman() {
    return this._args.length ? this._args.map(arg => arg.toHuman()) : super.toHuman();
  }
  /**
   * @description Returns the raw type for this
   */


  toRawType() {
    return 'StorageKey';
  }

}

exports.default = StorageKey;

/***/ }),

/***/ "../../node_modules/@polkadot/types/primitive/Text.js":
/*!*****************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/primitive/Text.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classPrivateFieldLooseBase2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classPrivateFieldLooseBase */ "../../node_modules/@babel/runtime/helpers/classPrivateFieldLooseBase.js"));

var _classPrivateFieldLooseKey2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classPrivateFieldLooseKey */ "../../node_modules/@babel/runtime/helpers/classPrivateFieldLooseKey.js"));

var _util = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/index.js");

var _Compact = _interopRequireDefault(__webpack_require__(/*! ../codec/Compact */ "../../node_modules/@polkadot/types/codec/Compact.js"));

var _Raw = _interopRequireDefault(__webpack_require__(/*! ../codec/Raw */ "../../node_modules/@polkadot/types/codec/Raw.js"));

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
const MAX_LENGTH = 128 * 1024;
/** @internal */

function decodeText(value) {
  if ((0, _util.isHex)(value)) {
    return (0, _util.u8aToString)((0, _util.hexToU8a)(value.toString()));
  } else if (value instanceof Uint8Array) {
    if (!value.length) {
      return '';
    } // for Raw, the internal buffer does not have an internal length
    // (the same applies in e.g. Bytes, where length is added at encoding-time)


    if (value instanceof _Raw.default) {
      return (0, _util.u8aToString)(value);
    }

    const [offset, length] = _Compact.default.decodeU8a(value);

    const total = offset + length.toNumber();
    (0, _util.assert)(length.lten(MAX_LENGTH), `Text length ${length.toString()} exceeds ${MAX_LENGTH}`);
    (0, _util.assert)(total <= value.length, `Text: required length less than remainder, expected at least ${total}, found ${value.length}`);
    return (0, _util.u8aToString)(value.subarray(offset, total));
  }

  return value ? value.toString() : '';
}
/**
 * @name Text
 * @description
 * This is a string wrapper, along with the length. It is used both for strings as well
 * as items such as documentation. It simply extends the standard JS `String` built-in
 * object, inheriting all methods exposed from `String`.
 * @noInheritDoc
 */
// TODO
//   - Strings should probably be trimmed (docs do come through with extra padding)


var _override = (0, _classPrivateFieldLooseKey2.default)("override");

class Text extends String {
  constructor(registry, value) {
    super(decodeText(value));
    this.registry = void 0;
    Object.defineProperty(this, _override, {
      writable: true,
      value: null
    });
    this.registry = registry;
  }
  /**
   * @description The length of the value when encoded as a Uint8Array
   */


  get encodedLength() {
    return this.toU8a().length;
  }
  /**
   * @description returns a hash of the contents
   */


  get hash() {
    return this.registry.createType('H256', this.registry.hash(this.toU8a()));
  }
  /**
   * @description Checks if the value is an empty value
   */


  get isEmpty() {
    return this.length === 0;
  }
  /**
   * @description The length of the value
   */


  get length() {
    // only included here since we ignore inherited docs
    return super.length;
  }
  /**
   * @description Compares the value of the input to see if there is a match
   */


  eq(other) {
    return (0, _util.isString)(other) ? this.toString() === other.toString() : false;
  }
  /**
   * @description Set an override value for this
   */


  setOverride(override) {
    (0, _classPrivateFieldLooseBase2.default)(this, _override)[_override] = override;
  }
  /**
   * @description Returns a hex string representation of the value
   */


  toHex() {
    // like  with Vec<u8>, when we are encoding to hex, we don't actually add
    // the length prefix (it is already implied by the actual string length)
    return (0, _util.u8aToHex)(this.toU8a(true));
  }
  /**
   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
   */


  toHuman() {
    return this.toJSON();
  }
  /**
   * @description Converts the Object to JSON, typically used for RPC transfers
   */


  toJSON() {
    return this.toString();
  }
  /**
   * @description Returns the base runtime type name for this instance
   */


  toRawType() {
    return 'Text';
  }
  /**
   * @description Returns the string representation of the value
   */


  toString() {
    return (0, _classPrivateFieldLooseBase2.default)(this, _override)[_override] || super.toString();
  }
  /**
   * @description Encodes the value as a Uint8Array as per the SCALE specifications
   * @param isBare true when the value has none of the type-specific prefixes (internal)
   */


  toU8a(isBare) {
    // NOTE Here we use the super toString (we are not taking overrides into account,
    // rather encoding the original value the string was constructed with)
    const encoded = (0, _util.stringToU8a)(super.toString());
    return isBare ? encoded : _Compact.default.addLengthPrefix(encoded);
  }

}

exports.default = Text;

/***/ }),

/***/ "../../node_modules/@polkadot/types/primitive/Type.js":
/*!*****************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/primitive/Type.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _sanitize = _interopRequireDefault(__webpack_require__(/*! ../create/sanitize */ "../../node_modules/@polkadot/types/create/sanitize.js"));

var _Text = _interopRequireDefault(__webpack_require__(/*! ./Text */ "../../node_modules/@polkadot/types/primitive/Text.js"));

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name Type
 * @description
 * This is a extended version of String, specifically to handle types. Here we rely fully
 * on what string provides us, however we also adjust the types received from the runtime,
 * i.e. we remove the `T::` prefixes found in some types for consistency across implementation.
 */
class Type extends _Text.default {
  constructor(registry, value = '') {
    super(registry, value);
    this.setOverride((0, _sanitize.default)(this.toString()));
  }
  /**
   * @description Returns the base runtime type name for this instance
   */


  toRawType() {
    return 'Type';
  }

}

exports.default = Type;

/***/ }),

/***/ "../../node_modules/@polkadot/types/primitive/U128.js":
/*!*****************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/primitive/U128.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _UInt = _interopRequireDefault(__webpack_require__(/*! ../codec/UInt */ "../../node_modules/@polkadot/types/codec/UInt.js"));

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name U128
 * @description
 * A 128-bit unsigned integer
 */
class U128 extends _UInt.default.with(128) {}

exports.default = U128;

/***/ }),

/***/ "../../node_modules/@polkadot/types/primitive/U16.js":
/*!****************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/primitive/U16.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _UInt = _interopRequireDefault(__webpack_require__(/*! ../codec/UInt */ "../../node_modules/@polkadot/types/codec/UInt.js"));

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name U16
 * @description
 * A 16-bit unsigned integer
 */
class U16 extends _UInt.default.with(16) {}

exports.default = U16;

/***/ }),

/***/ "../../node_modules/@polkadot/types/primitive/U256.js":
/*!*****************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/primitive/U256.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _UInt = _interopRequireDefault(__webpack_require__(/*! ../codec/UInt */ "../../node_modules/@polkadot/types/codec/UInt.js"));

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name U256
 * @description
 * A 256-bit unsigned integer
 */
class U256 extends _UInt.default.with(256) {}

exports.default = U256;

/***/ }),

/***/ "../../node_modules/@polkadot/types/primitive/U32.js":
/*!****************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/primitive/U32.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _UInt = _interopRequireDefault(__webpack_require__(/*! ../codec/UInt */ "../../node_modules/@polkadot/types/codec/UInt.js"));

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name U32
 * @description
 * A 32-bit unsigned integer
 */
class U32 extends _UInt.default.with(32) {}

exports.default = U32;

/***/ }),

/***/ "../../node_modules/@polkadot/types/primitive/U64.js":
/*!****************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/primitive/U64.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _UInt = _interopRequireDefault(__webpack_require__(/*! ../codec/UInt */ "../../node_modules/@polkadot/types/codec/UInt.js"));

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name U64
 * @description
 * A 64-bit unsigned integer
 */
class U64 extends _UInt.default.with(64) {}

exports.default = U64;

/***/ }),

/***/ "../../node_modules/@polkadot/types/primitive/U8.js":
/*!***************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/primitive/U8.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _UInt = _interopRequireDefault(__webpack_require__(/*! ../codec/UInt */ "../../node_modules/@polkadot/types/codec/UInt.js"));

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name U8
 * @description
 * An 8-bit unsigned integer
 */
class U8 extends _UInt.default.with(8) {}

exports.default = U8;

/***/ }),

/***/ "../../node_modules/@polkadot/types/primitive/USize.js":
/*!******************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/primitive/USize.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _U = _interopRequireDefault(__webpack_require__(/*! ./U32 */ "../../node_modules/@polkadot/types/primitive/U32.js"));

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name USize
 * @description
 * A System default unsigned number, typically used in RPC to report non-consensus
 * data. It is a wrapper for [[U32]] as a WASM default (as generated by Rust bindings).
 * It is not to be used, since it created consensus mismatches.
 */
class USize extends _U.default {
  constructor(registry, value) {
    super(registry, value);
    throw new Error('The `usize` type should not be used. Since it is platform-specific, it creates incompatibilities between native (generally u64) and WASM (always u32) code. Use one of the `u32` or `u64` types explicitly.');
  }

}

exports.default = USize;

/***/ }),

/***/ "../../node_modules/@polkadot/types/primitive/index.js":
/*!******************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/primitive/index.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "BitVec", {
  enumerable: true,
  get: function () {
    return _BitVec.default;
  }
});
Object.defineProperty(exports, "bool", {
  enumerable: true,
  get: function () {
    return _Bool.default;
  }
});
Object.defineProperty(exports, "Bytes", {
  enumerable: true,
  get: function () {
    return _Bytes.default;
  }
});
Object.defineProperty(exports, "Data", {
  enumerable: true,
  get: function () {
    return _Data.default;
  }
});
Object.defineProperty(exports, "DoNotConstruct", {
  enumerable: true,
  get: function () {
    return _DoNotConstruct.default;
  }
});
Object.defineProperty(exports, "i8", {
  enumerable: true,
  get: function () {
    return _I.default;
  }
});
Object.defineProperty(exports, "i16", {
  enumerable: true,
  get: function () {
    return _I2.default;
  }
});
Object.defineProperty(exports, "i32", {
  enumerable: true,
  get: function () {
    return _I3.default;
  }
});
Object.defineProperty(exports, "i64", {
  enumerable: true,
  get: function () {
    return _I4.default;
  }
});
Object.defineProperty(exports, "i128", {
  enumerable: true,
  get: function () {
    return _I5.default;
  }
});
Object.defineProperty(exports, "i256", {
  enumerable: true,
  get: function () {
    return _I6.default;
  }
});
Object.defineProperty(exports, "Null", {
  enumerable: true,
  get: function () {
    return _Null.default;
  }
});
Object.defineProperty(exports, "StorageKey", {
  enumerable: true,
  get: function () {
    return _StorageKey.default;
  }
});
Object.defineProperty(exports, "Text", {
  enumerable: true,
  get: function () {
    return _Text.default;
  }
});
Object.defineProperty(exports, "Type", {
  enumerable: true,
  get: function () {
    return _Type.default;
  }
});
Object.defineProperty(exports, "u8", {
  enumerable: true,
  get: function () {
    return _U.default;
  }
});
Object.defineProperty(exports, "u16", {
  enumerable: true,
  get: function () {
    return _U2.default;
  }
});
Object.defineProperty(exports, "u32", {
  enumerable: true,
  get: function () {
    return _U3.default;
  }
});
Object.defineProperty(exports, "u64", {
  enumerable: true,
  get: function () {
    return _U4.default;
  }
});
Object.defineProperty(exports, "u128", {
  enumerable: true,
  get: function () {
    return _U5.default;
  }
});
Object.defineProperty(exports, "u256", {
  enumerable: true,
  get: function () {
    return _U6.default;
  }
});
Object.defineProperty(exports, "U256", {
  enumerable: true,
  get: function () {
    return _U6.default;
  }
});
Object.defineProperty(exports, "usize", {
  enumerable: true,
  get: function () {
    return _USize.default;
  }
});

var _BitVec = _interopRequireDefault(__webpack_require__(/*! ./BitVec */ "../../node_modules/@polkadot/types/primitive/BitVec.js"));

var _Bool = _interopRequireDefault(__webpack_require__(/*! ./Bool */ "../../node_modules/@polkadot/types/primitive/Bool.js"));

var _Bytes = _interopRequireDefault(__webpack_require__(/*! ./Bytes */ "../../node_modules/@polkadot/types/primitive/Bytes.js"));

var _Data = _interopRequireDefault(__webpack_require__(/*! ./Data */ "../../node_modules/@polkadot/types/primitive/Data.js"));

var _DoNotConstruct = _interopRequireDefault(__webpack_require__(/*! ./DoNotConstruct */ "../../node_modules/@polkadot/types/primitive/DoNotConstruct.js"));

var _I = _interopRequireDefault(__webpack_require__(/*! ./I8 */ "../../node_modules/@polkadot/types/primitive/I8.js"));

var _I2 = _interopRequireDefault(__webpack_require__(/*! ./I16 */ "../../node_modules/@polkadot/types/primitive/I16.js"));

var _I3 = _interopRequireDefault(__webpack_require__(/*! ./I32 */ "../../node_modules/@polkadot/types/primitive/I32.js"));

var _I4 = _interopRequireDefault(__webpack_require__(/*! ./I64 */ "../../node_modules/@polkadot/types/primitive/I64.js"));

var _I5 = _interopRequireDefault(__webpack_require__(/*! ./I128 */ "../../node_modules/@polkadot/types/primitive/I128.js"));

var _I6 = _interopRequireDefault(__webpack_require__(/*! ./I256 */ "../../node_modules/@polkadot/types/primitive/I256.js"));

var _Null = _interopRequireDefault(__webpack_require__(/*! ./Null */ "../../node_modules/@polkadot/types/primitive/Null.js"));

var _StorageKey = _interopRequireDefault(__webpack_require__(/*! ./StorageKey */ "../../node_modules/@polkadot/types/primitive/StorageKey.js"));

var _Text = _interopRequireDefault(__webpack_require__(/*! ./Text */ "../../node_modules/@polkadot/types/primitive/Text.js"));

var _Type = _interopRequireDefault(__webpack_require__(/*! ./Type */ "../../node_modules/@polkadot/types/primitive/Type.js"));

var _U = _interopRequireDefault(__webpack_require__(/*! ./U8 */ "../../node_modules/@polkadot/types/primitive/U8.js"));

var _U2 = _interopRequireDefault(__webpack_require__(/*! ./U16 */ "../../node_modules/@polkadot/types/primitive/U16.js"));

var _U3 = _interopRequireDefault(__webpack_require__(/*! ./U32 */ "../../node_modules/@polkadot/types/primitive/U32.js"));

var _U4 = _interopRequireDefault(__webpack_require__(/*! ./U64 */ "../../node_modules/@polkadot/types/primitive/U64.js"));

var _U5 = _interopRequireDefault(__webpack_require__(/*! ./U128 */ "../../node_modules/@polkadot/types/primitive/U128.js"));

var _U6 = _interopRequireDefault(__webpack_require__(/*! ./U256 */ "../../node_modules/@polkadot/types/primitive/U256.js"));

var _USize = _interopRequireDefault(__webpack_require__(/*! ./USize */ "../../node_modules/@polkadot/types/primitive/USize.js"));

/***/ }),

/***/ "../../node_modules/@polkadot/types/types/calls.js":
/*!**************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/types/calls.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),

/***/ "../../node_modules/@polkadot/types/types/codec.js":
/*!**************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/types/codec.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),

/***/ "../../node_modules/@polkadot/types/types/definitions.js":
/*!********************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/types/definitions.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),

/***/ "../../node_modules/@polkadot/types/types/extrinsic.js":
/*!******************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/types/extrinsic.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),

/***/ "../../node_modules/@polkadot/types/types/helpers.js":
/*!****************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/types/helpers.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),

/***/ "../../node_modules/@polkadot/types/types/index.js":
/*!**************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/types/index.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

__webpack_require__(/*! @polkadot/types/augment */ "../../node_modules/@polkadot/types/augment/index.js");

var _types = __webpack_require__(/*! ../create/types */ "../../node_modules/@polkadot/types/create/types.js");

Object.keys(_types).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _types[key];
    }
  });
});

var _calls = __webpack_require__(/*! ./calls */ "../../node_modules/@polkadot/types/types/calls.js");

Object.keys(_calls).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _calls[key];
    }
  });
});

var _codec = __webpack_require__(/*! ./codec */ "../../node_modules/@polkadot/types/types/codec.js");

Object.keys(_codec).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _codec[key];
    }
  });
});

var _definitions = __webpack_require__(/*! ./definitions */ "../../node_modules/@polkadot/types/types/definitions.js");

Object.keys(_definitions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _definitions[key];
    }
  });
});

var _extrinsic = __webpack_require__(/*! ./extrinsic */ "../../node_modules/@polkadot/types/types/extrinsic.js");

Object.keys(_extrinsic).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _extrinsic[key];
    }
  });
});

var _helpers = __webpack_require__(/*! ./helpers */ "../../node_modules/@polkadot/types/types/helpers.js");

Object.keys(_helpers).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _helpers[key];
    }
  });
});

var _interfaces = __webpack_require__(/*! ./interfaces */ "../../node_modules/@polkadot/types/types/interfaces.js");

Object.keys(_interfaces).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _interfaces[key];
    }
  });
});

var _registry = __webpack_require__(/*! ./registry */ "../../node_modules/@polkadot/types/types/registry.js");

Object.keys(_registry).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _registry[key];
    }
  });
});

/***/ }),

/***/ "../../node_modules/@polkadot/types/types/interfaces.js":
/*!*******************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/types/interfaces.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),

/***/ "../../node_modules/@polkadot/types/types/registry.js":
/*!*****************************************************************!*\
  !*** /root/apps/node_modules/@polkadot/types/types/registry.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ })

}]);